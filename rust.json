{
    "AdjacencyMatrix": {
      "prefix": "AdjacencyMatrix",
      "body": [
        "struct AdjacencyMatrix {",
        "    a: Vec<Vec<i64>>,",
        "}",
        "impl AdjacencyMatrix {",
        "    pub fn new(n: usize, inf: i64) -> Self {",
        "        let mut a = vec![vec![inf; n]; n];",
        "        for i in 0..n {",
        "            a[i][i] = 0;",
        "        }",
        "        AdjacencyMatrix { a: a }",
        "    }",
        "    pub fn add_edge(&mut self, u: usize, v: usize, cost: i64) {",
        "        self.a[u][v] = cost;",
        "    }",
        "    pub fn build(&self) -> Vec<Vec<i64>> {",
        "        self.a.clone()",
        "    }",
        "}"
      ]
    },
    "ArithSeq": {
      "prefix": "ArithSeq",
      "body": [
        "pub struct ArithSeq {",
        "    pub a: i64,",
        "    pub b: i64,",
        "}",
        "impl ArithSeq {",
        "    ///y=ax+b",
        "    pub fn new(a: i64, b: i64) -> Self {",
        "        ArithSeq { a: a, b: b }",
        "    }",
        "    /// (x0,y0)を通る傾きaの直線を求める",
        "    pub fn from_point(x0: i64, y0: i64, a: i64) -> Self {",
        "        let b = y0 - a * x0;",
        "        Self::new(a, b)",
        "    }",
        "    pub fn y(&self, x0: i64) -> i64 {",
        "        self.a * x0 + self.b",
        "    }",
        "    /// ceil(y=y0との交点)",
        "    pub fn x_ceil(&self, y: i64) -> i64 {",
        "        assert!(self.a != 0);",
        "        let a = self.a;",
        "        let b = self.b;",
        "        if a > 0 {",
        "            let mut x = y - b;",
        "            if x >= 0 {",
        "                x += a - 1;",
        "            } else {",
        "            }",
        "            let x = x / a;",
        "            x",
        "        } else {",
        "            let c = 2 * y - b;",
        "            let mirror = Self::new(-a, c);",
        "            mirror.x_ceil(y)",
        "        }",
        "    }",
        "    /// floor(y=y0との交点)",
        "    pub fn x_floor(&self, y0: i64) -> i64 {",
        "        let x0 = self.x_ceil(y0);",
        "        let y = self.y(x0);",
        "        if y == y0 {",
        "            return x0;",
        "        }",
        "        if self.a > 0 && y > y0 {",
        "            x0 - 1",
        "        } else if self.a < 0 && y < y0 {",
        "            x0 - 1",
        "        } else {",
        "            x0",
        "        }",
        "    }",
        "}"
      ]
    },
    "Array": {
      "prefix": "Array",
      "body": [
        "/// i64でアクセス出来るテーブル",
        "/// 迷路問題など、境界処理をしなければいけない場合、インデックスにi64を使える方が便利である。",
        "/// 単に上下左右に足し引きして、境界内かどうかチェックすればいいだけになるため。",
        "#[derive(Debug, Clone, PartialEq)]",
        "pub struct Array1d<T> {",
        "    v: Vec<T>,",
        "}",
        "impl<T> Array1d<T> {",
        "    pub fn new(v: Vec<T>) -> Self {",
        "        Array1d { v }",
        "    }",
        "}",
        "impl<T> std::ops::Index<i64> for Array1d<T> {",
        "    type Output = T;",
        "    fn index(&self, i: i64) -> &Self::Output {",
        "        &self.v[i as usize]",
        "    }",
        "}",
        "impl<T> std::ops::IndexMut<i64> for Array1d<T> {",
        "    fn index_mut(&mut self, i: i64) -> &mut Self::Output {",
        "        &mut self.v[i as usize]",
        "    }",
        "}",
        "#[derive(Debug, Clone, PartialEq)]",
        "pub struct Array2d<T> {",
        "    v: Vec<Array1d<T>>,",
        "}",
        "impl<T> Array2d<T> {",
        "    pub fn new(v: Vec<Vec<T>>) -> Self {",
        "        let mut vv = vec![];",
        "        for row in v {",
        "            vv.push(Array1d::new(row));",
        "        }",
        "        Array2d { v: vv }",
        "    }",
        "}",
        "impl<T> std::ops::Index<i64> for Array2d<T> {",
        "    type Output = Array1d<T>;",
        "    fn index(&self, i: i64) -> &Self::Output {",
        "        &self.v[i as usize]",
        "    }",
        "}",
        "impl<T> std::ops::IndexMut<i64> for Array2d<T> {",
        "    fn index_mut(&mut self, i: i64) -> &mut Self::Output {",
        "        &mut self.v[i as usize]",
        "    }",
        "}"
      ]
    },
    "BIT": {
      "prefix": "BIT",
      "body": [
        "/// フェニック木",
        "///",
        "/// a1,a2,...,aN (1-indexed)",
        "/// の数列に対して、",
        "/// add i x: aiにxを足す",
        "/// sum k: a1+a2+...+akを求める。",
        "///",
        "/// 計算量:",
        "/// ともにO(logN)",
        "///",
        "/// sumがa1からの和を調べる特殊性から、",
        "/// 2Nの容量を必要としない。",
        "///",
        "/// 計算量だけ見れば、セグ木で十分だが、係数が軽い。",
        "#[allow(dead_code)]",
        "pub struct BIT<T> {",
        "    buf: Vec<T>,",
        "}",
        "#[allow(dead_code)]",
        "impl<T: Clone + Default + std::ops::AddAssign> BIT<T> {",
        "    pub fn new(n: usize) -> BIT<T> {",
        "        BIT {",
        "            buf: vec![T::default(); n + 1],",
        "        }",
        "    }",
        "    pub fn sum(&self, i: usize) -> T {",
        "        let mut i = i as i64;",
        "        let mut s = T::default();",
        "        while i > 0 {",
        "            s += self.buf[i as usize].clone();",
        "            i -= i & -i;",
        "        }",
        "        s",
        "    }",
        "    pub fn add(&mut self, i: usize, x: T) {",
        "        let mut i = i as i64;",
        "        while i < self.buf.len() as i64 {",
        "            self.buf[i as usize] += x.clone();",
        "            i += i & -i;",
        "        }",
        "    }",
        "}"
      ]
    },
    "BSGSable": {
      "prefix": "BSGSable",
      "body": [
        "pub trait BSGSable {",
        "    type T: std::fmt::Debug;",
        "    type K: std::hash::Hash + std::cmp::Eq;",
        "    fn inv(x: &Self::T, mo: u64) -> Self::T;",
        "    fn unit() -> Self::T;",
        "    fn multiply(x: &Self::T, y: &Self::T, mo: u64) -> Self::T;",
        "    fn unique_key_for(x: &Self::T) -> Self::K;",
        "}"
      ]
    },
    "Bag": {
      "prefix": "Bag",
      "body": [
        "struct Bag<T> {",
        "    h: HashMap<T, usize>,",
        "}"
      ]
    },
    "BinarySearch": {
      "prefix": "BinarySearch",
      "body": [
        "///lower,upper are inclusive range",
        "pub struct BinarySearch<F> {",
        "    pub f: F,",
        "    pub l: i64,",
        "    pub r: i64,",
        "}",
        "impl<F: FnMut(i64) -> bool> BinarySearch<F> {",
        "    ///O(log(upper-lower))",
        "    pub fn lower_bound(&mut self) -> i64 {",
        "        assert!(self.l <= self.r);",
        "        let mut l = self.l;",
        "        let mut r = self.r;",
        "        while r > l {",
        "            let mid = (l + r) / 2;",
        "            let ok = (self.f)(mid);",
        "            if ok {",
        "                r = mid;",
        "            } else {",
        "                l = mid + 1;",
        "            }",
        "        }",
        "        l",
        "    }",
        "}"
      ]
    },
    "BinarySearchf64": {
      "prefix": "BinarySearchf64",
      "body": [
        "struct BinarySearchf64<F> {",
        "    lb: f64,",
        "    ub: f64,",
        "    f: F,",
        "}",
        "impl<F: FnMut(f64) -> bool> BinarySearchf64<F> {",
        "    const eps: f64 = 1e-9;",
        "    fn new(lb: f64, ub: f64, f: F) -> BinarySearchf64<F> {",
        "        BinarySearchf64 {",
        "            lb: lb,",
        "            ub: ub,",
        "            f: f,",
        "        }",
        "    }",
        "    fn search(&mut self) -> f64 {",
        "        let mut lb = self.lb;",
        "        let mut ub = self.ub;",
        "        while ub > lb + Self::eps {",
        "            let mid = (lb + ub) / 2.0;",
        "            if (self.f)(mid) {",
        "                ub = mid;",
        "            } else {",
        "                lb = mid;",
        "            }",
        "        }",
        "        lb",
        "    }",
        "}"
      ]
    },
    "BipartiteMatching": {
      "prefix": "BipartiteMatching",
      "body": [
        "/// 二部グラフというのは、",
        "/// 頂点集合を２つに分割して、各集合の頂点はお互いに隣接しないようなグラフである。",
        "/// 隣合うノードに白黒と色をつけていくことで二部グラフかどうかを判定する。",
        "pub fn isbipartite(g: &[HashSet<usize>]) -> bool {",
        "    struct Rec<'a> {",
        "        g: &'a [HashSet<usize>],",
        "        color: Vec<i8>,",
        "    }",
        "    impl<'a> Rec<'a> {",
        "        fn solve(&mut self, u: usize, color: i8) -> bool {",
        "            self.color[u] = color;",
        "            let mut ok = true;",
        "            for &v in &self.g[u] {",
        "                if self.color[v] == 0 {",
        "                    if !self.solve(v, -1 * color) {",
        "                        ok = false",
        "                    }",
        "                } else {",
        "                    if self.color[v] == color {",
        "                        ok = false",
        "                    }",
        "                }",
        "            }",
        "            ok",
        "        }",
        "    }",
        "    let n = g.len();",
        "    let mut rec = Rec {",
        "        g: g,",
        "        color: vec![0; n],",
        "    };",
        "    rec.solve(0, 1)",
        "}",
        "/// 二部グラフの中から、最大マッチングを列挙する。",
        "///",
        "/// アイデア:",
        "/// 増加路を探しまくる。",
        "/// 増加路が存在しない <=> 最大マッチング",
        "/// が言える。",
        "///",
        "/// 計算量:",
        "/// O(V(V+E))",
        "fn find_max_bipartite_matching(g_list: &[HashSet<usize>]) -> Vec<(usize, usize)> {",
        "    fn dfs(",
        "        v: usize,",
        "        g_list: &[HashSet<usize>],",
        "        used: &mut [bool],",
        "        matching: &mut [Option<usize>],",
        "    ) -> bool {",
        "        used[v] = true;",
        "        for &u in &g_list[v] {",
        "            let w = matching[u];",
        "            if w.is_none() || (!used[w.unwrap()] && dfs(w.unwrap(), g_list, used, matching)) {",
        "                matching[v] = Some(u);",
        "                matching[u] = Some(v);",
        "                return true;",
        "            }",
        "        }",
        "        false",
        "    }",
        "    let n = g_list.len();",
        "    let mut matching = vec![None; n];",
        "    for v in 0..n {",
        "        if matching[v].is_none() {",
        "            let mut used = vec![false; n];",
        "            dfs(v, g_list, &mut used, &mut matching);",
        "        }",
        "    }",
        "    let mut res = vec![];",
        "    for u in 0..matching.len() {",
        "        let v0 = matching[u];",
        "        if v0.is_some() {",
        "            let v = v0.unwrap();",
        "            assert!(u != v);",
        "            if u < v {",
        "                res.push((u, v));",
        "            }",
        "        }",
        "    }",
        "    res",
        "}",
        "struct BipartiteMatching {",
        "    g: Vec<HashSet<usize>>,",
        "}",
        "impl BipartiteMatching {",
        "    pub fn new(n: usize) -> BipartiteMatching {",
        "        BipartiteMatching {",
        "            g: vec![HashSet::new(); n],",
        "        }",
        "    }",
        "    pub fn connect(&mut self, u: usize, v: usize) {",
        "        assert!(u != v);",
        "        self.g[u].insert(v);",
        "        self.g[v].insert(u);",
        "    }",
        "    pub fn solve(&self) -> Option<Vec<(usize, usize)>> {",
        "        if isbipartite(&self.g) {",
        "            Some(find_max_bipartite_matching(&self.g))",
        "        } else {",
        "            None",
        "        }",
        "    }",
        "}"
      ]
    },
    "BitOp": {
      "prefix": "BitOp",
      "body": [
        "/// bit演算を行うクラス",
        "/// 計算量: 全部O(1)",
        "struct BitOp {",
        "    x: i64,",
        "}",
        "impl BitOp {",
        "    pub fn new(x: i64) -> Self {",
        "        Self { x: x }",
        "    }",
        "    pub fn check(&self, k: usize) -> bool {",
        "        self.x & (1 << k) > 0",
        "    }",
        "    pub fn on(&self, k: usize) -> i64 {",
        "        self.x | (1 << k)",
        "    }",
        "    pub fn off(&self, k: usize) -> i64 {",
        "        let mask = !(1 << k);",
        "        self.x & mask",
        "    }",
        "    pub fn flip(&self, k: usize) -> i64 {",
        "        self.x ^ (1 << k)",
        "    }",
        "    /// もっとも右に立ってるビットのみを返す。",
        "    /// 例: 0x1010 -> 0x10",
        "    pub fn lsb(&self) -> i64 {",
        "        let x = self.x;",
        "        x & -x",
        "    }",
        "}"
      ]
    },
    "BitSet": {
      "prefix": "BitSet",
      "body": [
        "const TRUE: &'static bool = &true;",
        "const FALSE: &'static bool = &false;",
        "#[derive(Clone, Debug)]",
        "/// Efficient bool collection",
        "pub struct BitSet {",
        "    buf: Vec<u64>,",
        "    size: usize,",
        "}",
        "impl BitSet {",
        "    #[allow(dead_code)]",
        "    pub fn new(size: usize) -> BitSet {",
        "        BitSet {",
        "            buf: vec![0; (size + 63) / 64],",
        "            size: size,",
        "        }",
        "    }",
        "    #[allow(dead_code)]",
        "    pub fn set(&mut self, i: usize, b: bool) {",
        "        assert!(i < self.size);",
        "        if b {",
        "            self.buf[i >> 6] |= 1 << (i & 63);",
        "        } else {",
        "            self.buf[i >> 6] &= !(1 << (i & 63));",
        "        }",
        "    }",
        "    #[allow(dead_code)]",
        "    pub fn count_ones(&self) -> usize {",
        "        let sum: u32 = self.buf.iter().map(|x| x.count_ones()).sum();",
        "        sum as usize",
        "    }",
        "    #[allow(dead_code)]",
        "    fn chomp(&mut self) {",
        "        let r = self.size & 63;",
        "        if r != 0 {",
        "            if let Some(x) = self.buf.last_mut() {",
        "                let d = 64 - r;",
        "                *x = (*x << d) >> d;",
        "            }",
        "        }",
        "    }",
        "}",
        "impl std::ops::Index<usize> for BitSet {",
        "    type Output = bool;",
        "    fn index(&self, index: usize) -> &bool {",
        "        [FALSE, TRUE][(self.buf[index >> 6] >> (index & 63)) as usize & 1]",
        "    }",
        "}",
        "impl std::ops::ShlAssign<usize> for BitSet {",
        "    fn shl_assign(&mut self, x: usize) {",
        "        let q = x >> 6;",
        "        let r = x & 63;",
        "        if q >= self.buf.len() {",
        "            for x in &mut self.buf {",
        "                *x = 0;",
        "            }",
        "            return;",
        "        }",
        "        if r == 0 {",
        "            for i in (q..self.buf.len()).rev() {",
        "                self.buf[i] = self.buf[i - q];",
        "            }",
        "        } else {",
        "            for i in (q + 1..self.buf.len()).rev() {",
        "                self.buf[i] = (self.buf[i - q] << r) | (self.buf[i - q - 1] >> (64 - r));",
        "            }",
        "            self.buf[q] = self.buf[0] << r;",
        "        }",
        "        for x in &mut self.buf[..q] {",
        "            *x = 0;",
        "        }",
        "        self.chomp();",
        "    }",
        "}",
        "impl std::ops::Shl<usize> for BitSet {",
        "    type Output = Self;",
        "    fn shl(mut self, x: usize) -> Self {",
        "        self <<= x;",
        "        self",
        "    }",
        "}",
        "impl std::ops::ShrAssign<usize> for BitSet {",
        "    fn shr_assign(&mut self, x: usize) {",
        "        let q = x >> 6;",
        "        let r = x & 63;",
        "        if q >= self.buf.len() {",
        "            for x in &mut self.buf {",
        "                *x = 0;",
        "            }",
        "            return;",
        "        }",
        "        if r == 0 {",
        "            for i in 0..self.buf.len() - q {",
        "                self.buf[i] = self.buf[i + q];",
        "            }",
        "        } else {",
        "            for i in 0..self.buf.len() - q - 1 {",
        "                self.buf[i] = (self.buf[i + q] >> r) | (self.buf[i + q + 1] << (64 - r));",
        "            }",
        "            let len = self.buf.len();",
        "            self.buf[len - q - 1] = self.buf[len - 1] >> r;",
        "        }",
        "        let len = self.buf.len();",
        "        for x in &mut self.buf[len - q..] {",
        "            *x = 0;",
        "        }",
        "    }",
        "}",
        "impl std::ops::Shr<usize> for BitSet {",
        "    type Output = Self;",
        "    fn shr(mut self, x: usize) -> Self {",
        "        self >>= x;",
        "        self",
        "    }",
        "}",
        "impl<'a> std::ops::BitAndAssign<&'a BitSet> for BitSet {",
        "    fn bitand_assign(&mut self, rhs: &'a Self) {",
        "        for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {",
        "            *a &= *b;",
        "        }",
        "    }",
        "}",
        "impl<'a> std::ops::BitAnd<&'a BitSet> for BitSet {",
        "    type Output = Self;",
        "    fn bitand(mut self, rhs: &'a Self) -> Self {",
        "        self &= rhs;",
        "        self",
        "    }",
        "}",
        "impl<'a> std::ops::BitOrAssign<&'a BitSet> for BitSet {",
        "    fn bitor_assign(&mut self, rhs: &'a Self) {",
        "        for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {",
        "            *a |= *b;",
        "        }",
        "        self.chomp();",
        "    }",
        "}",
        "impl<'a> std::ops::BitOr<&'a BitSet> for BitSet {",
        "    type Output = Self;",
        "    fn bitor(mut self, rhs: &'a Self) -> Self {",
        "        self |= rhs;",
        "        self",
        "    }",
        "}",
        "impl<'a> std::ops::BitXorAssign<&'a BitSet> for BitSet {",
        "    fn bitxor_assign(&mut self, rhs: &'a Self) {",
        "        for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {",
        "            *a ^= *b;",
        "        }",
        "        self.chomp();",
        "    }",
        "}",
        "impl<'a> std::ops::BitXor<&'a BitSet> for BitSet {",
        "    type Output = Self;",
        "    fn bitxor(mut self, rhs: &'a Self) -> Self {",
        "        self ^= rhs;",
        "        self",
        "    }",
        "}"
      ]
    },
    "Boundary": {
      "prefix": "Boundary",
      "body": [
        "struct Boundary {",
        "    l: i64,",
        "    r: i64,",
        "}",
        "impl Boundary {",
        "    pub fn new(n: usize) -> Self {",
        "        Self { l: 0, r: n as i64 }",
        "    }",
        "    pub fn add(&self, x: usize, diff: i64) -> Option<usize> {",
        "        let x = x as i64;",
        "        let y = x + diff;",
        "        if y > self.r - 1 {",
        "            None",
        "        } else if y < self.l {",
        "            None",
        "        } else {",
        "            Some(y as usize)",
        "        }",
        "    }",
        "}",
        "struct Boundary2d {",
        "    h: Boundary,",
        "    w: Boundary,",
        "}",
        "impl Boundary2d {",
        "    pub fn new(h: usize, w: usize) -> Self {",
        "        Self {",
        "            h: Boundary::new(h),",
        "            w: Boundary::new(w),",
        "        }",
        "    }",
        "    pub fn add(&self, p: (usize, usize), diff: (i64, i64)) -> Option<(usize, usize)> {",
        "        let x = self.h.add(p.0, diff.0);",
        "        let y = self.w.add(p.1, diff.1);",
        "        match (x, y) {",
        "            (Some(a), Some(b)) => Some((a, b)),",
        "            _ => None,",
        "        }",
        "    }",
        "}"
      ]
    },
    "ConvexHullTrick": {
      "prefix": "ConvexHullTrick",
      "body": [
        "#[derive(Clone, Copy)]",
        "struct Line {",
        "    a: i64,",
        "    b: i64,",
        "}",
        "impl Line {",
        "    ///y=ax+b",
        "    pub fn new(a: i64, b: i64) -> Line {",
        "        Line { a: a, b: b }",
        "    }",
        "    pub fn y(&self, x: i64) -> i64 {",
        "        self.a * x + self.b",
        "    }",
        "}",
        "struct ConvexHullTrick {",
        "    lines: Vec<(i64, i64)>,",
        "}",
        "impl ConvexHullTrick {",
        "    pub fn new() -> ConvexHullTrick {",
        "        ConvexHullTrick { lines: vec![] }",
        "    }",
        "    fn check(l1: (i64, i64), l2: (i64, i64), l3: (i64, i64)) -> bool {",
        "        let mut l1 = l1;",
        "        let mut l3 = l3;",
        "        if l1 < l3 {",
        "            std::mem::swap(&mut l1, &mut l3);",
        "        }",
        "        (l3.1 - l2.1) * (l2.0 - l1.0) >= (l2.1 - l1.1) * (l3.0 - l2.0)",
        "    }",
        "    ///add a line f(x)=ax+b",
        "    pub fn add(&mut self, line: Line) {",
        "        let line = (line.a, line.b);",
        "        while self.lines.len() >= 2",
        "            && Self::check(",
        "                self.lines[self.lines.len() - 2],",
        "                self.lines[self.lines.len() - 1],",
        "                line,",
        "            )",
        "        {",
        "            self.lines.pop();",
        "        }",
        "        self.lines.push(line);",
        "    }",
        "    pub fn f(&self, i: usize, x: i64) -> i64 {",
        "        let line = self.lines[i];",
        "        line.0 * x + line.1",
        "    }",
        "    ///lower: l>=r, upper: l<=r",
        "    fn get<F: Fn(i64, i64) -> bool>(&self, x: i64, comp: F) -> Line {",
        "        let mut low: i64 = -1;",
        "        let mut high: i64 = (self.lines.len() - 1) as i64;",
        "        while high - low > 1 {",
        "            let mid = (high + low) / 2;",
        "            if comp(self.f(mid as usize, x), self.f((mid + 1) as usize, x)) {",
        "                low = mid;",
        "            } else {",
        "                high = mid;",
        "            }",
        "        }",
        "        let (a, b) = self.lines[high as usize];",
        "        Line { a: a, b: b }",
        "    }",
        "    pub fn get_upper(&self, x: i64) -> Line {",
        "        self.get(x, |l, r| l <= r)",
        "    }",
        "    pub fn get_lower(&self, x: i64) -> Line {",
        "        self.get(x, |l, r| l >= r)",
        "    }",
        "}"
      ]
    },
    "CoordCompression": {
      "prefix": "CoordCompression",
      "body": [
        "pub struct CoordCompression {",
        "    comp: std::collections::HashMap<i64, usize>,",
        "    dcmp: std::collections::HashMap<usize, i64>,",
        "}",
        "impl CoordCompression {",
        "    pub fn new(xs: &[i64], start: usize, step: usize) -> CoordCompression {",
        "        let mut xs = xs.to_owned();",
        "        xs.sort();",
        "        let mut comp = std::collections::HashMap::new();",
        "        let mut dcmp = std::collections::HashMap::new();",
        "        let mut acc = start;",
        "        for x in xs {",
        "            if comp.contains_key(&x) {",
        "                continue;",
        "            }",
        "            comp.insert(x, acc);",
        "            dcmp.insert(acc, x);",
        "            acc += step;",
        "        }",
        "        CoordCompression {",
        "            comp: comp,",
        "            dcmp: dcmp,",
        "        }",
        "    }",
        "    pub fn compress(&self, x: i64) -> usize {",
        "        *self.comp.get(&x).unwrap()",
        "    }",
        "    pub fn decompress(&self, x: usize) -> i64 {",
        "        *self.dcmp.get(&x).unwrap()",
        "    }",
        "    pub fn n(&self) -> usize {",
        "        self.comp.len()",
        "    }",
        "}"
      ]
    },
    "CumRL": {
      "prefix": "CumRL",
      "body": [
        "/// 全方位木DP",
        "///  ",
        "/// 木において、ある頂点uの入辺v->uの値をDP[u,v]で表すことにする。",
        "/// これを効率的に求めるアルゴリズムである。",
        "///",
        "/// 解説: https://www.akiradeveloper.com/post/algorithm-rerooting/",
        "/// 木であるが、辺は有向として、各方向に値を格納出来るようにしている。",
        "/// （アルゴリズムの実行のためにはbidirectionalにする必要がある）",
        "/// 頂点や辺の値は、DPの計算に利用することが出来る。",
        "trait Foldable {",
        "    type T: Clone + std::fmt::Debug;",
        "    fn id() -> Self::T;",
        "    fn fold(acc: Self::T, x: Self::T) -> Self::T;",
        "}",
        "#[derive(Clone, Debug)]",
        "struct CumRL<F: Foldable> {",
        "    lcum: Vec<F::T>,",
        "    rcum: Vec<F::T>,",
        "}",
        "impl<F: Foldable> CumRL<F> {",
        "    pub fn new(elems: Vec<F::T>) -> CumRL<F> {",
        "        let n = elems.len();",
        "        let mut lcum = vec![F::id()];",
        "        for i in 0..n {",
        "            let x = F::fold(lcum[i].clone(), elems[i].clone());",
        "            lcum.push(x);",
        "        }",
        "        let mut elems = elems;",
        "        elems.reverse();",
        "        let mut rcum = vec![F::id()];",
        "        for i in 0..n {",
        "            let x = F::fold(rcum[i].clone(), elems[i].clone());",
        "            rcum.push(x);",
        "        }",
        "        CumRL {",
        "            lcum: lcum,",
        "            rcum: rcum,",
        "        }",
        "    }",
        "    pub fn len(&self) -> usize {",
        "        self.lcum.len() - 1",
        "    }",
        "    pub fn lcum(&self, len: usize) -> F::T {",
        "        self.lcum[len].clone()",
        "    }",
        "    pub fn rcum(&self, len: usize) -> F::T {",
        "        self.rcum[len].clone()",
        "    }",
        "}"
      ]
    },
    "CycleDetection": {
      "prefix": "CycleDetection",
      "body": [
        "/// 有向グラフに対してサイクルの存在判定を行う。",
        "///",
        "/// アイデア:",
        "/// サイクルの周りにある辺を全部カットする。",
        "/// 入次数0の頂点から辿っていき、その都度辺をカットしていく。",
        "/// 最終的に、入次数が0にならないということは、その頂点がサイクルの一部だということである。",
        "///",
        "/// 計算量: O(E)",
        "/// 最悪ケースで全辺を辿るため",
        "fn cycle_detection_directed(g: &[Vec<usize>]) -> bool {",
        "    let n = g.len();",
        "    let mut in_g = vec![HashSet::new(); n];",
        "    for v in 0..n {",
        "        for &u in &g[v] {",
        "            in_g[u].insert(v);",
        "        }",
        "    }",
        "    let mut v_indegree0 = vec![];",
        "    for v in 0..n {",
        "        if in_g[v].len() == 0 {",
        "            v_indegree0.push(v);",
        "        }",
        "    }",
        "    let mut m = 0;",
        "    while let Some(v) = v_indegree0.pop() {",
        "        m += 1;",
        "        for &to in &g[v] {",
        "            if in_g[to].remove(&v) && in_g[to].is_empty() {",
        "                v_indegree0.push(to);",
        "            }",
        "        }",
        "    }",
        "    m != n",
        "}",
        "struct CycleDetection {",
        "    g: Vec<Vec<usize>>,",
        "}",
        "impl CycleDetection {",
        "    pub fn new(n: usize) -> CycleDetection {",
        "        CycleDetection { g: vec![vec![]; n] }",
        "    }",
        "    pub fn add_edge(&mut self, u: usize, v: usize) {",
        "        self.g[u].push(v);",
        "    }",
        "    pub fn solve(&self) -> bool {",
        "        cycle_detection_directed(&self.g)",
        "    }",
        "}"
      ]
    },
    "Dfa": {
      "prefix": "Dfa",
      "body": [
        "trait Dfa {",
        "    type Alphabet;",
        "    type State;",
        "    fn init(&self) -> Self::State;",
        "    fn next(&self, s: Self::State, a: Self::Alphabet, i: usize) -> Self::State;",
        "    fn accept(&self, s: Self::State) -> bool;",
        "}",
        "fn count<X: Dfa>(dfa: &X, n: usize, alphabet: &[X::Alphabet], modulo: u32) -> u32",
        "where",
        "    X::Alphabet: Copy,",
        "    X::State: Eq + Hash + Copy,",
        "{",
        "    let mut dp = HashMap::new();",
        "    let mut dp2 = HashMap::new();",
        "    dp.insert(dfa.init(), 1_u64);",
        "    for i in 0..n {",
        "        for (s, k) in dp.drain() {",
        "            let k = k % modulo as u64;",
        "            for &a in alphabet {",
        "                let s1 = dfa.next(s, a, i);",
        "                *dp2.entry(s1).or_insert(0) += k;",
        "            }",
        "        }",
        "        std::mem::swap(&mut dp, &mut dp2);",
        "    }",
        "    let mut sum = 0;",
        "    for (s, k) in dp {",
        "        if dfa.accept(s) {",
        "            sum += k;",
        "            sum %= modulo as u64",
        "        }",
        "    }",
        "    sum as u32",
        "}",
        "struct Leq<'a>(&'a [u8]);",
        "impl Dfa for Leq<'_> {",
        "    type Alphabet = u8;",
        "    type State = Ordering;",
        "    fn init(&self) -> Self::State {",
        "        Ordering::Equal",
        "    }",
        "    fn next(&self, s: Self::State, a: Self::Alphabet, i: usize) -> Self::State {",
        "        s.then(a.cmp(&self.0[i]))",
        "    }",
        "    fn accept(&self, s: Self::State) -> bool {",
        "        s != Ordering::Greater",
        "    }",
        "}",
        "struct Lt<'a>(&'a [u8]);",
        "impl Dfa for Lt<'_> {",
        "    type Alphabet = u8;",
        "    type State = Ordering;",
        "    fn init(&self) -> Self::State {",
        "        Ordering::Equal",
        "    }",
        "    fn next(&self, s: Self::State, a: Self::Alphabet, i: usize) -> Self::State {",
        "        s.then(a.cmp(&self.0[i]))",
        "    }",
        "    fn accept(&self, s: Self::State) -> bool {",
        "        s == Ordering::Less",
        "    }",
        "}",
        "struct And<X, Y>(X, Y);",
        "impl<X: Dfa<Alphabet = A>, Y: Dfa<Alphabet = A>, A: Copy> Dfa for And<X, Y> {",
        "    type Alphabet = A;",
        "    type State = (X::State, Y::State);",
        "    fn init(&self) -> Self::State {",
        "        (self.0.init(), self.1.init())",
        "    }",
        "    fn next(&self, (s0, s1): Self::State, a: Self::Alphabet, i: usize) -> Self::State {",
        "        (self.0.next(s0, a, i), self.1.next(s1, a, i))",
        "    }",
        "    fn accept(&self, (s0, s1): Self::State) -> bool {",
        "        self.0.accept(s0) && self.1.accept(s1)",
        "    }",
        "}",
        "struct Not<X>(X);",
        "impl<X: Dfa> Dfa for Not<X> {",
        "    type Alphabet = X::Alphabet;",
        "    type State = X::State;",
        "    fn init(&self) -> Self::State {",
        "        self.0.init()",
        "    }",
        "    fn next(&self, s: Self::State, a: Self::Alphabet, i: usize) -> Self::State {",
        "        self.0.next(s, a, i)",
        "    }",
        "    fn accept(&self, s: Self::State) -> bool {",
        "        !self.0.accept(s)",
        "    }",
        "}",
        "struct Prod<X, Y>(X, Y);",
        "impl<X: Dfa, Y: Dfa> Dfa for Prod<X, Y> {",
        "    type Alphabet = (X::Alphabet, Y::Alphabet);",
        "    type State = (X::State, Y::State);",
        "    fn init(&self) -> Self::State {",
        "        (self.0.init(), self.1.init())",
        "    }",
        "    fn next(&self, (s0, s1): Self::State, (a0, a1): Self::Alphabet, i: usize) -> Self::State {",
        "        (self.0.next(s0, a0, i), self.1.next(s1, a1, i))",
        "    }",
        "    fn accept(&self, (s0, s1): Self::State) -> bool {",
        "        self.0.accept(s0) && self.1.accept(s1)",
        "    }",
        "}"
      ]
    },
    "DijkstraQueue": {
      "prefix": "DijkstraQueue",
      "body": [
        "struct DijkstraQueue<State: std::hash::Hash + std::cmp::Eq> {",
        "    cur: usize,",
        "    que: Vec<Vec<State>>,",
        "    next: BinaryHeap<i64>,",
        "}",
        "impl<State: Default + Clone + std::hash::Hash + std::cmp::Eq> DijkstraQueue<State> {",
        "    pub fn new(maxdist: usize) -> DijkstraQueue<State> {",
        "        DijkstraQueue {",
        "            cur: maxdist + 1,",
        "            que: vec![vec![]; maxdist + 2],",
        "            next: BinaryHeap::new(),",
        "        }",
        "    }",
        "    fn pop_retry(&mut self) -> Option<(usize, State)> {",
        "        self.forward_cur();",
        "        let q = &mut self.que[self.cur];",
        "        if q.is_empty() {",
        "            None",
        "        } else {",
        "            let e = q.pop().unwrap();",
        "            Some((self.cur, e))",
        "        }",
        "    }",
        "    pub fn pop(&mut self) -> Option<(usize, State)> {",
        "        let q = &mut self.que[self.cur];",
        "        if q.is_empty() {",
        "            self.pop_retry()",
        "        } else {",
        "            let e = q.pop().unwrap();",
        "            Some((self.cur, e))",
        "        }",
        "    }",
        "    pub fn push(&mut self, cost: usize, st: State) {",
        "        if self.que[cost].is_empty() {",
        "            self.next.push(-1 * cost as i64);",
        "        }",
        "        self.que[cost].push(st);",
        "    }",
        "    fn is_empty_retry(&mut self) -> bool {",
        "        self.forward_cur();",
        "        let q = &self.que[self.cur];",
        "        q.is_empty()",
        "    }",
        "    pub fn is_empty(&mut self) -> bool {",
        "        let q = &self.que[self.cur];",
        "        if q.is_empty() {",
        "            self.is_empty_retry()",
        "        } else {",
        "            false",
        "        }",
        "    }",
        "    fn forward_cur(&mut self) {",
        "        if let Some(nx) = self.next.pop() {",
        "            self.cur = -nx as usize;",
        "        }",
        "    }",
        "}"
      ]
    },
    "Doubling": {
      "prefix": "Doubling",
      "body": [
        "/// ダブリング",
        "///",
        "/// 理論的には",
        "/// [f^1,f^2,f^4,...]",
        "/// という配列を構築すればよいが、関数を保持するというのは難しい。",
        "/// 例えば、f^4を計算するのにf^2が必要といったように関数を構築するのに遅延計算を行うと、計算量に影響する。",
        "///",
        "/// そこで、このライブラリでは、関数を表す値を保持することにする。",
        "///",
        "/// x0: 単位",
        "/// f: ap(f^1, x0)",
        "/// ap: 任意のfをxに適用する",
        "/// inv: f^n(x0)が与えられた時、f^nに相当する値を計算する",
        "trait Doublable {",
        "    type T: std::fmt::Debug;",
        "    fn x0(&self) -> Self::T;",
        "    fn f(&self) -> Self::T;",
        "    fn ap(&self, f: &Self::T, x: &Self::T) -> Self::T;",
        "    fn inv(&self, x: &Self::T) -> Self::T;",
        "}",
        "struct Doubling<D: Doublable> {",
        "    d: D,",
        "    f_table: Vec<D::T>,",
        "}",
        "impl<D: Doublable> Doubling<D> {",
        "    pub fn new(d: D, maxbit: usize) -> Self {",
        "        let mut f = vec![d.f()];",
        "        for i in 1..=maxbit {",
        "            let x = d.x0();",
        "            let fx = d.ap(&f[i - 1], &x);",
        "            let ffx = d.ap(&f[i - 1], &fx);",
        "            f.push(d.inv(&ffx));",
        "        }",
        "        Doubling { d: d, f_table: f }",
        "    }",
        "    pub fn pow(&self, k: i64) -> D::T {",
        "        let mut k = k;",
        "        let mut res = self.d.x0();",
        "        let mut i = 0;",
        "        while k > 0 {",
        "            if k & 1 == 1 {",
        "                res = self.d.ap(&self.f_table[i], &res);",
        "            }",
        "            k >>= 1;",
        "            i += 1;",
        "        }",
        "        res",
        "    }",
        "}"
      ]
    },
    "EularTour": {
      "prefix": "EularTour",
      "body": [
        "#[derive(Debug)]",
        "struct EularTour {",
        "    g: Vec<Vec<usize>>,",
        "    n: usize,",
        "    vid: usize,",
        "    enter: Vec<usize>,",
        "    leave: Vec<usize>,",
        "}",
        "impl EularTour {",
        "    pub fn new(n: usize) -> EularTour {",
        "        EularTour {",
        "            g: vec![vec![]; n],",
        "            n: n,",
        "            vid: 0,",
        "            enter: vec![n; n],",
        "            leave: vec![n; n],",
        "        }",
        "    }",
        "    pub fn connect(&mut self, u: usize, v: usize) {",
        "        self.g[u].push(v);",
        "        self.g[v].push(u);",
        "    }",
        "    fn alloc_vid(&mut self) -> usize {",
        "        let tmp = self.vid;",
        "        self.vid += 1;",
        "        tmp",
        "    }",
        "    pub fn dfs(&mut self, u: usize) {",
        "        self.rec(u, self.n);",
        "    }",
        "    fn rec(&mut self, u: usize, p: usize) {",
        "        self.enter[u] = self.alloc_vid();",
        "        for i in 0..self.g[u].len() {",
        "            let v = self.g[u][i];",
        "            if v == p {",
        "                continue;",
        "            }",
        "            self.rec(v, u);",
        "        }",
        "        self.leave[u] = self.alloc_vid();",
        "    }",
        "}"
      ]
    },
    "GaussianElimination": {
      "prefix": "GaussianElimination",
      "body": [
        "/// ガウスの掃き出し法",
        "/// Rankというのはざっくりいうと、",
        "/// 実質的に何次元の一次変換かということ。",
        "pub struct GaussianElimination {",
        "    pub mat: Matrix,",
        "    pub rank: usize,",
        "}",
        "impl GaussianElimination {",
        "    pub fn sweep(mat: Matrix, mo: i64) -> GaussianElimination {",
        "        let mut mat = mat;",
        "        let rank = Self::do_sweep(&mut mat, mo);",
        "        GaussianElimination { mat, rank: rank }",
        "    }",
        "    fn do_sweep(mat: &mut Matrix, mo: i64) -> usize {",
        "        let h = mat.m();",
        "        let w = mat.n();",
        "        let mut rank = 0;",
        "        for j in 0..w {",
        "            let mut pivot = h;",
        "            for i in rank..h {",
        "                if mat[i][j] != 0 {",
        "                    pivot = i;",
        "                    break;",
        "                }",
        "            }",
        "            if pivot == h {",
        "                continue;",
        "            }",
        "            for j2 in 0..w {",
        "                let x = mat[pivot][j2];",
        "                let y = mat[rank][j2];",
        "                mat[rank][j2] = x;",
        "                mat[pivot][j2] = y;",
        "            }",
        "            let inv = modinv(mat[rank][j], mo);",
        "            for j2 in 0..w {",
        "                mat[rank][j2] = (mat[rank][j2] * inv) % mo;",
        "            }",
        "            for i in 0..h {",
        "                if i != rank && mat[i][j] != 0 {",
        "                    let fac = mat[i][j];",
        "                    for j2 in 0..w {",
        "                        mat[i][j2] -= (mat[rank][j2] * fac) % mo;",
        "                        if mat[i][j2] < 0 {",
        "                            mat[i][j2] += mo;",
        "                        }",
        "                    }",
        "                }",
        "            }",
        "            rank += 1;",
        "        }",
        "        rank",
        "    }",
        "}"
      ]
    },
    "Geom": {
      "prefix": "Geom",
      "body": [
        "const EPS: f64 = 1e-9;",
        "#[derive(Debug, Clone, Copy)]",
        "#[allow(dead_code)]",
        "pub struct Vector2D(f64, f64);",
        "impl Vector2D {",
        "    pub fn add(a: f64, b: f64) -> f64 {",
        "        let c = a + b;",
        "        if c.abs() < EPS {",
        "            0.0",
        "        } else {",
        "            c",
        "        }",
        "    }",
        "    pub fn dot(self, other: Vector2D) -> f64 {",
        "        Self::add(self.0 * other.0, self.1 * other.1)",
        "    }",
        "    pub fn det(self, other: Vector2D) -> f64 {",
        "        Self::add(self.0 * other.1, -self.1 * other.0)",
        "    }",
        "    pub fn complex_mul(self, other: Vector2D) -> Self {",
        "        let real = self.0 * other.0 - self.1 * other.1;",
        "        let imag = self.0 * other.1 + self.1 * other.0;",
        "        Vector2D(real, imag)",
        "    }",
        "    pub fn dist(self, other: Self) -> f64 {",
        "        (self - other).len()",
        "    }",
        "    pub fn len(&self) -> f64 {",
        "        f64::sqrt((self.0).powi(2) + (self.1).powi(2))",
        "    }",
        "    pub fn unit(self) -> Vector2D {",
        "        let l = self.len();",
        "        Vector2D(self.0 / l, self.1 / l)",
        "    }",
        "    ///orthogonal vector",
        "    pub fn normal(self) -> Vector2D {",
        "        Vector2D(self.1, -self.0).unit()",
        "    }",
        "    ///bisection of the angle",
        "    pub fn bisect(a: Vector2D, b: Vector2D) -> Vector2D {",
        "        (a.unit() + b.unit()).unit()",
        "    }",
        "}",
        "impl std::ops::Add for Vector2D {",
        "    type Output = Vector2D;",
        "    fn add(self, rhs: Vector2D) -> Self::Output {",
        "        Vector2D(Vector2D::add(self.0, rhs.0), Vector2D::add(self.1, rhs.1))",
        "    }",
        "}",
        "impl std::ops::Sub for Vector2D {",
        "    type Output = Vector2D;",
        "    fn sub(self, rhs: Vector2D) -> Self::Output {",
        "        Vector2D(Vector2D::add(self.0, -rhs.0), Vector2D::add(self.1, -rhs.1))",
        "    }",
        "}",
        "impl std::ops::Mul<f64> for Vector2D {",
        "    type Output = Vector2D;",
        "    fn mul(self, rhs: f64) -> Self::Output {",
        "        Vector2D(rhs * self.0, rhs * self.1)",
        "    }",
        "}",
        "impl std::ops::Div<f64> for Vector2D {",
        "    type Output = Vector2D;",
        "    fn div(self, rhs: f64) -> Self::Output {",
        "        Vector2D(self.0 / rhs, self.1 / rhs)",
        "    }",
        "}",
        "impl std::cmp::PartialEq for Vector2D {",
        "    fn eq(&self, other: &Self) -> bool {",
        "        let x = (self.0 - other.0).abs();",
        "        let y = (self.1 - other.1).abs();",
        "        x < EPS && y < EPS",
        "    }",
        "}",
        "#[derive(Clone, Copy)]",
        "struct Triangle {",
        "    x: Vector2D,",
        "    y: Vector2D,",
        "    z: Vector2D,",
        "}",
        "impl Triangle {",
        "    pub fn exists(&self) -> bool {",
        "        let a = (self.y - self.z).len();",
        "        let b = (self.x - self.z).len();",
        "        let c = (self.x - self.y).len();",
        "        if a + b - c < EPS {",
        "            return false;",
        "        }",
        "        if b + c - a < EPS {",
        "            return false;",
        "        }",
        "        if c + a - b < EPS {",
        "            return false;",
        "        }",
        "        true",
        "    }",
        "}",
        "#[derive(Debug, Clone, Copy)]",
        "pub struct Circle {",
        "    center: Vector2D,",
        "    radius: f64,",
        "}",
        "impl Circle {",
        "    pub fn inner_circle(a: Vector2D, b: Vector2D, c: Vector2D) -> Option<Circle> {",
        "        let tri = Triangle { x: a, y: b, z: c };",
        "        if !tri.exists() {",
        "            return None;",
        "        }",
        "        let a_bisect = Line2D::pd(a, Vector2D::bisect(a - b, a - c));",
        "        let b_bisect = Line2D::pd(b, Vector2D::bisect(b - a, b - c));",
        "        let center = Line2D::intersection(a_bisect, b_bisect);",
        "        let ab = Line2D::pd(a, b - a);",
        "        let radius = ab.distance(center);",
        "        Some(Circle {",
        "            center: center,",
        "            radius: radius,",
        "        })",
        "    }",
        "    pub fn outer_circle(x: Vector2D, y: Vector2D, z: Vector2D) -> Option<Circle> {",
        "        let a = (y - z).len();",
        "        let a2 = a * a;",
        "        let b = (x - z).len();",
        "        let b2 = b * b;",
        "        let c = (x - y).len();",
        "        let c2 = c * c;",
        "        if a + b - c < EPS {",
        "            return None;",
        "        }",
        "        if b + c - a < EPS {",
        "            return None;",
        "        }",
        "        if c + a - b < EPS {",
        "            return None;",
        "        }",
        "        let X = x * (a2 * (b2 + c2 - a2)) + y * (b2 * (c2 + a2 - b2)) + z * (c2 * (a2 + b2 - c2));",
        "        let Y = a2 * (b2 + c2 - a2) + b2 * (c2 + a2 - b2) + c2 * (a2 + b2 - c2);",
        "        let center = X / Y;",
        "        let radius = (x - center).len();",
        "        Some(Circle {",
        "            center: center,",
        "            radius: radius,",
        "        })",
        "    }",
        "    pub fn intersection(c1: &Self, c2: &Self) -> Vec<Vector2D> {",
        "        let d = c1.center.dist(c2.center);",
        "        if d > c1.radius + c2.radius + EPS {",
        "            return vec![];",
        "        }",
        "        if c1.center == c2.center {",
        "            return vec![];",
        "        }",
        "        let rc: f64 = (d * d + c1.radius * c1.radius - c2.radius * c2.radius) / (2. * d);",
        "        let rs: f64 = f64::sqrt(c1.radius * c1.radius - rc * rc);",
        "        let diff: Vector2D = (c2.center - c1.center) / d;",
        "        let p1 = c1.center + diff.complex_mul(Vector2D(rc, rs));",
        "        let p2 = c1.center + diff.complex_mul(Vector2D(rc, -rs));",
        "        if p1 == p2 {",
        "            vec![p1]",
        "        } else {",
        "            vec![p1, p2]",
        "        }",
        "    }",
        "}",
        "/// Is line a-b and line c-d intersected ?",
        "pub fn is_intersected(a: Vector2D, b: Vector2D, c: Vector2D, d: Vector2D) -> bool {",
        "    let ta = (c.0 - d.0) * (a.1 - c.1) + (c.1 - d.1) * (c.0 - a.0);",
        "    let tb = (c.0 - d.0) * (b.1 - c.1) + (c.1 - d.1) * (c.0 - b.0);",
        "    let tc = (a.0 - b.0) * (c.1 - a.1) + (a.1 - b.1) * (a.0 - c.0);",
        "    let td = (a.0 - b.0) * (d.1 - a.1) + (a.1 - b.1) * (a.0 - d.0);",
        "    tc * td <= 0.0 && ta * tb <= 0.0",
        "}",
        "#[derive(Clone, Copy, Debug)]",
        "pub struct Line2D {",
        "    p: Vector2D,",
        "    d: Vector2D,",
        "}",
        "impl Line2D {",
        "    pub fn pd(p: Vector2D, d: Vector2D) -> Self {",
        "        Line2D { p: p, d: d.unit() }",
        "    }",
        "    pub fn from_two_points(a: Vector2D, b: Vector2D) -> Self {",
        "        Line2D { p: a, d: b - a }",
        "    }",
        "    pub fn intersection(a: Line2D, b: Line2D) -> Vector2D {",
        "        let n = b.d.normal();",
        "        let x = n.dot(b.p - a.p) / n.dot(a.d);",
        "        a.p + a.d * x",
        "    }",
        "    pub fn distance(self, a: Vector2D) -> f64 {",
        "        let perpendicular = Self::pd(a, self.d.normal());",
        "        let q = Self::intersection(self, perpendicular);",
        "        (a - q).len()",
        "    }",
        "}"
      ]
    },
    "HLDecomposition": {
      "prefix": "HLDecomposition",
      "body": [
        "/// HL分解は、木構造をパスの集合に分解する。",
        "/// こうして木構造をvid木上で一直線状にすることにより、",
        "/// セグツリーなどの配列構造に対するアルゴリズムを適用可能になる。",
        "/// そして、頂点や辺にvidをつける。ここで辺は子ノードの頂点vidで表される。",
        "/// クエリ(u,v)に対して、木上のパスに含まれるパス集合（vidベース）を列挙する。",
        "///",
        "/// 構築 O(N)",
        "struct HLDecomposition {",
        "    n: usize,",
        "    g: Vec<Vec<usize>>,",
        "    subcnt: Vec<usize>,",
        "    depth: Vec<usize>,",
        "    pub par: Vec<Option<usize>>,",
        "    heavy_next: Vec<Option<usize>>,",
        "    heavy_head: Vec<usize>,",
        "    real_to_virt: Vec<usize>,",
        "    pub virt_to_real: Vec<usize>,",
        "}",
        "impl HLDecomposition {",
        "    pub fn new(n: usize) -> Self {",
        "        HLDecomposition {",
        "            n: n,",
        "            g: vec![vec![]; n],",
        "            subcnt: vec![0; n],",
        "            depth: vec![0; n],",
        "            par: vec![None; n],",
        "            heavy_next: vec![None; n],",
        "            heavy_head: vec![n; n],",
        "            real_to_virt: vec![n; n],",
        "            virt_to_real: vec![n; n],",
        "        }",
        "    }",
        "    pub fn connect(&mut self, u: usize, v: usize) {",
        "        self.g[u].push(v);",
        "        self.g[v].push(u);",
        "    }",
        "    /// O(N)",
        "    pub fn build(&mut self, root: usize) {",
        "        self.dfs1(root);",
        "        self.dfs2(root);",
        "        self.bfs(root);",
        "    }",
        "    fn dfs1(&mut self, root: usize) {",
        "        self.depth[root] = 0;",
        "        self.par[root] = None;",
        "        self.dfs1_sub(root, None);",
        "    }",
        "    fn dfs1_sub(&mut self, u: usize, par: Option<usize>) -> usize {",
        "        let mut cnt = 1;",
        "        for v in self.g[u].clone() {",
        "            if Some(v) == par {",
        "                continue;",
        "            }",
        "            self.depth[v] = self.depth[u] + 1;",
        "            self.par[v] = Some(u);",
        "            cnt += self.dfs1_sub(v, Some(u));",
        "        }",
        "        self.subcnt[u] = cnt;",
        "        cnt",
        "    }",
        "    fn dfs2(&mut self, root: usize) {",
        "        self.dfs2_sub(root, None);",
        "    }",
        "    fn dfs2_sub(&mut self, u: usize, par: Option<usize>) {",
        "        let mut maxv = 0;",
        "        let mut heavy_next = None;",
        "        let cld = self.g[u].clone();",
        "        for &v in &cld {",
        "            if Some(v) == par {",
        "                continue;",
        "            }",
        "            if self.subcnt[v] > maxv {",
        "                maxv = self.subcnt[v];",
        "                heavy_next = Some(v);",
        "            }",
        "        }",
        "        if let Some(hn) = heavy_next {",
        "            self.heavy_next[u] = Some(hn);",
        "            self.dfs2_sub(hn, Some(u));",
        "        }",
        "        for &v in &cld {",
        "            if Some(v) == par || Some(v) == heavy_next {",
        "                continue;",
        "            }",
        "            self.dfs2_sub(v, Some(u));",
        "        }",
        "    }",
        "    fn bfs(&mut self, root: usize) {",
        "        let mut cur_virt_id = 0;",
        "        let mut q = VecDeque::new();",
        "        q.push_back(root);",
        "        while let Some(h) = q.pop_front() {",
        "            let mut cur0 = Some(h);",
        "            while cur0.is_some() {",
        "                let cur = cur0.unwrap();",
        "                self.real_to_virt[cur] = cur_virt_id;",
        "                self.virt_to_real[cur_virt_id] = cur;",
        "                cur_virt_id += 1;",
        "                self.heavy_head[cur] = h;",
        "                for v in self.g[cur].clone() {",
        "                    if Some(v) == self.par[cur] || Some(v) == self.heavy_next[cur] {",
        "                        continue;",
        "                    }",
        "                    q.push_back(v);",
        "                }",
        "                cur0 = self.heavy_next[cur];",
        "            }",
        "        }",
        "    }",
        "    /// O(log N)",
        "    pub fn lca(&self, u: usize, v: usize) -> usize {",
        "        let mut l = u;",
        "        let mut r = v;",
        "        loop {",
        "            if self.real_to_virt[l] > self.real_to_virt[r] {",
        "                std::mem::swap(&mut l, &mut r);",
        "            }",
        "            if self.heavy_head[l] == self.heavy_head[r] {",
        "                return l;",
        "            }",
        "            r = self.par[self.heavy_head[r]].unwrap();",
        "        }",
        "    }",
        "    /// O(N)",
        "    pub fn vertex_decomposition(&self) -> Vec<(usize, usize)> {",
        "        let mut vhead = vec![self.n; self.n];",
        "        for i in 0..self.n {",
        "            vhead[i] = self.real_to_virt[self.heavy_head[i]];",
        "        }",
        "        let mut hs = std::collections::HashMap::new();",
        "        for x in vhead {",
        "            *hs.entry(x).or_insert(0) += 1;",
        "        }",
        "        let mut res = vec![];",
        "        for (k, v) in hs {",
        "            res.push((k, k + v - 1));",
        "        }",
        "        res",
        "    }",
        "    /// O(N)",
        "    pub fn edge_decomposition(&self) -> Vec<(usize, usize)> {",
        "        let V = self.vertex_decomposition();",
        "        let mut res = vec![];",
        "        for (u, v) in V {",
        "            let u = if u == 0 { 1 } else { u };",
        "            res.push((u, v));",
        "        }",
        "        res",
        "    }",
        "    pub fn vertex_decomposition_between(&self, u: usize, v: usize) -> Vec<(usize, usize)> {",
        "        let mut res = vec![];",
        "        let mut l = u;",
        "        let mut r = v;",
        "        loop {",
        "            if self.real_to_virt[l] > self.real_to_virt[r] {",
        "                std::mem::swap(&mut l, &mut r);",
        "            }",
        "            let p = (",
        "                std::cmp::max(self.real_to_virt[self.heavy_head[r]], self.real_to_virt[l]),",
        "                self.real_to_virt[r],",
        "            );",
        "            res.push(p);",
        "            if self.heavy_head[l] != self.heavy_head[r] {",
        "                r = self.par[self.heavy_head[r]].unwrap();",
        "            } else {",
        "                break;",
        "            }",
        "        }",
        "        res",
        "    }",
        "    pub fn edge_decomposition_between(&self, u: usize, v: usize) -> Vec<(usize, usize)> {",
        "        let mut res = vec![];",
        "        let mut l = u;",
        "        let mut r = v;",
        "        loop {",
        "            if self.real_to_virt[l] > self.real_to_virt[r] {",
        "                std::mem::swap(&mut l, &mut r);",
        "            }",
        "            if self.heavy_head[l] != self.heavy_head[r] {",
        "                let p = (self.real_to_virt[self.heavy_head[r]], self.real_to_virt[r]);",
        "                res.push(p);",
        "                r = self.par[self.heavy_head[r]].unwrap();",
        "            } else {",
        "                if l != r {",
        "                    let p = (self.real_to_virt[l] + 1, self.real_to_virt[r]);",
        "                    res.push(p);",
        "                }",
        "                break;",
        "            }",
        "        }",
        "        res",
        "    }",
        "    pub fn distance(&self, u: usize, v: usize) -> usize {",
        "        self.depth[u] + self.depth[v] - 2 * self.depth[self.lca(u, v)]",
        "    }",
        "}"
      ]
    },
    "Imosu1d": {
      "prefix": "Imosu1d",
      "body": [
        "/// いもす法（１次元）",
        "///",
        "/// いもす法の１次元ならば、２次元の時のように均一の値ではなく、",
        "/// 一次式ax+yを足し合わせることが出来る。",
        "/// なぜならば、",
        "/// aの配列をスイープすることによって",
        "/// a,2a,3a,...の",
        "/// 足し合わせをO(N)で計算出来るから。",
        "///",
        "/// 計算量:",
        "/// 構築 O(N)",
        "/// クエリ O(1)",
        "pub struct Imosu1d {",
        "    n: usize,",
        "    dp1: Vec<i64>,",
        "    dp2: Vec<i64>,",
        "    dp3: Vec<i64>,",
        "}",
        "impl Imosu1d {",
        "    pub fn new(n: usize) -> Imosu1d {",
        "        Imosu1d {",
        "            n: n,",
        "            dp1: vec![0; n + 1],",
        "            dp2: vec![0; n + 1],",
        "            dp3: vec![0; n + 1],",
        "        }",
        "    }",
        "    ///y=ax+b",
        "    pub fn add_line(&mut self, l: usize, r: usize, line: ArithSeq) {",
        "        if l >= r {",
        "            return;",
        "        }",
        "        let a = line.a;",
        "        let b = line.b;",
        "        let y = line.y(l as i64);",
        "        self.dp1[l] += y;",
        "        self.dp1[r] += -y;",
        "        self.dp2[l + 1] += a;",
        "        self.dp2[r] += -a;",
        "        let L = r - (l + 1);",
        "        self.dp3[r] += -a * L as i64;",
        "    }",
        "    fn sweep(dp: &mut [i64]) {",
        "        let mut cur = 0;",
        "        for i in 0..dp.len() {",
        "            cur += dp[i];",
        "            dp[i] = cur;",
        "        }",
        "    }",
        "    pub fn build(&mut self) {",
        "        let n = self.dp1.len();",
        "        Self::sweep(&mut self.dp1);",
        "        Self::sweep(&mut self.dp2);",
        "        for i in 0..n {",
        "            self.dp2[i] += self.dp3[i];",
        "        }",
        "        Self::sweep(&mut self.dp2);",
        "        for i in 0..n {",
        "            self.dp1[i] += self.dp2[i];",
        "        }",
        "    }",
        "    pub fn get(&self, k: usize) -> i64 {",
        "        self.dp1[k]",
        "    }",
        "}"
      ]
    },
    "Imosu2d": {
      "prefix": "Imosu2d",
      "body": [
        "/// いもす法（２次元）",
        "///",
        "/// [i0,i1)x[j0,j1)の領域に範囲加算をしていったあと、",
        "/// i,jの値を調べる。",
        "/// 横方向、縦方向のスイープを行うだけで構築可能。",
        "///",
        "/// 計算量:",
        "/// 構築 O(N+M)",
        "/// クエリ O(1)",
        "pub struct Imosu2d {",
        "    n: usize,",
        "    m: usize,",
        "    dp: Vec<Vec<i64>>,",
        "}",
        "impl Imosu2d {",
        "    pub fn new(n: usize, m: usize) -> Imosu2d {",
        "        Imosu2d {",
        "            n: n,",
        "            m: m,",
        "            dp: vec![vec![0; m + 1]; n + 1],",
        "        }",
        "    }",
        "    pub fn add(&mut self, i0: usize, i1: usize, j0: usize, j1: usize, x: i64) {",
        "        self.dp[i0][j0] += x;",
        "        self.dp[i0][j1] += -x;",
        "        self.dp[i1][j0] += -x;",
        "        self.dp[i1][j1] += x;",
        "    }",
        "    pub fn build(&mut self) {",
        "        for i in 0..self.n + 1 {",
        "            for j in 0..self.m {",
        "                self.dp[i][j + 1] += self.dp[i][j];",
        "            }",
        "        }",
        "        for j in 0..self.m + 1 {",
        "            for i in 0..self.n {",
        "                self.dp[i + 1][j] += self.dp[i][j];",
        "            }",
        "        }",
        "    }",
        "    pub fn get(&self, i: usize, j: usize) -> i64 {",
        "        self.dp[i][j]",
        "    }",
        "}"
      ]
    },
    "InvMatrix": {
      "prefix": "InvMatrix",
      "body": [
        "struct InvMatrix;",
        "impl InvMatrix {",
        "    /// ガウスの掃き出し法を使って逆行列を求める",
        "    pub fn solve(a: Matrix, mo: i64) -> Option<Matrix> {",
        "        assert_eq!(a.m(), a.n());",
        "        let n = a.m();",
        "        let e = Matrix::identity(n);",
        "        let elim1 = GaussianElimination::sweep(a.clone(), mo);",
        "        dbg!(&elim1.mat);",
        "        let elim2 = GaussianElimination::sweep(Matrix::combine(a, e), mo);",
        "        dbg!(&elim2.mat);",
        "        if elim1.rank == n {",
        "            let mut ret = Matrix::zeros(n, n);",
        "            for i in 0..n {",
        "                for j in 0..n {",
        "                    ret[i][j] = elim2.mat[i][n + j];",
        "                }",
        "            }",
        "            Some(ret)",
        "        } else {",
        "            None",
        "        }",
        "    }",
        "}"
      ]
    },
    "KMP": {
      "prefix": "KMP",
      "body": [
        "/// パターン文字列についてテーブルを構築",
        "/// 構築計算量 O(|P|)",
        "///",
        "/// 文字列SからPを全検索",
        "/// 計算量 O(|S|)",
        "struct KMP {",
        "    pat: Vec<u64>,",
        "    tbl: Vec<i64>,",
        "}",
        "impl KMP {",
        "    fn new(pat: Vec<u64>) -> Self {",
        "        let n = pat.len();",
        "        let mut tbl = vec![0; n + 1];",
        "        tbl[0] = -1;",
        "        let mut j: i64 = -1;",
        "        for i in 0..n {",
        "            while j >= 0 && pat[i] != pat[j as usize] {",
        "                j = tbl[j as usize];",
        "            }",
        "            j += 1;",
        "            if i + 1 < n && pat[i + 1] == pat[j as usize] {",
        "                tbl[i + 1] = tbl[j as usize];",
        "            } else {",
        "                tbl[i + 1] = j;",
        "            }",
        "        }",
        "        KMP { pat: pat, tbl: tbl }",
        "    }",
        "    pub fn search(&self, s: &[u64]) -> Vec<usize> {",
        "        let mut res = vec![];",
        "        let mut head: i64 = 0;",
        "        let mut j: i64 = 0;",
        "        while head + j < s.len() as i64 {",
        "            if self.pat[j as usize] == s[(head + j) as usize] {",
        "                j += 1;",
        "                if j != self.pat.len() as i64 {",
        "                    continue;",
        "                }",
        "                res.push(head as usize);",
        "            }",
        "            head += j - self.tbl[j as usize];",
        "            j = std::cmp::max(self.tbl[j as usize], 0);",
        "        }",
        "        res",
        "    }",
        "}"
      ]
    },
    "Kadane": {
      "prefix": "Kadane",
      "body": [
        "struct Kadane<T, Sum, Fold> {",
        "    lmax_table: Vec<(usize, Sum)>,",
        "    rmax_table: Vec<(usize, Sum)>,",
        "    p1: std::marker::PhantomData<T>,",
        "    p2: std::marker::PhantomData<Fold>,",
        "}",
        "impl<",
        "        T: Clone,",
        "        Sum: std::cmp::PartialOrd + std::default::Default + Clone,",
        "        Fold: Fn(&Sum, &T) -> Sum,",
        "    > Kadane<T, Sum, Fold>",
        "{",
        "    pub fn new(a: Vec<T>, add: Fold) -> Kadane<T, Sum, Fold> {",
        "        let L = Self::build_lmax(a.clone(), &add);",
        "        let mut a = a;",
        "        a.reverse();",
        "        let mut R = Self::build_lmax(a, &add);",
        "        R.reverse();",
        "        Kadane {",
        "            lmax_table: L,",
        "            rmax_table: R,",
        "            p1: std::marker::PhantomData,",
        "            p2: std::marker::PhantomData,",
        "        }",
        "    }",
        "    pub fn rmax(&self, l: usize) -> (usize, Sum) {",
        "        let (len, sum) = self.rmax_table[l].clone();",
        "        (l + len, sum)",
        "    }",
        "    pub fn lmax(&self, r: usize) -> (usize, Sum) {",
        "        let (len, sum) = self.lmax_table[r].clone();",
        "        (r - len, sum)",
        "    }",
        "    fn build_lmax(a: Vec<T>, fold: &Fold) -> Vec<(usize, Sum)> {",
        "        let n = a.len();",
        "        let mut res = vec![(0, Sum::default())];",
        "        for r in 1..n + 1 {",
        "            let (L, ma) = res[r - 1].clone();",
        "            let i = r - 1;",
        "            let x = fold(&Sum::default(), &a[i]);",
        "            let y = fold(&ma, &a[i]);",
        "            let z = Sum::default();",
        "            if z >= x && z >= y {",
        "                res.push((0, Sum::default()));",
        "            } else if x >= y {",
        "                res.push((1, x));",
        "            } else {",
        "                res.push((L + 1, y));",
        "            }",
        "        }",
        "        res",
        "    }",
        "}"
      ]
    },
    "LCA": {
      "prefix": "LCA",
      "body": [
        "struct LCA {",
        "    tree: Vec<Vec<usize>>,",
        "    parent: Vec<Vec<Option<usize>>>,",
        "    depth: Vec<usize>,",
        "}",
        "impl LCA {",
        "    pub fn new(n: usize) -> Self {",
        "        let mut log_n = (n as f64).log2().ceil() as usize;",
        "        if log_n == 0 {",
        "            log_n = 1;",
        "        }",
        "        assert!(log_n > 0);",
        "        LCA {",
        "            tree: vec![vec![]; n],",
        "            parent: vec![vec![None; n]; log_n],",
        "            depth: vec![0; n],",
        "        }",
        "    }",
        "    pub fn connect(&mut self, u: usize, v: usize) {",
        "        self.tree[u].push(v);",
        "        self.tree[v].push(u);",
        "    }",
        "    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: usize) {",
        "        self.parent[0][u] = parent;",
        "        self.depth[u] = depth;",
        "        for i in 0..self.tree[u].len() {",
        "            let v = self.tree[u][i];",
        "            if Some(v) != parent {",
        "                self.dfs(v, Some(u), depth + 1);",
        "            }",
        "        }",
        "    }",
        "    pub fn build(&mut self, root: usize) {",
        "        self.dfs(root, None, 0);",
        "        let mut k = 0;",
        "        while k + 1 < self.parent.len() {",
        "            for u in 0..self.tree.len() {",
        "                if self.parent[k][u].is_some() {",
        "                    self.parent[k + 1][u] = self.parent[k][self.parent[k][u].unwrap()]",
        "                }",
        "            }",
        "            k += 1;",
        "        }",
        "    }",
        "    pub fn lca(&self, u: usize, v: usize) -> usize {",
        "        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {",
        "            (u, v)",
        "        } else {",
        "            (v, u)",
        "        };",
        "        assert!(self.depth[v1] >= self.depth[v0]);",
        "        for k in 0..self.parent.len() {",
        "            if (((self.depth[v1] - self.depth[v0]) >> k) & 1) > 0 {",
        "                assert!(self.parent[k][v1].is_some());",
        "                v1 = self.parent[k][v1].unwrap();",
        "            }",
        "        }",
        "        assert!(self.depth[v1] >= self.depth[v0]);",
        "        assert!(self.depth[v1] == self.depth[v0]);",
        "        if (v0 == v1) {",
        "            return v0;",
        "        }",
        "        for k in (0..self.parent.len()).rev() {",
        "            if self.parent[k][v0] != self.parent[k][v1] {",
        "                assert!(self.parent[k][v0].is_some());",
        "                assert!(self.parent[k][v1].is_some());",
        "                v0 = self.parent[k][v0].unwrap();",
        "                v1 = self.parent[k][v1].unwrap();",
        "            }",
        "        }",
        "        return self.parent[0][v0].unwrap();",
        "    }",
        "    pub fn distance(&self, u: usize, v: usize) -> usize {",
        "        self.depth[u] + self.depth[v] - 2 * self.depth[self.lca(u, v)]",
        "    }",
        "}"
      ]
    },
    "LCS": {
      "prefix": "LCS",
      "body": [
        "/// 2つの文字列のマッチング（連続でなくともよい）のうち",
        "/// 最大のものを求める。",
        "///",
        "/// 計算量 O(MN)",
        "/// 空間量 O(MN)",
        "#[derive(Debug)]",
        "struct LCS<T> {",
        "    max_matching: Vec<Vec<usize>>,",
        "    /// 最大マッチングを作るインデックスのペア",
        "    pub matching: Vec<(usize, usize)>,",
        "    phantom: std::marker::PhantomData<T>,",
        "}",
        "impl<T: Eq> LCS<T> {",
        "    pub fn new(xs: &[T], ys: &[T]) -> LCS<T> {",
        "        let n = xs.len();",
        "        let m = ys.len();",
        "        let dp = Self::lcs(xs, ys);",
        "        let mut k = dp[n][m];",
        "        let mut i = n;",
        "        let mut j = m;",
        "        let mut matching = vec![];",
        "        while k > 0 {",
        "            while dp[i - 1][j] == k {",
        "                i -= 1;",
        "            }",
        "            while dp[i][j - 1] == k {",
        "                j -= 1;",
        "            }",
        "            matching.push((i - 1, j - 1));",
        "            k -= 1;",
        "            i -= 1;",
        "            j -= 1;",
        "        }",
        "        matching.reverse();",
        "        LCS {",
        "            max_matching: dp,",
        "            matching: matching,",
        "            phantom: std::marker::PhantomData,",
        "        }",
        "    }",
        "    fn lcs(xs: &[T], ys: &[T]) -> Vec<Vec<usize>> {",
        "        let n = xs.len();",
        "        let m = ys.len();",
        "        let mut dp = vec![vec![0; m + 1]; n + 1];",
        "        dp[0][0] = 0;",
        "        for i in 1..=n {",
        "            for j in 1..=m {",
        "                dp[i][j] = if xs[i - 1] == ys[j - 1] {",
        "                    dp[i - 1][j - 1] + 1",
        "                } else {",
        "                    std::cmp::max(dp[i][j - 1], dp[i - 1][j])",
        "                }",
        "            }",
        "        }",
        "        dp",
        "    }",
        "}"
      ]
    },
    "LexicalPermutation": {
      "prefix": "LexicalPermutation",
      "body": [
        "pub trait LexicalPermutation {",
        "    fn next_permutation(&mut self) -> bool;",
        "    fn prev_permutation(&mut self) -> bool;",
        "}",
        "impl<T> LexicalPermutation for [T]",
        "where",
        "    T: Ord,",
        "{",
        "    /// Original author in Rust: Thomas Backman <serenity@exscape.org>",
        "    fn next_permutation(&mut self) -> bool {",
        "        if self.len() < 2 {",
        "            return false;",
        "        }",
        "        let mut i = self.len() - 1;",
        "        while i > 0 && self[i - 1] >= self[i] {",
        "            i -= 1;",
        "        }",
        "        if i == 0 {",
        "            return false;",
        "        }",
        "        let mut j = self.len() - 1;",
        "        while j >= i && self[j] <= self[i - 1] {",
        "            j -= 1;",
        "        }",
        "        self.swap(j, i - 1);",
        "        self[i..].reverse();",
        "        true",
        "    }",
        "    fn prev_permutation(&mut self) -> bool {",
        "        if self.len() < 2 {",
        "            return false;",
        "        }",
        "        let mut i = self.len() - 1;",
        "        while i > 0 && self[i - 1] <= self[i] {",
        "            i -= 1;",
        "        }",
        "        if i == 0 {",
        "            return false;",
        "        }",
        "        self[i..].reverse();",
        "        let mut j = self.len() - 1;",
        "        while j >= i && self[j - 1] < self[i - 1] {",
        "            j -= 1;",
        "        }",
        "        self.swap(i - 1, j);",
        "        true",
        "    }",
        "}"
      ]
    },
    "LinSolve": {
      "prefix": "LinSolve",
      "body": [
        "#[derive(PartialEq, Debug)]",
        "pub enum LinSolveResult {",
        "    Infinite,",
        "    None,",
        "    One(Matrix),",
        "}",
        "pub struct LinSolve;",
        "impl LinSolve {",
        "    /// Ax = y",
        "    /// の解xをmod Mの下で計算する。",
        "    pub fn solve(a: Matrix, y: Matrix, mo: i64) -> LinSolveResult {",
        "        assert_eq!(a.m(), a.n());",
        "        let n = a.m();",
        "        let elim1 = GaussianElimination::sweep(a.clone(), mo);",
        "        dbg!(&elim1.mat);",
        "        let elim2 = GaussianElimination::sweep(Matrix::combine(a, y), mo);",
        "        dbg!(&elim2.mat);",
        "        if elim1.rank == n {",
        "            let mut ret = Matrix::zeros(n, 1);",
        "            for i in 0..n {",
        "                ret[i][0] = elim2.mat[i][n];",
        "            }",
        "            LinSolveResult::One(ret)",
        "        } else {",
        "            if elim1.rank == elim2.rank {",
        "                LinSolveResult::Infinite",
        "            } else {",
        "                LinSolveResult::None",
        "            }",
        "        }",
        "    }",
        "}"
      ]
    },
    "Lowlink": {
      "prefix": "Lowlink",
      "body": [
        "/// 無向グラフにおいて関節点と橋を求める。",
        "///",
        "/// 関節点: その点を取り除くと連結成分が増える",
        "/// 橋: その辺を取り除くと連結成分が増える",
        "///",
        "/// アイデア:",
        "/// あるノードからDFSを行い、到達順ord[u]を記録する。",
        "/// この時のたどり順をDFS-Treeと呼び、通らなかった辺を後退辺と呼ぶことにする。",
        "/// lowlinkという値を定義する。",
        "/// lowlink[u]は、DFS-Treeに沿って後退辺をたかだか1本通った時に到達可能な頂点集合のordのうち最小値である。",
        "/// lowlinkはこんな性質がある。もし、後退辺が一本もないような木の場合、ord[u]=lowlink[u]となる。",
        "/// 仮にDFS-Treeにおいて、uの子vについてord[u]<=low[v]が成り立ったとする。",
        "/// この時、uを取り除いてしまうと、vはuの祖先から孤立してしまうことがわかる。",
        "/// なぜならば、vからuの祖先に行く方法がないからである。",
        "/// つまり、uが関節点であることが言える。",
        "///",
        "/// 橋については、",
        "/// まず後退辺については橋には成り得ない。",
        "/// DFS-Treeのうちu->v辺についてord[u]<low[v]の時、u->vは橋となる。",
        "/// なぜならば、u->vを切ってしまうとvからuにすら到達出来なくなってしまうため。",
        "///",
        "/// 計算量:",
        "/// 構築 O(V+E)",
        "struct LowLink {",
        "    g: Vec<Vec<usize>>,",
        "    used: Vec<bool>,",
        "    ord: Vec<usize>,",
        "    low: Vec<usize>,",
        "    pub articulation: Vec<usize>,",
        "    pub bridge: Vec<(usize, usize)>,",
        "}",
        "///find articulation points and bridges at the same time",
        "impl LowLink {",
        "    fn minmax(p: (usize, usize)) -> (usize, usize) {",
        "        if p.0 <= p.1 {",
        "            p",
        "        } else {",
        "            (p.1, p.0)",
        "        }",
        "    }",
        "    pub fn new(n: usize) -> LowLink {",
        "        let mut g = vec![vec![]; n];",
        "        let mut used = vec![false; n];",
        "        let mut ord = vec![0; n];",
        "        let mut low = vec![0; n];",
        "        let articulation = vec![];",
        "        let bridge = vec![];",
        "        LowLink {",
        "            g,",
        "            used,",
        "            ord,",
        "            low,",
        "            articulation,",
        "            bridge,",
        "        }",
        "    }",
        "    pub fn connect(&mut self, u: usize, v: usize) {",
        "        self.g[u].push(v);",
        "        self.g[v].push(u);",
        "    }",
        "    pub fn build(&mut self) {",
        "        self.do_build(0, 0, None);",
        "        self.articulation.sort();",
        "        self.bridge.sort();",
        "    }",
        "    fn do_build(&mut self, u: usize, k: usize, par: Option<usize>) -> usize {",
        "        let mut k = k;",
        "        self.used[u] = true;",
        "        self.ord[u] = k;",
        "        k += 1;",
        "        self.low[u] = self.ord[u];",
        "        let mut is_articulation = false;",
        "        let mut cnt = 0;",
        "        for i in 0..self.g[u].len() {",
        "            let v = self.g[u][i];",
        "            if !self.used[v] {",
        "                cnt += 1;",
        "                k = self.do_build(v, k, Some(u));",
        "                self.low[u] = std::cmp::min(self.low[u], self.low[v]);",
        "                is_articulation |= par.is_some() && self.low[v] >= self.ord[u];",
        "                if self.ord[u] < self.low[v] {",
        "                    self.bridge.push(Self::minmax((u, v)));",
        "                }",
        "            } else if Some(v) != par {",
        "                self.low[u] = std::cmp::min(self.low[u], self.ord[v]);",
        "            } else {",
        "            }",
        "        }",
        "        is_articulation |= par.is_none() && cnt > 1;",
        "        if is_articulation {",
        "            self.articulation.push(u);",
        "        }",
        "        k",
        "    }",
        "}"
      ]
    },
    "Manacher": {
      "prefix": "Manacher",
      "body": [
        "/// 各iを中心にした回文半径を計算する。",
        "/// 回文半径は、(直径+1)/2で計算される。（つまり中心を含む）",
        "/// ここで直径は常に奇数",
        "fn manacher(s: &[u64]) -> Vec<usize> {",
        "    let mut r = vec![0; s.len()];",
        "    let mut i = 0;",
        "    let mut j = 0;",
        "    while i < s.len() {",
        "        while i >= j && i + j < s.len() && s[i - j] == s[i + j] {",
        "            j += 1;",
        "        }",
        "        r[i] = j;",
        "        let mut k = 1;",
        "        while i >= k && i + k < s.len() && k + r[i - k] < j {",
        "            r[i + k] = r[i - k];",
        "            k += 1;",
        "        }",
        "        i += k;",
        "        j -= k;",
        "    }",
        "    r",
        "}",
        "struct Manacher {",
        "    a: Vec<usize>,",
        "}",
        "impl Manacher {",
        "    pub fn new(s: Vec<u64>) -> Self {",
        "        let sep = 1 << 60;",
        "        let n = s.len();",
        "        let m = 2 * n + 1;",
        "        let mut t = vec![sep; m];",
        "        for i in 0..n {",
        "            let k = (2 * i) + 1;",
        "            t[k] = s[i];",
        "        }",
        "        let a = manacher(&t);",
        "        Manacher { a: a }",
        "    }",
        "    /// 通常のmanacher",
        "    /// ある文字を中心とした半径",
        "    pub fn radius_odd(&self, i: usize) -> usize {",
        "        let k = (2 * i) + 1;",
        "        let r = self.a[k];",
        "        r / 2",
        "    }",
        "    /// 仕切りを中心とした半径",
        "    pub fn radius_even(&self, i: usize) -> usize {",
        "        let k = 2 * i;",
        "        let r = self.a[k];",
        "        r / 2",
        "    }",
        "    pub fn is_pelimdrome(&self, l: usize, r: usize) -> bool {",
        "        let len = r - l;",
        "        if len % 2 == 0 {",
        "            let i = (l + r) / 2;",
        "            let r = len / 2;",
        "            self.radius_even(i) >= r",
        "        } else {",
        "            let i = (l + r) / 2;",
        "            let r = (len + 1) / 2;",
        "            self.radius_odd(i) >= r",
        "        }",
        "    }",
        "}"
      ]
    },
    "Matrix": {
      "prefix": "Matrix",
      "body": [
        "pub mod matrix {",
        "    #[derive(Clone, PartialEq, Debug)]",
        "    pub struct Matrix {",
        "        pub v: Vec<Vec<i64>>,",
        "    }",
        "    impl Matrix {",
        "        pub fn new(v: Vec<Vec<i64>>) -> Self {",
        "            Self { v }",
        "        }",
        "        pub fn into_inner(self) -> Vec<Vec<i64>> {",
        "            self.v",
        "        }",
        "        /// (a|b)",
        "        pub fn combine(a: Self, b: Self) -> Self {",
        "            assert_eq!(a.m(), b.m());",
        "            let m = a.m();",
        "            let mut ret = Self::zeros(m, a.n() + b.n());",
        "            for i in 0..m {",
        "                for j in 0..a.n() {",
        "                    ret[i][j] = a[i][j];",
        "                }",
        "                for j in 0..b.n() {",
        "                    ret[i][a.n() + j] = b[i][j];",
        "                }",
        "            }",
        "            ret",
        "        }",
        "        pub fn transpose(self) -> Self {",
        "            let mut ret = Self::zeros(self.n(), self.m());",
        "            for i in 0..self.n() {",
        "                for j in 0..self.m() {",
        "                    ret[i][j] = self[j][i];",
        "                }",
        "            }",
        "            ret",
        "        }",
        "        pub fn zeros(m: usize, n: usize) -> Self {",
        "            let v = vec![vec![0; n]; m];",
        "            Self { v }",
        "        }",
        "        pub fn identity(n: usize) -> Self {",
        "            let mut v = vec![vec![0; n]; n];",
        "            for i in 0..n {",
        "                v[i][i] = 1;",
        "            }",
        "            Matrix { v: v }",
        "        }",
        "        pub fn m(&self) -> usize {",
        "            self.v.len()",
        "        }",
        "        pub fn n(&self) -> usize {",
        "            self.v[0].len()",
        "        }",
        "        pub fn mul_rem(&self, other: &Self, mo: i64) -> Self {",
        "            assert!(self.n() == other.m());",
        "            let K = self.n();",
        "            let M = self.m();",
        "            let N = other.n();",
        "            let mut r = vec![vec![0; N]; M];",
        "            for i in 0..M {",
        "                for j in 0..N {",
        "                    let mut v = 0;",
        "                    for k in 0..K {",
        "                        v += self.v[i][k] * other.v[k][j] % mo;",
        "                        v %= mo;",
        "                    }",
        "                    r[i][j] = v;",
        "                }",
        "            }",
        "            Matrix { v: r }",
        "        }",
        "        pub fn pow(&self, k: u64, mo: i64) -> Self {",
        "            assert!(self.m() == self.n());",
        "            let mut k = k;",
        "            let mut x = Self::identity(self.m());",
        "            let mut y = self.clone();",
        "            while k > 0 {",
        "                if k & 1 > 0 {",
        "                    x = y.clone() * x;",
        "                    x %= mo;",
        "                }",
        "                y = y.mul_rem(&y, mo);",
        "                y %= mo;",
        "                k >>= 1;",
        "            }",
        "            x",
        "        }",
        "    }",
        "    use std::ops::*;",
        "    impl Add for Matrix {",
        "        type Output = Self;",
        "        fn add(self, other: Self) -> Self {",
        "            let mut r = self.v.clone();",
        "            for i in 0..self.m() {",
        "                for j in 0..self.n() {",
        "                    r[i][j] += other.v[i][j];",
        "                }",
        "            }",
        "            Matrix { v: r }",
        "        }",
        "    }",
        "    impl Sub for Matrix {",
        "        type Output = Self;",
        "        fn sub(self, other: Self) -> Self {",
        "            let mut r = self.v.clone();",
        "            for i in 0..self.m() {",
        "                for j in 0..self.n() {",
        "                    r[i][j] -= other.v[i][j];",
        "                }",
        "            }",
        "            Matrix { v: r }",
        "        }",
        "    }",
        "    impl Mul for Matrix {",
        "        type Output = Self;",
        "        fn mul(self, other: Self) -> Self {",
        "            assert!(self.n() == other.m());",
        "            let K = self.n();",
        "            let M = self.m();",
        "            let N = other.n();",
        "            let mut r = vec![vec![0; N]; M];",
        "            for i in 0..M {",
        "                for j in 0..N {",
        "                    let mut v = 0;",
        "                    for k in 0..K {",
        "                        v += self.v[i][k] * other.v[k][j];",
        "                    }",
        "                    r[i][j] = v;",
        "                }",
        "            }",
        "            Matrix { v: r }",
        "        }",
        "    }",
        "    impl Rem<i64> for Matrix {",
        "        type Output = Self;",
        "        fn rem(self, mo: i64) -> Self {",
        "            let mut r = self.v.clone();",
        "            for i in 0..self.m() {",
        "                for j in 0..self.n() {",
        "                    r[i][j] %= mo;",
        "                }",
        "            }",
        "            Matrix { v: r }",
        "        }",
        "    }",
        "    impl RemAssign<i64> for Matrix {",
        "        fn rem_assign(&mut self, mo: i64) {",
        "            for i in 0..self.m() {",
        "                for j in 0..self.n() {",
        "                    self.v[i][j] %= mo;",
        "                }",
        "            }",
        "        }",
        "    }",
        "    impl std::ops::Index<usize> for Matrix {",
        "        type Output = [i64];",
        "        fn index(&self, i: usize) -> &Self::Output {",
        "            &self.v[i]",
        "        }",
        "    }",
        "    impl std::ops::IndexMut<usize> for Matrix {",
        "        fn index_mut(&mut self, i: usize) -> &mut Self::Output {",
        "            &mut self.v[i]",
        "        }",
        "    }",
        "}",
        "pub type Matrix = matrix::Matrix;"
      ]
    },
    "ModComb": {
      "prefix": "ModComb",
      "body": [
        "#[derive(Clone)]",
        "struct ModComb {",
        "    fact: Vec<i64>,",
        "    fact_inv: Vec<i64>,",
        "    n: usize,",
        "    p: i64,",
        "}",
        "impl ModComb {",
        "    fn initialize(ft: &mut Self) {",
        "        let n = ft.n;",
        "        ft.fact[0] = 1;",
        "        for i in 1..n {",
        "            ft.fact[i] = (ft.fact[i - 1] * i as i64) % ft.p;",
        "        }",
        "        ft.fact_inv[n - 1] = modpow(ft.fact[n - 1], ft.p - 2, ft.p);",
        "        for i in (0..n - 1).rev() {",
        "            ft.fact_inv[i] = (ft.fact_inv[i + 1] * (i + 1) as i64) % ft.p;",
        "        }",
        "    }",
        "    ///O(N)",
        "    fn new(max_n: usize, p: i64) -> ModComb {",
        "        let mut ft = ModComb {",
        "            fact: vec![0; max_n + 1],",
        "            fact_inv: vec![0; max_n + 1],",
        "            n: max_n + 1,",
        "            p: p,",
        "        };",
        "        Self::initialize(&mut ft);",
        "        ft",
        "    }",
        "    fn fact(&self, n: usize) -> i64 {",
        "        self.fact[n]",
        "    }",
        "    ///choose k numbers from 1..n",
        "    fn nCk(&self, n: i64, k: i64) -> i64 {",
        "        if n < k {",
        "            return 0;",
        "        }",
        "        (self.nPk(n, k) * self.fact_inv[k as usize]) % self.p",
        "    }",
        "    fn nPk(&self, n: i64, k: i64) -> i64 {",
        "        if n < k {",
        "            return 0;",
        "        }",
        "        self.fact[n as usize] * self.fact_inv[(n - k) as usize] % self.p",
        "    }",
        "    ///split k into n number as x1+x2+...xn=k",
        "    fn nHk(&self, n: i64, k: i64) -> i64 {",
        "        if n == 0 && k == 0 {",
        "            return 1;",
        "        }",
        "        self.nCk(n + k - 1, k)",
        "    }",
        "    ///put n balls into k different boxes. In case of n=3,k+2 [[1,2],[3]]==[[3],[1,2]]",
        "    fn nSk(&self, n: i64, k: i64) -> i64 {",
        "        if n < k {",
        "            return 0;",
        "        }",
        "        let mut res = 0;",
        "        for i in 0..k + 1 {",
        "            let v = self.nCk(k, i) * modpow(i, n, self.p) % self.p;",
        "            if (k - i) % 2 == 1 {",
        "                res = (res + self.p - v) % self.p;",
        "            } else {",
        "                res = (res + v) % self.p;",
        "            }",
        "        }",
        "        return res * self.fact_inv[k as usize] % self.p;",
        "    }",
        "    fn nBk(&self, n: i64, k: i64) -> i64 {",
        "        0",
        "    }",
        "}",
        "#[allow(dead_code)]",
        "/// x ^ n % m",
        "pub fn modpow(x: i64, n: i64, m: i64) -> i64 {",
        "    let mut res = 1;",
        "    let mut x = x % m;",
        "    let mut n = n;",
        "    while n > 0 {",
        "        if n & 1 == 1 {",
        "            res = (res * x) % m;",
        "        }",
        "        x = (x * x) % m;",
        "        n >>= 1;",
        "    }",
        "    res",
        "}"
      ]
    },
    "NTT": {
      "prefix": "NTT",
      "body": [
        "struct NTT {",
        "    pub mo: i64,",
        "}",
        "impl NTT {",
        "    pub fn new(mo: i64) -> NTT {",
        "        NTT { mo: mo }",
        "    }",
        "    fn _ntt(&self, a: &mut [i64], n: usize, inverse: bool) {",
        "        let g = 3;",
        "        let mut h = modpow(g, (self.mo - 1) / n as i64, self.mo);",
        "        if inverse {",
        "            h = modinv(h, self.mo);",
        "        }",
        "        let mut i = 0;",
        "        for j in 1..n - 1 {",
        "            let mut k = n >> 1;",
        "            loop {",
        "                i ^= k;",
        "                if k > i {",
        "                    k >>= 1;",
        "                } else {",
        "                    break;",
        "                }",
        "            }",
        "            if j < i {",
        "                let tmp = a[i];",
        "                a[i] = a[j];",
        "                a[j] = tmp;",
        "            }",
        "        }",
        "        let mut m = 1;",
        "        while m < n {",
        "            let m2 = m * 2;",
        "            let base = modpow(h, (n / m2) as i64, self.mo);",
        "            let mut w = 1;",
        "            for x in 0..m {",
        "                let mut s = x;",
        "                while s < n {",
        "                    let u = a[s];",
        "                    let d = (a[s + m] * w) % self.mo;",
        "                    a[s] = u + d;",
        "                    if a[s] >= self.mo {",
        "                        a[s] -= self.mo;",
        "                    }",
        "                    a[s + m] = u - d;",
        "                    if a[s + m] < 0 {",
        "                        a[s + m] += self.mo;",
        "                    }",
        "                    s += m2;",
        "                }",
        "                w = (w * base) % self.mo;",
        "            }",
        "            m *= 2;",
        "        }",
        "        for i in 0..n {",
        "            if a[i] < 0 {",
        "                a[i] += self.mo;",
        "            }",
        "        }",
        "    }",
        "    fn ntt(&self, a: &mut [i64], n: usize) {",
        "        self._ntt(a, n, false);",
        "    }",
        "    fn intt(&self, a: &mut [i64], n: usize) {",
        "        self._ntt(a, n, true);",
        "        let n_inv = modinv(a.len() as i64, self.mo);",
        "        for i in 0..n {",
        "            a[i] = (a[i] * n_inv) % self.mo;",
        "        }",
        "    }",
        "    pub fn convolve(&self, a: &[i64], b: &[i64]) -> Vec<i64> {",
        "        let mut a = a.to_vec();",
        "        let mut b = b.to_vec();",
        "        let mut n = 1;",
        "        while n < a.len() + b.len() {",
        "            n <<= 1;",
        "        }",
        "        a.resize(n, 0);",
        "        b.resize(n, 0);",
        "        self.ntt(&mut a, n);",
        "        self.ntt(&mut b, n);",
        "        let mut c = vec![0; n];",
        "        for i in 0..n {",
        "            c[i] = (a[i] * b[i]) % self.mo;",
        "        }",
        "        self.intt(&mut c, n);",
        "        c",
        "    }",
        "}",
        "pub fn ntt_multiply(a: &[i64], b: &[i64], mo: i64) -> Vec<i64> {",
        "    let mut a = a.to_vec();",
        "    let mut b = b.to_vec();",
        "    let n = a.len();",
        "    let m = b.len();",
        "    for i in 0..n {",
        "        a[i] %= mo;",
        "    }",
        "    for i in 0..m {",
        "        b[i] %= mo;",
        "    }",
        "    let ntt1 = NTT::new(167772161);",
        "    let ntt2 = NTT::new(469762049);",
        "    let ntt3 = NTT::new(1224736769);",
        "    let x = ntt1.convolve(&a, &b);",
        "    let y = ntt2.convolve(&a, &b);",
        "    let z = ntt3.convolve(&a, &b);",
        "    let m1 = ntt1.mo;",
        "    let m2 = ntt2.mo;",
        "    let m3 = ntt3.mo;",
        "    let m1_inv_m2 = modinv(m1, m2);",
        "    let m12_inv_m3 = modinv(m1 * m2, m3);",
        "    let m12_mod = (m1 * m2) % mo;",
        "    let L = x.len();",
        "    let mut res = vec![0; L];",
        "    for i in 0..L {",
        "        let mut v1 = (y[i] - x[i]) * m1_inv_m2;",
        "        v1 %= m2;",
        "        if v1 < 0 {",
        "            v1 += m2;",
        "        }",
        "        let mut v2 = (z[i] - (x[i] + m1 * v1) % m3) * m12_inv_m3;",
        "        v2 %= m3;",
        "        if v2 < 0 {",
        "            v2 += m3;",
        "        }",
        "        let mut const3 = (x[i] + m1 * v1 + m12_mod * v2) % mo;",
        "        if const3 < 0 {",
        "            const3 += mo;",
        "        }",
        "        res[i] = const3;",
        "    }",
        "    res.truncate(n + m - 1);",
        "    res",
        "}"
      ]
    },
    "Permutation": {
      "prefix": "Permutation",
      "body": [
        "/// 置換の二行記法",
        "#[derive(Debug, Clone)]",
        "pub struct Permutation {",
        "    a: Vec<usize>,",
        "    b: Vec<usize>,",
        "}",
        "impl Permutation {",
        "    ///permutation a[i] -> b[i]",
        "    pub fn new(a: Vec<usize>, b: Vec<usize>) -> Self {",
        "        Permutation { a: a, b: b }",
        "    }",
        "    /// 巡回置換に分解する。",
        "    /// 計算量: O(NlogN)",
        "    pub fn into_cycles(self) -> Vec<CyclicPermutation> {",
        "        let mut ab = vec![];",
        "        let mut next = std::collections::HashMap::new();",
        "        let n = self.a.len();",
        "        for i in 0..n {",
        "            next.insert(self.a[i], self.b[i]);",
        "            ab.push((self.a[i], self.b[i]));",
        "        }",
        "        ab.sort();",
        "        ab.reverse();",
        "        let mut res = vec![];",
        "        let mut visited = vec![false; n];",
        "        loop {",
        "            if ab.is_empty() {",
        "                break;",
        "            }",
        "            let (head, _) = ab.pop().unwrap();",
        "            if visited[head] {",
        "                continue;",
        "            }",
        "            let mut chain = vec![];",
        "            let mut a = head;",
        "            loop {",
        "                chain.push(a);",
        "                visited[a] = true;",
        "                let b = next.get(&a).cloned().unwrap();",
        "                if b == head {",
        "                    break;",
        "                }",
        "                a = b;",
        "            }",
        "            res.push(CyclicPermutation::new(chain))",
        "        }",
        "        res",
        "    }",
        "}"
      ]
    },
    "Polynomial": {
      "prefix": "Polynomial",
      "body": [
        "/// NTTを使った多項式の掛け算を行う。",
        "/// ダブリングによる乗算もサポートする。",
        "#[derive(Debug)]",
        "struct Polynomial {",
        "    coeff: Vec<i64>,",
        "    mo: i64,",
        "}",
        "impl Polynomial {",
        "    pub fn new(coeff: Vec<i64>, mo: i64) -> Polynomial {",
        "        Polynomial {",
        "            coeff: coeff,",
        "            mo: mo,",
        "        }",
        "    }",
        "    pub fn multiply(&self, other: &Self) -> Self {",
        "        assert!(self.mo == other.mo);",
        "        Polynomial {",
        "            coeff: ntt::ntt_multiply(&self.coeff, &other.coeff, self.mo),",
        "            mo: self.mo,",
        "        }",
        "    }",
        "    pub fn pow(&self, k: i64) -> Self {",
        "        let mut res = Polynomial {",
        "            coeff: vec![1],",
        "            mo: self.mo,",
        "        };",
        "        let mut x = Polynomial {",
        "            coeff: self.coeff.clone(),",
        "            mo: self.mo,",
        "        };",
        "        let mut k = k;",
        "        while k > 0 {",
        "            if k & 1 == 1 {",
        "                res = res.multiply(&x);",
        "            }",
        "            x = x.multiply(&x);",
        "            k >>= 1;",
        "        }",
        "        res",
        "    }",
        "}"
      ]
    },
    "PowTable": {
      "prefix": "PowTable",
      "body": [
        "struct PowTable {",
        "    dp: Vec<i64>,",
        "}",
        "impl PowTable {",
        "    pub fn new(x: i64, maxbit: usize, mo: i64) -> Self {",
        "        let mut dp = vec![1];",
        "        for i in 0..maxbit {",
        "            let v = (dp[i] * x) % mo;",
        "            dp.push(v);",
        "        }",
        "        PowTable { dp: dp }",
        "    }",
        "    pub fn pow(&self, k: usize) -> i64 {",
        "        self.dp[k]",
        "    }",
        "}"
      ]
    },
    "Rename": {
      "prefix": "Rename",
      "body": [
        "struct Rename {",
        "    F: Vec<usize>,",
        "    R: Vec<usize>,",
        "    n: usize,",
        "    cur: usize,",
        "}",
        "impl Rename {",
        "    pub fn new(n: usize) -> Self {",
        "        NodeRename {",
        "            F: vec![n; n],",
        "            R: vec![n; n],",
        "            n: n,",
        "            cur: 0,",
        "        }",
        "    }",
        "    pub fn insert(&mut self, u: usize) {",
        "        if self.F[u] == self.n {",
        "            let i = self.cur;",
        "            self.F[u] = i;",
        "            self.R[i] = u;",
        "            self.cur += 1;",
        "        }",
        "    }",
        "    pub fn get(&mut self, u: usize) -> usize {",
        "        self.F[u]",
        "    }",
        "    pub fn rev(&mut self, i: usize) -> usize {",
        "        self.R[i]",
        "    }",
        "    pub fn len(&self) -> usize {",
        "        self.cur",
        "    }",
        "}"
      ]
    },
    "Rev": {
      "prefix": "Rev",
      "body": [
        "#[derive(Eq, PartialEq, Clone, Debug)]",
        "/// Equivalent to std::cmp::Reverse",
        "pub struct Rev<T>(pub T);",
        "impl<T: PartialOrd> PartialOrd for Rev<T> {",
        "    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {",
        "        other.0.partial_cmp(&self.0)",
        "    }",
        "}",
        "impl<T: Ord> Ord for Rev<T> {",
        "    fn cmp(&self, other: &Rev<T>) -> Ordering {",
        "        other.0.cmp(&self.0)",
        "    }",
        "}"
      ]
    },
    "RoLiHa": {
      "prefix": "RoLiHa",
      "body": [
        "struct RoLiHa {",
        "    powMemo: Vec<u64>,",
        "    hash: Vec<u64>,",
        "}",
        "const ROLIHA_MASK30: u64 = (1 << 30) - 1;",
        "const ROLIHA_MASK31: u64 = (1 << 31) - 1;",
        "const ROLIHA_MOD: u64 = (1 << 61) - 1;",
        "const ROLIHA_P: u64 = ROLIHA_MOD * ((1 << 3) - 1);",
        "impl RoLiHa {",
        "    ///注意: Sに0は含まれてはいけない",
        "    fn new(s: &[u64]) -> Self {",
        "        let mut randgen = Xorshift::new();",
        "        let rand = randgen.rand(std::i64::MAX as u64);",
        "        let base = rand + 129;",
        "        let mut powMemo = vec![0; s.len() + 1];",
        "        powMemo[0] = 1;",
        "        for i in 1..powMemo.len() {",
        "            powMemo[i] = Self::calcmod(Self::mul(powMemo[i - 1], base));",
        "        }",
        "        let mut hash = vec![0; s.len() + 1];",
        "        for i in 0..s.len() {",
        "            hash[i + 1] = Self::calcmod(Self::mul(hash[i], base) + s[i]);",
        "        }",
        "        RoLiHa {",
        "            powMemo: powMemo,",
        "            hash: hash,",
        "        }",
        "    }",
        "    /// [l,r)のハッシュ値を計算する",
        "    pub fn get(&self, l: usize, r: usize) -> u64 {",
        "        return Self::calcmod(",
        "            self.hash[r] + ROLIHA_P - Self::mul(self.hash[l], self.powMemo[r - l]),",
        "        );",
        "    }",
        "    pub fn connect(&self, h1: u64, h2: u64, h2len: usize) -> u64 {",
        "        return Self::calcmod(Self::mul(h1, self.powMemo[h2len]) + h2);",
        "    }",
        "    fn mul(l: u64, r: u64) -> u64 {",
        "        let lu = l >> 31;",
        "        let ld = l & ROLIHA_MASK31;",
        "        let ru = r >> 31;",
        "        let rd = r & ROLIHA_MASK31;",
        "        let middle_bit = ld * ru + lu * rd;",
        "        ((lu * ru) << 1) + ld * rd + ((middle_bit & ROLIHA_MASK30) << 31) + (middle_bit >> 30)",
        "    }",
        "    fn calcmod(x: u64) -> u64 {",
        "        let mut x = (x & ROLIHA_MOD) + (x >> 61);",
        "        if x > ROLIHA_MOD {",
        "            x -= ROLIHA_MOD;",
        "        }",
        "        x",
        "    }",
        "}"
      ]
    },
    "SCC": {
      "prefix": "SCC",
      "body": [
        "/// 強連結分解",
        "///",
        "/// 有向グラフをお互いに行き来可能な",
        "/// 頂点集合に分解する。",
        "///",
        "/// 入力: 有向グラフ",
        "/// 出力: 各ノードが所属する集合",
        "///",
        "/// 計算量: O(V+E)",
        "pub struct SCC {",
        "    g: Vec<Vec<usize>>,",
        "    r_g: Vec<Vec<usize>>,",
        "    post_order: VecDeque<usize>,",
        "    used: Vec<bool>,",
        "    pub order: Vec<usize>,",
        "}",
        "impl SCC {",
        "    pub fn new(n: usize) -> Self {",
        "        Self {",
        "            g: vec![vec![]; n],",
        "            r_g: vec![vec![]; n],",
        "            post_order: VecDeque::new(),",
        "            used: vec![false; n],",
        "            order: vec![n; n],",
        "        }",
        "    }",
        "    pub fn add_edge(&mut self, u: usize, v: usize) {",
        "        self.g[u].push(v);",
        "        self.r_g[v].push(u);",
        "    }",
        "    fn dfs(&mut self, u: usize) {",
        "        self.used[u] = true;",
        "        for i in 0..self.g[u].len() {",
        "            let v = self.g[u][i];",
        "            if !self.used[v] {",
        "                self.dfs(v);",
        "            }",
        "        }",
        "        self.post_order.push_front(u);",
        "    }",
        "    fn rdfs(&mut self, u: usize, k: usize) {",
        "        self.used[u] = true;",
        "        self.order[u] = k;",
        "        for i in 0..self.r_g[u].len() {",
        "            let v = self.r_g[u][i];",
        "            if !self.used[v] {",
        "                self.rdfs(v, k);",
        "            }",
        "        }",
        "    }",
        "    pub fn build(&mut self) {",
        "        for v in 0..self.g.len() {",
        "            if !self.used[v] {",
        "                self.dfs(v);",
        "            }",
        "        }",
        "        self.used = vec![false; self.g.len()];",
        "        let mut k = 0;",
        "        for i in 0..self.post_order.len() {",
        "            let v = self.post_order[i];",
        "            if !self.used[v] {",
        "                self.rdfs(v, k);",
        "                k += 1;",
        "            }",
        "        }",
        "    }",
        "}"
      ]
    },
    "SEG": {
      "prefix": "SEG",
      "body": [
        "/// フェニック木の一般化",
        "///",
        "/// 各ノードには最初、idに相当する値が入っている。",
        "/// get i: a[i]を返す",
        "/// update i x: a[i]=x",
        "/// query l r: [l,r)をカバーするノードに対してopを適用したもの",
        "#[allow(dead_code)]",
        "pub trait Monoid {",
        "    type T: Clone + std::fmt::Debug;",
        "    fn id() -> Self::T;",
        "    fn op(a: &Self::T, b: &Self::T) -> Self::T;",
        "}",
        "#[allow(dead_code)]",
        "pub struct SEG<M: Monoid> {",
        "    pub n: usize,",
        "    pub buf: Vec<M::T>,",
        "}",
        "impl<M: Monoid> SEG<M> {",
        "    #[allow(dead_code)]",
        "    pub fn new(n: usize) -> SEG<M> {",
        "        let mut m = 1;",
        "        while m < n {",
        "            m *= 2;",
        "        }",
        "        SEG {",
        "            n: m,",
        "            buf: vec![M::id().clone(); 2 * m],",
        "        }",
        "    }",
        "    #[allow(dead_code)]",
        "    pub fn update(&mut self, k: usize, a: M::T) {",
        "        let mut k = k + self.n;",
        "        self.buf[k] = a;",
        "        while k > 1 {",
        "            k = k >> 1;",
        "            self.buf[k] = M::op(&self.buf[k * 2], &self.buf[k * 2 + 1]);",
        "        }",
        "    }",
        "    #[allow(dead_code)]",
        "    pub fn get(&self, k: usize) -> M::T {",
        "        self.buf[k + self.n].clone()",
        "    }",
        "    pub fn do_query(&self, a: usize, b: usize, k: usize, l: usize, r: usize) -> M::T {",
        "        if r <= a || b <= l {",
        "            return M::id();",
        "        }",
        "        if a <= l && r <= b {",
        "            return self.buf[k].clone();",
        "        } else {",
        "            let vl = self.do_query(a, b, k * 2, l, (l + r) / 2);",
        "            let vr = self.do_query(a, b, k * 2 + 1, (l + r) / 2, r);",
        "            return M::op(&vl, &vr);",
        "        }",
        "    }",
        "    #[allow(dead_code)]",
        "    pub fn query(&self, a: usize, b: usize) -> M::T {",
        "        self.do_query(a, b, 1, 0, self.n)",
        "    }",
        "}"
      ]
    },
    "SEG2d": {
      "prefix": "SEG2d",
      "body": [
        "pub struct SEG2d<M: Monoid> {",
        "    tree: SEGTree,",
        "    segs: Vec<SEG<M>>,",
        "    index: Vec<Vec<usize>>,",
        "}",
        "impl<M: Monoid> SEG2d<M> {",
        "    pub fn new(i2j: Vec<Vec<usize>>) -> Self {",
        "        let tree = SEGTree::new(i2j.len());",
        "        let n = i2j.len().next_power_of_two();",
        "        let mut index = vec![vec![]; 2 * n];",
        "        for i in 0..i2j.len() {",
        "            let mut v = i2j[i].clone();",
        "            v.sort();",
        "            v.dedup();",
        "            index[i + n] = v;",
        "        }",
        "        let mut k = n - 1;",
        "        while k >= 1 {",
        "            let l = 2 * k;",
        "            let r = 2 * k + 1;",
        "            let mut v = vec![];",
        "            v.extend_from_slice(&index[l]);",
        "            v.extend_from_slice(&index[r]);",
        "            v.sort();",
        "            v.dedup();",
        "            index[k] = v;",
        "            k -= 1;",
        "        }",
        "        let mut segs = vec![];",
        "        for ii in &index {",
        "            let s: SEG<M> = SEG::new(ii.len());",
        "            segs.push(s);",
        "        }",
        "        Self { tree, index, segs }",
        "    }",
        "    /// 計算量",
        "    /// O(logH logW)",
        "    pub fn update(&mut self, i: usize, j: usize, v: M::T) {",
        "        let nodes = self.tree.update_nodes(i);",
        "        for node in nodes {",
        "            match node {",
        "                SEGNode::Leaf { k } => {",
        "                    let i = self.index[k].binary_search(&j).unwrap();",
        "                    self.segs[k].update(i, v.clone());",
        "                }",
        "                SEGNode::Branch { k, l, r } => {",
        "                    let mut v = M::id();",
        "                    if let Ok(il) = self.index[l].binary_search(&j) {",
        "                        let vl = self.segs[l].get(il);",
        "                        v = M::op(&v, &vl);",
        "                    }",
        "                    if let Ok(ir) = self.index[r].binary_search(&j) {",
        "                        let vr = self.segs[r].get(ir);",
        "                        v = M::op(&v, &vr);",
        "                    }",
        "                    let i = self.index[k].binary_search(&j).unwrap();",
        "                    self.segs[k].update(i, v);",
        "                }",
        "            }",
        "        }",
        "    }",
        "    /// [x0,x1) x [y0,y1)",
        "    /// 計算量",
        "    /// O(logH logW)",
        "    pub fn query(&self, i0: usize, i1: usize, j0: usize, j1: usize) -> M::T {",
        "        let nodes = self.tree.query_nodes(i0, i1);",
        "        let mut ans = M::id();",
        "        for k in nodes {",
        "            let l = self.index[k].lower_bound(&j0);",
        "            let r = self.index[k].lower_bound(&j1);",
        "            let v = self.segs[k].query(l, r);",
        "            ans = M::op(&ans, &v);",
        "        }",
        "        ans",
        "    }",
        "}"
      ]
    },
    "SEGBeats": {
      "prefix": "SEGBeats",
      "body": [
        "/// 範囲に対してchmin, chmax関数を適用出来るセグ木",
        "/// 更新は、update, add, chmin, chmax",
        "/// クエリは、min, max, sumをサポートする。",
        "struct SEGBeats {",
        "    max_v: Vec<i64>,",
        "    smax_v: Vec<i64>,",
        "    max_c: Vec<usize>,",
        "    min_v: Vec<i64>,",
        "    smin_v: Vec<i64>,",
        "    min_c: Vec<usize>,",
        "    sum: Vec<i64>,",
        "    len: Vec<usize>,",
        "    ladd: Vec<i64>,",
        "    lval: Vec<i64>,",
        "    n0: usize,",
        "}",
        "impl SEGBeats {",
        "    const inf: i64 = std::i64::MAX / 4;",
        "    pub fn new(n: usize) -> SEGBeats {",
        "        let mut n0 = 1;",
        "        while n0 < n {",
        "            n0 <<= 1;",
        "        }",
        "        let mut max_v = vec![0; 2 * n0];",
        "        let mut smax_v = vec![0; 2 * n0];",
        "        let mut max_c = vec![0; 2 * n0];",
        "        let mut min_v = vec![0; 2 * n0];",
        "        let mut smin_v = vec![0; 2 * n0];",
        "        let mut min_c = vec![0; 2 * n0];",
        "        let mut sum = vec![0; 2 * n0];",
        "        let mut len = vec![0; 2 * n0];",
        "        let mut ladd = vec![0; 2 * n0];",
        "        let mut lval = vec![0; 2 * n0];",
        "        for i in 0..2 * n0 {",
        "            ladd[i] = 0;",
        "            lval[i] = Self::inf;",
        "        }",
        "        len[0] = n0;",
        "        for i in 0..n0 - 1 {",
        "            let l = len[i] >> 1;",
        "            len[2 * i + 1] = l;",
        "            len[2 * i + 2] = l;",
        "        }",
        "        for i in 0..n {",
        "            let j = n0 - 1 + i;",
        "            max_v[j] = 0;",
        "            min_v[j] = 0;",
        "            sum[j] = 0;",
        "            smax_v[j] = -Self::inf;",
        "            smin_v[j] = Self::inf;",
        "            max_c[j] = 1;",
        "            min_c[j] = 1;",
        "        }",
        "        for i in n..n0 {",
        "            let j = n0 - 1 + i;",
        "            max_v[j] = -Self::inf;",
        "            smax_v[j] = -Self::inf;",
        "            min_v[j] = Self::inf;",
        "            smin_v[j] = Self::inf;",
        "            max_c[j] = 0;",
        "            min_c[j] = 0;",
        "        }",
        "        let mut ret = SEGBeats {",
        "            max_v: max_v,",
        "            smax_v: smax_v,",
        "            max_c: max_c,",
        "            min_v: min_v,",
        "            smin_v: smin_v,",
        "            min_c: min_c,",
        "            sum: sum,",
        "            len: len,",
        "            ladd: ladd,",
        "            lval: lval,",
        "            n0: n0,",
        "        };",
        "        ret.build();",
        "        ret",
        "    }",
        "    fn build(&mut self) {",
        "        for i in (0..self.n0 - 1).rev() {",
        "            self.update(i);",
        "        }",
        "    }",
        "    fn update_node_max(&mut self, k: usize, x: i64) {",
        "        self.sum[k] += (x - self.max_v[k]) * self.max_c[k] as i64;",
        "        if self.max_v[k] == self.min_v[k] {",
        "            self.max_v[k] = x;",
        "            self.min_v[k] = x;",
        "        } else if self.max_v[k] == self.smin_v[k] {",
        "            self.max_v[k] = x;",
        "            self.smin_v[k] = x;",
        "        } else {",
        "            self.max_v[k] = x;",
        "        }",
        "        if self.lval[k] != Self::inf && x < self.lval[k] {",
        "            self.lval[k] = x;",
        "        }",
        "    }",
        "    fn update_node_min(&mut self, k: usize, x: i64) {",
        "        self.sum[k] += (x - self.min_v[k]) * self.min_c[k] as i64;",
        "        if self.max_v[k] == self.min_v[k] {",
        "            self.max_v[k] = x;",
        "            self.min_v[k] = x;",
        "        } else if self.smax_v[k] == self.min_v[k] {",
        "            self.min_v[k] = x;",
        "            self.smax_v[k] = x;",
        "        } else {",
        "            self.min_v[k] = x;",
        "        }",
        "        if self.lval[k] != Self::inf && self.lval[k] < x {",
        "            self.lval[k] = x;",
        "        }",
        "    }",
        "    fn push(&mut self, k: usize) {",
        "        if self.n0 - 1 <= k {",
        "            return;",
        "        }",
        "        if self.lval[k] != Self::inf {",
        "            self.update_all(2 * k + 1, self.lval[k]);",
        "            self.update_all(2 * k + 2, self.lval[k]);",
        "            self.lval[k] = Self::inf;",
        "            return;",
        "        }",
        "        if self.ladd[k] != 0 {",
        "            self.add_all(2 * k + 1, self.ladd[k]);",
        "            self.add_all(2 * k + 2, self.ladd[k]);",
        "            self.ladd[k] = 0;",
        "        }",
        "        if self.max_v[k] < self.max_v[2 * k + 1] {",
        "            self.update_node_max(2 * k + 1, self.max_v[k]);",
        "        }",
        "        if self.min_v[2 * k + 1] < self.min_v[k] {",
        "            self.update_node_min(2 * k + 1, self.min_v[k]);",
        "        }",
        "        if self.max_v[k] < self.max_v[2 * k + 2] {",
        "            self.update_node_max(2 * k + 2, self.max_v[k]);",
        "        }",
        "        if self.min_v[2 * k + 2] < self.min_v[k] {",
        "            self.update_node_min(2 * k + 2, self.min_v[k]);",
        "        }",
        "    }",
        "    fn update(&mut self, k: usize) {",
        "        self.sum[k] = self.sum[2 * k + 1] + self.sum[2 * k + 2];",
        "        if self.max_v[2 * k + 1] < self.max_v[2 * k + 2] {",
        "            self.max_v[k] = self.max_v[2 * k + 2];",
        "            self.max_c[k] = self.max_c[2 * k + 2];",
        "            self.smax_v[k] = std::cmp::max(self.max_v[2 * k + 1], self.smax_v[2 * k + 2]);",
        "        } else if self.max_v[2 * k + 1] > self.max_v[2 * k + 2] {",
        "            self.max_v[k] = self.max_v[2 * k + 1];",
        "            self.max_c[k] = self.max_c[2 * k + 1];",
        "            self.smax_v[k] = std::cmp::max(self.smax_v[2 * k + 1], self.max_v[2 * k + 2]);",
        "        } else {",
        "            self.max_v[k] = self.max_v[2 * k + 1];",
        "            self.max_c[k] = self.max_c[2 * k + 1] + self.max_c[2 * k + 2];",
        "            self.smax_v[k] = std::cmp::max(self.smax_v[2 * k + 1], self.smax_v[2 * k + 2]);",
        "        }",
        "        if self.min_v[2 * k + 1] < self.min_v[2 * k + 2] {",
        "            self.min_v[k] = self.min_v[2 * k + 1];",
        "            self.min_c[k] = self.min_c[2 * k + 1];",
        "            self.smin_v[k] = min(self.smin_v[2 * k + 1], self.min_v[2 * k + 2]);",
        "        } else if self.min_v[2 * k + 1] > self.min_v[2 * k + 2] {",
        "            self.min_v[k] = self.min_v[2 * k + 2];",
        "            self.min_c[k] = self.min_c[2 * k + 2];",
        "            self.smin_v[k] = min(self.min_v[2 * k + 1], self.smin_v[2 * k + 2]);",
        "        } else {",
        "            self.min_v[k] = self.min_v[2 * k + 1];",
        "            self.min_c[k] = self.min_c[2 * k + 1] + self.min_c[2 * k + 2];",
        "            self.smin_v[k] = min(self.smin_v[2 * k + 1], self.smin_v[2 * k + 2]);",
        "        }",
        "    }",
        "    fn _update_max(&mut self, x: i64, a: usize, b: usize, k: usize, l: usize, r: usize) {",
        "        if b <= l || r <= a || self.max_v[k] <= x {",
        "            return;",
        "        }",
        "        if a <= l && r <= b && self.smax_v[k] < x {",
        "            self.update_node_max(k, x);",
        "            return;",
        "        }",
        "        self.push(k);",
        "        self._update_max(x, a, b, 2 * k + 1, l, (l + r) / 2);",
        "        self._update_max(x, a, b, 2 * k + 2, (l + r) / 2, r);",
        "        self.update(k);",
        "    }",
        "    fn _update_min(&mut self, x: i64, a: usize, b: usize, k: usize, l: usize, r: usize) {",
        "        if b <= l || r <= a || x <= self.min_v[k] {",
        "            return;",
        "        }",
        "        if a <= l && r <= b && x < self.smin_v[k] {",
        "            self.update_node_min(k, x);",
        "            return;",
        "        }",
        "        self.push(k);",
        "        self._update_min(x, a, b, 2 * k + 1, l, (l + r) / 2);",
        "        self._update_min(x, a, b, 2 * k + 2, (l + r) / 2, r);",
        "        self.update(k);",
        "    }",
        "    fn add_all(&mut self, k: usize, x: i64) {",
        "        self.max_v[k] += x;",
        "        if self.smax_v[k] != -Self::inf {",
        "            self.smax_v[k] += x;",
        "        }",
        "        self.min_v[k] += x;",
        "        if self.smin_v[k] != Self::inf {",
        "            self.smin_v[k] += x;",
        "        }",
        "        self.sum[k] += self.len[k] as i64 * x;",
        "        if self.lval[k] != Self::inf {",
        "            self.lval[k] += x;",
        "        } else {",
        "            self.ladd[k] += x;",
        "        }",
        "    }",
        "    fn update_all(&mut self, k: usize, x: i64) {",
        "        self.max_v[k] = x;",
        "        self.smax_v[k] = -Self::inf;",
        "        self.min_v[k] = x;",
        "        self.smin_v[k] = Self::inf;",
        "        self.max_c[k] = self.len[k];",
        "        self.min_c[k] = self.len[k];",
        "        self.sum[k] = x * self.len[k] as i64;",
        "        self.lval[k] = x;",
        "        self.ladd[k] = 0;",
        "    }",
        "    fn _add_val(&mut self, x: i64, a: usize, b: usize, k: usize, l: usize, r: usize) {",
        "        if b <= l || r <= a {",
        "            return;",
        "        }",
        "        if a <= l && r <= b {",
        "            self.add_all(k, x);",
        "            return;",
        "        }",
        "        self.push(k);",
        "        self._add_val(x, a, b, 2 * k + 1, l, (l + r) / 2);",
        "        self._add_val(x, a, b, 2 * k + 2, (l + r) / 2, r);",
        "        self.update(k);",
        "    }",
        "    fn _update_val(&mut self, x: i64, a: usize, b: usize, k: usize, l: usize, r: usize) {",
        "        if b <= l || r <= a {",
        "            return;",
        "        }",
        "        if a <= l && r <= b {",
        "            self.update_all(k, x);",
        "            return;",
        "        }",
        "        self.push(k);",
        "        self._update_val(x, a, b, 2 * k + 1, l, (l + r) / 2);",
        "        self._update_val(x, a, b, 2 * k + 2, (l + r) / 2, r);",
        "        self.update(k);",
        "    }",
        "    fn _query_max(&mut self, a: usize, b: usize, k: usize, l: usize, r: usize) -> i64 {",
        "        if b <= l || r <= a {",
        "            return -Self::inf;",
        "        }",
        "        if a <= l && r <= b {",
        "            return self.max_v[k];",
        "        }",
        "        self.push(k);",
        "        let lv = self._query_max(a, b, 2 * k + 1, l, (l + r) / 2);",
        "        let rv = self._query_max(a, b, 2 * k + 2, (l + r) / 2, r);",
        "        return max(lv, rv);",
        "    }",
        "    fn _query_min(&mut self, a: usize, b: usize, k: usize, l: usize, r: usize) -> i64 {",
        "        if b <= l || r <= a {",
        "            return Self::inf;",
        "        }",
        "        if a <= l && r <= b {",
        "            return self.min_v[k];",
        "        }",
        "        self.push(k);",
        "        let lv = self._query_min(a, b, 2 * k + 1, l, (l + r) / 2);",
        "        let rv = self._query_min(a, b, 2 * k + 2, (l + r) / 2, r);",
        "        return min(lv, rv);",
        "    }",
        "    fn _query_sum(&mut self, a: usize, b: usize, k: usize, l: usize, r: usize) -> i64 {",
        "        if b <= l || r <= a {",
        "            return 0;",
        "        }",
        "        if a <= l && r <= b {",
        "            return self.sum[k];",
        "        }",
        "        self.push(k);",
        "        let lv = self._query_sum(a, b, 2 * k + 1, l, (l + r) / 2);",
        "        let rv = self._query_sum(a, b, 2 * k + 2, (l + r) / 2, r);",
        "        return lv + rv;",
        "    }",
        "    pub fn query_min(&mut self, l: usize, r: usize) -> i64 {",
        "        self._query_min(l, r, 0, 0, self.n0)",
        "    }",
        "    pub fn query_max(&mut self, l: usize, r: usize) -> i64 {",
        "        self._query_max(l, r, 0, 0, self.n0)",
        "    }",
        "    pub fn query_sum(&mut self, l: usize, r: usize) -> i64 {",
        "        self._query_sum(l, r, 0, 0, self.n0)",
        "    }",
        "    pub fn chmax(&mut self, l: usize, r: usize, x: i64) {",
        "        self._update_min(x, l, r, 0, 0, self.n0)",
        "    }",
        "    pub fn chmin(&mut self, l: usize, r: usize, x: i64) {",
        "        self._update_max(x, l, r, 0, 0, self.n0)",
        "    }",
        "    pub fn add_val(&mut self, l: usize, r: usize, x: i64) {",
        "        self._add_val(x, l, r, 0, 0, self.n0)",
        "    }",
        "    pub fn update_val(&mut self, l: usize, r: usize, x: i64) {",
        "        self._update_val(x, l, r, 0, 0, self.n0)",
        "    }",
        "}"
      ]
    },
    "SEGNode": {
      "prefix": "SEGNode",
      "body": [
        "#[derive(PartialEq, Debug)]",
        "pub enum SEGNode {",
        "    Leaf { k: usize },",
        "    Branch { k: usize, l: usize, r: usize },",
        "}",
        "pub struct SEGTree {",
        "    /// 葉の数（２の累乗）",
        "    pub n: usize,",
        "}",
        "impl SEGTree {",
        "    pub fn new(n: usize) -> SEGTree {",
        "        let n = n.next_power_of_two();",
        "        Self { n: n }",
        "    }",
        "    pub fn update_nodes(&self, i: usize) -> Vec<SEGNode> {",
        "        use SEGNode::*;",
        "        let mut i = i + self.n;",
        "        let mut res = vec![Leaf { k: i }];",
        "        while i > 1 {",
        "            i >>= 1;",
        "            res.push(Branch {",
        "                k: i,",
        "                l: i * 2,",
        "                r: i * 2 + 1,",
        "            });",
        "        }",
        "        res",
        "    }",
        "    /// [l,r)",
        "    pub fn query_nodes(&self, l: usize, r: usize) -> Vec<usize> {",
        "        let mut ret = vec![];",
        "        let mut l = l + self.n;",
        "        let mut r = r + self.n;",
        "        while l < r {",
        "            if l & 1 > 0 {",
        "                ret.push(l);",
        "                l += 1;",
        "            }",
        "            if r & 1 > 0 {",
        "                r -= 1;",
        "                ret.push(r);",
        "            }",
        "            l >>= 1;",
        "            r >>= 1;",
        "        }",
        "        ret",
        "    }",
        "}"
      ]
    },
    "SEG_LAZY": {
      "prefix": "SEG_LAZY",
      "body": [
        "/// 遅延セグ木",
        "///",
        "/// 範囲updateをサポートする。",
        "/// update時には作用素のみをノードに載せるのみにとどめ、",
        "/// query時にあるノードの作用素の値が必要になった時に作用素を伝搬する。",
        "/// この回数がたかだかO(logN)しかない。",
        "///",
        "/// 計算量:",
        "/// update l r f: O(logN)",
        "/// query l r: O(logN)",
        "trait SEGLazyImpl {",
        "    type Monoid: Copy;",
        "    type F: Copy + PartialEq;",
        "    fn e() -> Self::Monoid;",
        "    fn id() -> Self::F;",
        "    /// x `op` y",
        "    fn op(x: Self::Monoid, y: Self::Monoid) -> Self::Monoid;",
        "    /// f(x)",
        "    fn ap(f: Self::F, x: Self::Monoid) -> Self::Monoid;",
        "    /// f . g",
        "    fn compose(f: Self::F, g: Self::F) -> Self::F;",
        "}",
        "struct SEGLazy<T: SEGLazyImpl> {",
        "    n: usize,",
        "    data: Vec<T::Monoid>,",
        "    lazy: Vec<T::F>,",
        "}",
        "impl<T: SEGLazyImpl> SEGLazy<T> {",
        "    pub fn new(n: usize, init: T::Monoid) -> Self {",
        "        let mut m = 1;",
        "        while m < n {",
        "            m *= 2;",
        "        }",
        "        SEGLazy {",
        "            n: m,",
        "            data: vec![init; m * 2],",
        "            lazy: vec![T::id(); m * 2],",
        "        }",
        "    }",
        "    fn propagate(&mut self, k: usize) {",
        "        if self.lazy[k] != T::id() {",
        "            if k < self.n {",
        "                self.lazy[2 * k + 0] = T::compose(self.lazy[k], self.lazy[2 * k + 0]);",
        "                self.lazy[2 * k + 1] = T::compose(self.lazy[k], self.lazy[2 * k + 1]);",
        "            }",
        "            self.data[k] = T::ap(self.lazy[k], self.data[k]);",
        "            self.lazy[k] = T::id();",
        "        }",
        "    }",
        "    fn do_update(",
        "        &mut self,",
        "        a: usize,",
        "        b: usize,",
        "        x: T::F,",
        "        k: usize,",
        "        l: usize,",
        "        r: usize,",
        "    ) -> T::Monoid {",
        "        self.propagate(k);",
        "        if r <= a || b <= l {",
        "            self.data[k]",
        "        } else if a <= l && r <= b {",
        "            self.lazy[k] = T::compose(x, self.lazy[k]);",
        "            self.propagate(k);",
        "            self.data[k]",
        "        } else {",
        "            self.data[k] = T::op(",
        "                self.do_update(a, b, x, 2 * k + 0, l, (l + r) >> 1),",
        "                self.do_update(a, b, x, 2 * k + 1, (l + r) >> 1, r),",
        "            );",
        "            self.data[k]",
        "        }",
        "    }",
        "    ///[l,r)",
        "    pub fn update(&mut self, l: usize, r: usize, x: T::F) -> T::Monoid {",
        "        let n = self.n;",
        "        self.do_update(l, r, x, 1, 0, n)",
        "    }",
        "    fn do_query(&mut self, a: usize, b: usize, k: usize, l: usize, r: usize) -> T::Monoid {",
        "        self.propagate(k);",
        "        if r <= a || b <= l {",
        "            T::e()",
        "        } else if a <= l && r <= b {",
        "            self.data[k]",
        "        } else {",
        "            T::op(",
        "                self.do_query(a, b, 2 * k + 0, l, (l + r) >> 1),",
        "                self.do_query(a, b, 2 * k + 1, (l + r) >> 1, r),",
        "            )",
        "        }",
        "    }",
        "    ///[l,r)",
        "    pub fn query(&mut self, l: usize, r: usize) -> T::Monoid {",
        "        let n = self.n;",
        "        self.do_query(l, r, 1, 0, n)",
        "    }",
        "}"
      ]
    },
    "SEG_LAZY_MAX_RAQ": {
      "prefix": "SEG_LAZY_MAX_RAQ",
      "body": [
        "struct MAX_RAQ;",
        "impl SEGLazyImpl for MAX_RAQ {",
        "    type Monoid = i64;",
        "    type F = i64;",
        "    fn e() -> Self::Monoid {",
        "        std::i64::MIN",
        "    }",
        "    fn id() -> Self::F {",
        "        0",
        "    }",
        "    fn op(x: Self::Monoid, y: Self::Monoid) -> Self::Monoid {",
        "        std::cmp::max(x, y)",
        "    }",
        "    fn ap(f: Self::F, x: Self::Monoid) -> Self::Monoid {",
        "        x + f",
        "    }",
        "    fn compose(f: Self::F, g: Self::F) -> Self::F {",
        "        g + f",
        "    }",
        "}"
      ]
    },
    "SEG_LAZY_MAX_RUQ": {
      "prefix": "SEG_LAZY_MAX_RUQ",
      "body": [
        "struct MAX_RUQ;",
        "impl SEGLazyImpl for MAX_RUQ {",
        "    type Monoid = i64;",
        "    type F = i64;",
        "    fn e() -> Self::Monoid {",
        "        0",
        "    }",
        "    fn id() -> Self::F {",
        "        0",
        "    }",
        "    fn op(x: Self::Monoid, y: Self::Monoid) -> Self::Monoid {",
        "        std::cmp::max(x, y)",
        "    }",
        "    fn ap(f: Self::F, x: Self::Monoid) -> Self::Monoid {",
        "        f",
        "    }",
        "    fn compose(f: Self::F, g: Self::F) -> Self::F {",
        "        f",
        "    }",
        "}"
      ]
    },
    "SEG_LAZY_MIN_RAQ": {
      "prefix": "SEG_LAZY_MIN_RAQ",
      "body": [
        "struct MIN_RAQ;",
        "impl SEGLazyImpl for MIN_RAQ {",
        "    type Monoid = i64;",
        "    type F = i64;",
        "    fn e() -> Self::Monoid {",
        "        std::i64::MAX",
        "    }",
        "    fn id() -> Self::F {",
        "        0",
        "    }",
        "    fn op(x: Self::Monoid, y: Self::Monoid) -> Self::Monoid {",
        "        std::cmp::min(x, y)",
        "    }",
        "    fn ap(f: Self::F, x: Self::Monoid) -> Self::Monoid {",
        "        x + f",
        "    }",
        "    fn compose(f: Self::F, g: Self::F) -> Self::F {",
        "        g + f",
        "    }",
        "}"
      ]
    },
    "SEG_LAZY_MIN_RUQ": {
      "prefix": "SEG_LAZY_MIN_RUQ",
      "body": [
        "struct MIN_RUQ;",
        "impl SEGLazyImpl for MIN_RUQ {",
        "    type Monoid = i64;",
        "    type F = i64;",
        "    fn e() -> Self::Monoid {",
        "        std::i64::MAX",
        "    }",
        "    fn id() -> Self::F {",
        "        std::i64::MAX",
        "    }",
        "    fn op(x: Self::Monoid, y: Self::Monoid) -> Self::Monoid {",
        "        std::cmp::min(x, y)",
        "    }",
        "    fn ap(f: Self::F, x: Self::Monoid) -> Self::Monoid {",
        "        f",
        "    }",
        "    fn compose(f: Self::F, g: Self::F) -> Self::F {",
        "        f",
        "    }",
        "}"
      ]
    },
    "SEG_MAX": {
      "prefix": "SEG_MAX",
      "body": [
        "struct MAX;",
        "impl Monoid for MAX {",
        "    type T = i64;",
        "    fn id() -> Self::T {",
        "        std::i64::MIN",
        "    }",
        "    fn op(a: &Self::T, b: &Self::T) -> Self::T {",
        "        std::cmp::max(*a, *b)",
        "    }",
        "}"
      ]
    },
    "SEG_MIN": {
      "prefix": "SEG_MIN",
      "body": [
        "#[allow(dead_code)]",
        "struct MIN;",
        "impl Monoid for MIN {",
        "    type T = i64;",
        "    fn id() -> Self::T {",
        "        std::i64::MAX",
        "    }",
        "    fn op(a: &Self::T, b: &Self::T) -> Self::T {",
        "        std::cmp::min(*a, *b)",
        "    }",
        "}"
      ]
    },
    "SEG_SUM": {
      "prefix": "SEG_SUM",
      "body": [
        "#[allow(dead_code)]",
        "struct SUM;",
        "impl Monoid for SUM {",
        "    type T = i64;",
        "    fn id() -> Self::T {",
        "        0",
        "    }",
        "    fn op(a: &Self::T, b: &Self::T) -> Self::T {",
        "        *a + *b",
        "    }",
        "}"
      ]
    },
    "SparseTable": {
      "prefix": "SparseTable",
      "body": [
        "/// 範囲[l,r)の中の最小値のインデックスを求める",
        "/// 構築 O(N logN)",
        "/// クエリ O(1)",
        "pub struct SparseTable {",
        "    data: Vec<i64>,",
        "    log_table: Vec<usize>,",
        "    table: Vec<Vec<usize>>,",
        "}",
        "impl SparseTable {",
        "    pub fn new(data: Vec<i64>) -> Self {",
        "        let n = data.len();",
        "        let mut log_table = vec![0; n + 1];",
        "        for i in 2..n + 1 {",
        "            log_table[i] = log_table[i >> 1] + 1;",
        "        }",
        "        let mut table = vec![vec![n; n]; log_table[n] + 1];",
        "        for i in 0..n {",
        "            table[0][i] = i;",
        "        }",
        "        for k in 1..table.len() {",
        "            let half_jmp = 1 << (k - 1);",
        "            for i in 0..n {",
        "                let first = table[k - 1][i];",
        "                table[k][i] = first;",
        "                if i + half_jmp < n {",
        "                    let second = table[k - 1][i + half_jmp];",
        "                    assert!(first < n);",
        "                    assert!(second < n);",
        "                    if data[first] <= data[second] {",
        "                        table[k][i] = first;",
        "                    } else {",
        "                        table[k][i] = second;",
        "                    }",
        "                }",
        "            }",
        "        }",
        "        Self {",
        "            data,",
        "            log_table,",
        "            table,",
        "        }",
        "    }",
        "    /// [a, b)",
        "    pub fn query(&self, a: usize, b: usize) -> usize {",
        "        let d = b - a;",
        "        let k = self.log_table[d];",
        "        let first = self.table[k][a];",
        "        let second = self.table[k][b - (1 << k)];",
        "        if self.data[first] <= self.data[second] {",
        "            first",
        "        } else {",
        "            second",
        "        }",
        "    }",
        "}"
      ]
    },
    "SqrtDecomposition": {
      "prefix": "SqrtDecomposition",
      "body": [
        "/// N個の配列をrootN個ずつ分割する。",
        "/// こうすることで、更新とクエリをO(rootN)にすることが出来る。",
        "///",
        "/// Nは何らかの平方数であることが望ましいので、",
        "/// まず、N=d*dとなるように拡張し、整理する。",
        "///",
        "/// buckets(l,r)は、[l,r)にオーバーラップする",
        "/// バケットの列を計算する。計算量はO(rootN)",
        "///",
        "/// セグ木に対する優位性は汎用性が高いこと。",
        "#[derive(Debug, Copy, Clone)]",
        "enum Bucket {",
        "    ///b-idx",
        "    Filled { bucket_index: usize },",
        "    ///b-idx, [to, from)",
        "    Partial {",
        "        bucket_index: usize,",
        "        l: usize,",
        "        r: usize,",
        "    },",
        "}",
        "struct Buckets {",
        "    pub d: usize,",
        "}",
        "impl Buckets {",
        "    pub fn new(n: usize) -> Self {",
        "        let mut d = 1;",
        "        while d * d < n {",
        "            d += 1;",
        "        }",
        "        Self { d }",
        "    }",
        "    pub fn n(&self) -> usize {",
        "        self.d * self.d",
        "    }",
        "    ///[l, r)",
        "    pub fn buckets(&self, l: usize, r: usize) -> Vec<Bucket> {",
        "        if l == r {",
        "            return vec![];",
        "        }",
        "        assert!(r > l);",
        "        let mut res = vec![];",
        "        let bl = l / self.d;",
        "        let br = (r - 1) / self.d;",
        "        if bl == br {",
        "            if l % self.d == 0 && r % self.d == 0 {",
        "                res.push(Bucket::Filled { bucket_index: bl });",
        "            } else {",
        "                res.push(Bucket::Partial {",
        "                    bucket_index: bl,",
        "                    l,",
        "                    r,",
        "                });",
        "            }",
        "        } else {",
        "            if l % self.d == 0 {",
        "                res.push(Bucket::Filled { bucket_index: bl });",
        "            } else {",
        "                let bnext = bl + 1;",
        "                res.push(Bucket::Partial {",
        "                    bucket_index: bl,",
        "                    l,",
        "                    r: bnext * self.d,",
        "                });",
        "            }",
        "            for i in bl + 1..br {",
        "                res.push(Bucket::Filled { bucket_index: i });",
        "            }",
        "            if r % self.d == 0 {",
        "                res.push(Bucket::Filled { bucket_index: br });",
        "            } else {",
        "                res.push(Bucket::Partial {",
        "                    bucket_index: br,",
        "                    l: br * self.d,",
        "                    r,",
        "                });",
        "            }",
        "        }",
        "        res",
        "    }",
        "}"
      ]
    },
    "SuffixArray": {
      "prefix": "SuffixArray",
      "body": [
        "/// 各suffixを列挙し、その辞書順",
        "/// suffix -> 順番",
        "/// を構築する。",
        "///",
        "/// 構築計算量 O(|S| log |S|)",
        "///",
        "/// ある文字列Tがどれかのsuffixとprefixが一致するとき、",
        "/// マッチングが検索出来ていることになる。",
        "/// 従って、suffixについて二分探索をすることによって、",
        "/// マッチングしたインデックスを調べることが出来る。",
        "///",
        "/// 計算量 O(|T| log |S|)",
        "struct SuffixArray {",
        "    sa: Vec<usize>,",
        "    s: Vec<u64>,",
        "}",
        "impl SuffixArray {",
        "    pub fn new(s: Vec<u64>) -> Self {",
        "        let mut s = s;",
        "        s.push('\\$' as u64);",
        "        let mut sa = Self::sort_cyclic_shifts(&s);",
        "        sa.remove(0);",
        "        s.remove(s.len() - 1);",
        "        SuffixArray { sa: sa, s: s }",
        "    }",
        "    fn sort_cyclic_shifts(s: &[u64]) -> Vec<usize> {",
        "        let n = s.len();",
        "        const alphabet: usize = 256;",
        "        let mut p = vec![0; n];",
        "        let mut c = vec![0; n];",
        "        let mut cnt = vec![0; std::cmp::max(alphabet, n)];",
        "        for i in 0..n {",
        "            cnt[s[i] as usize] += 1;",
        "        }",
        "        for i in 1..alphabet {",
        "            cnt[i] += cnt[i - 1];",
        "        }",
        "        for i in 0..n {",
        "            cnt[s[i] as usize] -= 1;",
        "            p[cnt[s[i] as usize]] = i;",
        "        }",
        "        c[p[0]] = 0;",
        "        let mut classes = 1;",
        "        for i in 1..n {",
        "            if s[p[i]] != s[p[i - 1]] {",
        "                classes += 1;",
        "            }",
        "            c[p[i]] = classes - 1;",
        "        }",
        "        let mut pn = vec![0; n];",
        "        let mut cn = vec![0; n];",
        "        for k in 0.. {",
        "            if (1 << k) >= n {",
        "                break;",
        "            }",
        "            for i in 0..n {",
        "                if p[i] >= (1 << k) {",
        "                    pn[i] = p[i] - (1 << k);",
        "                } else {",
        "                    pn[i] = p[i] + n - (1 << k);",
        "                }",
        "            }",
        "            for i in 0..classes {",
        "                cnt[i] = 0;",
        "            }",
        "            for i in 0..n {",
        "                cnt[c[pn[i]]] += 1;",
        "            }",
        "            for i in 1..classes {",
        "                cnt[i] += cnt[i - 1];",
        "            }",
        "            for i in (0..n).rev() {",
        "                cnt[c[pn[i]]] -= 1;",
        "                p[cnt[c[pn[i]]]] = pn[i];",
        "            }",
        "            cn[p[0]] = 0;",
        "            classes = 1;",
        "            for i in 1..n {",
        "                let cur = (c[p[i]], c[(p[i] + (1 << k)) % n]);",
        "                let prev = (c[p[i - 1]], c[(p[i - 1] + (1 << k)) % n]);",
        "                if cur != prev {",
        "                    classes += 1;",
        "                }",
        "                cn[p[i]] = classes - 1;",
        "            }",
        "            let tmp = c;",
        "            c = cn;",
        "            cn = tmp",
        "        }",
        "        p",
        "    }",
        "    fn lt_substr(s: &[u64], t: &[u64], si: usize, ti: usize) -> bool {",
        "        let mut si = si;",
        "        let mut ti = ti;",
        "        let sn = s.len();",
        "        let tn = t.len();",
        "        while si < sn && ti < tn {",
        "            if s[si] < t[ti] {",
        "                return true;",
        "            }",
        "            if s[si] > t[ti] {",
        "                return false;",
        "            }",
        "            si += 1;",
        "            ti += 1;",
        "        }",
        "        si >= sn && ti < tn",
        "    }",
        "    ///find the rightmost match of the string t to s. O(mlogn) where n=|s|,m=|t|",
        "    fn lower_bound(&self, t: &[u64]) -> usize {",
        "        let mut low: i64 = -1;",
        "        let mut high: i64 = self.sa.len() as i64;",
        "        while high - low > 1 {",
        "            let mid = (low + high) / 2;",
        "            if Self::lt_substr(&self.s, t, self.sa[mid as usize], 0) {",
        "                low = mid;",
        "            } else {",
        "                high = mid;",
        "            }",
        "        }",
        "        return high as usize;",
        "    }",
        "    pub fn right_most_index(&self, t: &[u64]) -> usize {",
        "        self.sa[self.lower_bound(t)]",
        "    }",
        "}"
      ]
    },
    "TopologicalSort": {
      "prefix": "TopologicalSort",
      "body": [
        "struct TopologicalSort {",
        "    g: Vec<Vec<usize>>,",
        "    colors: Vec<bool>,",
        "    indeg: Vec<u32>,",
        "    Q: VecDeque<usize>,",
        "    out: Vec<usize>,",
        "}",
        "impl TopologicalSort {",
        "    pub fn new(n: usize) -> Self {",
        "        let colors = vec![false; n];",
        "        let indeg = vec![0; n];",
        "        TopologicalSort {",
        "            g: vec![vec![]; n],",
        "            Q: VecDeque::new(),",
        "            colors: colors,",
        "            indeg: indeg,",
        "            out: Vec::new(),",
        "        }",
        "    }",
        "    pub fn add_edge(&mut self, u: usize, v: usize) {",
        "        self.g[u].push(v);",
        "    }",
        "    fn bfs(&mut self, s: usize) {",
        "        self.Q.push_back(s);",
        "        self.colors[s] = true;",
        "        while !self.Q.is_empty() {",
        "            let u = self.Q.pop_front().unwrap();",
        "            self.out.push(u);",
        "            for &v in &self.g[u] {",
        "                self.indeg[v] -= 1;",
        "                if self.indeg[v] == 0 && self.colors[v] == false {",
        "                    self.colors[v] = true;",
        "                    self.Q.push_back(v);",
        "                }",
        "            }",
        "        }",
        "    }",
        "    pub fn tsort(&mut self) {",
        "        let n = self.g.len();",
        "        for u in 0..n {",
        "            let conn = &self.g[u];",
        "            for &next in conn {",
        "                self.indeg[next] += 1;",
        "            }",
        "        }",
        "        for u in 0..n {",
        "            if self.indeg[u] == 0 && self.colors[u] == false {",
        "                self.bfs(u)",
        "            }",
        "        }",
        "    }",
        "}"
      ]
    },
    "Total": {
      "prefix": "Total",
      "body": [
        "#[derive(PartialEq, PartialOrd)]",
        "/// Implement Eq and Ord for a type which has only PartialEq and PartialOrd.",
        "/// It is useful when sorting a Vec of f64",
        "pub struct Total<T>(pub T);",
        "impl<T: PartialEq> Eq for Total<T> {}",
        "impl<T: PartialOrd> Ord for Total<T> {",
        "    fn cmp(&self, other: &Total<T>) -> Ordering {",
        "        self.0.partial_cmp(&other.0).unwrap()",
        "    }",
        "}"
      ]
    },
    "Treap": {
      "prefix": "Treap",
      "body": [
        "mod treap {",
        "    #[derive(Clone, Debug)]",
        "    pub struct Node {",
        "        pub v: i64,",
        "        pri: u64,",
        "        lch: Option<Box<Node>>,",
        "        rch: Option<Box<Node>>,",
        "        cnt: usize,",
        "        sum: i64,",
        "    }",
        "    pub fn new_node(v: i64, rand: u64) -> Node {",
        "        Node {",
        "            v: v,",
        "            pri: rand,",
        "            lch: None.into(),",
        "            rch: None.into(),",
        "            cnt: 1,",
        "            sum: v,",
        "        }",
        "    }",
        "    pub fn count(t: &Option<Box<Node>>) -> usize {",
        "        match *t {",
        "            Some(ref x) => x.cnt,",
        "            None => 0,",
        "        }",
        "    }",
        "    pub fn sum(t: &Option<Box<Node>>) -> i64 {",
        "        match *t {",
        "            Some(ref x) => x.sum,",
        "            None => 0,",
        "        }",
        "    }",
        "    fn update(t: Box<Node>) -> Box<Node> {",
        "        let mut t = t;",
        "        t.cnt = count(&t.lch) + count(&t.rch) + 1;",
        "        t.sum = sum(&t.lch) + sum(&t.rch) + t.v;",
        "        t",
        "    }",
        "    pub fn merge(l: Option<Box<Node>>, r: Option<Box<Node>>) -> Option<Box<Node>> {",
        "        if l.is_none() && r.is_none() {",
        "            return None;",
        "        }",
        "        if l.is_none() {",
        "            return r;",
        "        }",
        "        if r.is_none() {",
        "            return l;",
        "        }",
        "        assert!(l.is_some() && r.is_some());",
        "        let mut l = l.unwrap();",
        "        let mut r = r.unwrap();",
        "        if l.pri > r.pri {",
        "            let old_rch = l.rch.take();",
        "            l.rch = merge(old_rch, Some(r).into());",
        "            update(l).into()",
        "        } else {",
        "            let old_lch = r.lch.take();",
        "            r.lch = merge(Some(l).into(), old_lch);",
        "            update(r).into()",
        "        }",
        "    }",
        "    pub fn split(t: Option<Box<Node>>, k: usize) -> (Option<Box<Node>>, Option<Box<Node>>) {",
        "        if t.is_none() {",
        "            return (None.into(), None.into());",
        "        }",
        "        let mut t = t.unwrap();",
        "        let lcnt = count(&t.lch);",
        "        if k <= lcnt {",
        "            let old_lch = t.lch.take();",
        "            let s = split(old_lch, k);",
        "            t.lch = s.1;",
        "            (s.0, Some(update(t)).into())",
        "        } else {",
        "            let old_rch = t.rch.take();",
        "            let s = split(old_rch, k - lcnt - 1);",
        "            t.rch = s.0;",
        "            (Some(update(t)).into(), s.1)",
        "        }",
        "    }",
        "    pub fn insert(t: Box<Node>, k: usize, v: i64, rand: u64) -> Option<Box<Node>> {",
        "        let (l, r) = split(Some(t).into(), k);",
        "        let newt = merge(l, Some(new_node(v, rand).into()));",
        "        let newt = merge(newt, r);",
        "        newt",
        "    }",
        "    pub fn erase(t: Box<Node>, k: usize) -> Option<Box<Node>> {",
        "        let (t1, rest) = split(Some(t).into(), k);",
        "        let (t2, t3) = split(rest, 1);",
        "        merge(t1, t3)",
        "    }",
        "    pub fn bisect(t: &Option<Box<Node>>, v: i64) -> usize {",
        "        match *t {",
        "            None => 0,",
        "            Some(ref n) => {",
        "                if v <= n.v {",
        "                    bisect(&n.lch, v)",
        "                } else {",
        "                    count(&n.lch) + 1 + bisect(&n.rch, v)",
        "                }",
        "            }",
        "        }",
        "    }",
        "}",
        "struct Treap {",
        "    rng: Xorshift,",
        "    t: Option<Box<treap::Node>>,",
        "}",
        "impl Treap {",
        "    pub fn new() -> Treap {",
        "        Treap {",
        "            rng: Xorshift::new(),",
        "            t: None,",
        "        }",
        "    }",
        "    ///[l,r)",
        "    pub fn lower_bound(&mut self, l: usize, r: usize, v: i64) -> usize {",
        "        let t = self.t.take();",
        "        let (lt, t) = treap::split(t, l);",
        "        let (t, rt) = treap::split(t, r - l);",
        "        let idx = treap::count(&lt) + treap::bisect(&t, v);",
        "        self.t = treap::merge(lt, treap::merge(t, rt));",
        "        idx",
        "    }",
        "    pub fn orderd_insert(&mut self, v: i64) {",
        "        if self.t.is_none() {",
        "            self.insert(0, v);",
        "        } else {",
        "            let n = self.len();",
        "            let ins_pos = self.lower_bound(0, n, v);",
        "            self.insert(ins_pos, v);",
        "        }",
        "    }",
        "    pub fn insert(&mut self, k: usize, v: i64) {",
        "        if self.t.is_none() {",
        "            self.t = Some(treap::new_node(v, self.rng.next()).into());",
        "        } else {",
        "            let t = self.t.take().unwrap();",
        "            self.t = treap::insert(t, k, v, self.rng.next());",
        "        }",
        "    }",
        "    pub fn erase(&mut self, k: usize) {",
        "        if self.t.is_some() {",
        "            let t = self.t.take().unwrap();",
        "            self.t = treap::erase(t, k).into();",
        "        }",
        "    }",
        "    ///split into [l,r)+[r,n)",
        "    pub fn split(self, k: usize) -> (Treap, Treap) {",
        "        let (a, b) = treap::split(self.t, k);",
        "        (",
        "            Treap {",
        "                rng: self.rng.clone(),",
        "                t: a,",
        "            },",
        "            Treap {",
        "                rng: self.rng.clone(),",
        "                t: b,",
        "            },",
        "        )",
        "    }",
        "    pub fn len(&self) -> usize {",
        "        treap::count(&self.t)",
        "    }",
        "    ///[l,r)",
        "    pub fn sum(&mut self, l: usize, r: usize) -> i64 {",
        "        if self.t.is_none() {",
        "            return 0;",
        "        } else {",
        "            let t = self.t.take();",
        "            let (a1, a2) = treap::split(t, l);",
        "            let (b1, b2) = treap::split(a2, r - l);",
        "            let res = treap::sum(&b1);",
        "            self.t = treap::merge(treap::merge(a1, b1), b2);",
        "            res",
        "        }",
        "    }",
        "    pub fn get(&mut self, k: usize) -> i64 {",
        "        self.sum(k, k + 1)",
        "    }",
        "}"
      ]
    },
    "TreeCentroid": {
      "prefix": "TreeCentroid",
      "body": [
        "/// 木の重心分解",
        "///",
        "/// 木の重心とは、その頂点の周りにある部分木が",
        "/// どれも元の木の半分以下の大きさになってる頂点のことである。",
        "///",
        "/// アイデア:",
        "/// 適当な頂点から木DPをして、部分木のサイズを求める。",
        "/// そして、全頂点のうち、全部分木がN/2以下のサイズになってるものを列挙する。",
        "/// 自分を頂点とした部分木のサイズが求まれば、親ノード側の部分木のサイズも求まる。",
        "pub struct Centroid {",
        "    pub g: Vec<Vec<usize>>,",
        "    pub centroid: Vec<usize>,",
        "    subsize: Vec<usize>,",
        "}",
        "impl Centroid {",
        "    pub fn new(n: usize) -> Centroid {",
        "        Centroid {",
        "            g: vec![vec![]; n],",
        "            centroid: vec![],",
        "            subsize: vec![0; n],",
        "        }",
        "    }",
        "    pub fn connect(&mut self, u: usize, v: usize) {",
        "        self.g[u].push(v);",
        "        self.g[v].push(u);",
        "    }",
        "    ///O(nlogn)",
        "    pub fn build(&mut self) {",
        "        let n = self.g.len();",
        "        self.rec(0, n);",
        "    }",
        "    fn rec(&mut self, u: usize, par: usize) {",
        "        let n = self.g.len();",
        "        self.subsize[u] = 1;",
        "        let mut is_centroid = true;",
        "        for i in 0..self.g[u].len() {",
        "            let ch = self.g[u][i];",
        "            if ch == par {",
        "                continue;",
        "            }",
        "            self.rec(ch, u);",
        "            if self.subsize[ch] > n / 2 {",
        "                is_centroid = false;",
        "            }",
        "            self.subsize[u] += self.subsize[ch];",
        "        }",
        "        if n - self.subsize[u] > n / 2 {",
        "            is_centroid = false;",
        "        }",
        "        if is_centroid {",
        "            self.centroid.push(u);",
        "        }",
        "    }",
        "}"
      ]
    },
    "TwoPointer": {
      "prefix": "TwoPointer",
      "body": [
        "struct TwoPointer<F> {",
        "    n: usize,",
        "    f: F,",
        "}",
        "impl<F: FnMut(usize, usize) -> bool> TwoPointer<F> {",
        "    pub fn new(n: usize, f: F) -> TwoPointer<F> {",
        "        TwoPointer { n: n, f: f }",
        "    }",
        "    pub fn run(&mut self) {",
        "        let mut l = 0;",
        "        let mut r = 0;",
        "        loop {",
        "            let mut ok = (self.f)(l, r);",
        "            if r == self.n {",
        "                ok = false;",
        "            }",
        "            if !ok {",
        "                l += 1;",
        "            } else {",
        "                r += 1;",
        "            }",
        "            if l == self.n && r == self.n {",
        "                break;",
        "            }",
        "        }",
        "    }",
        "}"
      ]
    },
    "UnionFind": {
      "prefix": "UnionFind",
      "body": [
        "pub struct UnionFind {",
        "    par: Vec<usize>,",
        "    rank: Vec<usize>,",
        "}",
        "impl UnionFind {",
        "    pub fn new(n: usize) -> UnionFind {",
        "        UnionFind {",
        "            par: (0..n).collect::<Vec<usize>>(),",
        "            rank: vec![1; n],",
        "        }",
        "    }",
        "    pub fn size(&mut self, x: usize) -> usize {",
        "        let y = self.root(x);",
        "        self.rank[y]",
        "    }",
        "    pub fn same(&mut self, x: usize, y: usize) -> bool {",
        "        self.root(x) == self.root(y)",
        "    }",
        "    pub fn root(&mut self, x: usize) -> usize {",
        "        if self.par[x] == x {",
        "            return x;",
        "        } else {",
        "            let y = self.par[x];",
        "            let z = self.root(y);",
        "            self.par[x] = z;",
        "            return z;",
        "        }",
        "    }",
        "    pub fn merge(&mut self, x: usize, y: usize) -> bool {",
        "        let mut a = self.root(x);",
        "        let mut b = self.root(y);",
        "        if a == b {",
        "            return false;",
        "        }",
        "        if self.rank[a] < self.rank[b] {",
        "            std::mem::swap(&mut a, &mut b);",
        "        }",
        "        assert!(self.rank[a] >= self.rank[b]);",
        "        self.rank[a] += self.rank[b];",
        "        self.par[b] = a;",
        "        return true;",
        "    }",
        "}"
      ]
    },
    "WaveletMatrix": {
      "prefix": "WaveletMatrix",
      "body": [
        "#[derive(Clone)]",
        "struct FID {",
        "    n: usize,",
        "    n_blocks: usize,",
        "    blocks: Vec<u64>,",
        "    block_rank1: Vec<usize>,",
        "}",
        "impl FID {",
        "    fn popcount(x: u64) -> usize {",
        "        u64::count_ones(x) as usize",
        "    }",
        "    fn kpopi(x: u64, k: usize) -> usize {",
        "        let mut x = x;",
        "        let mut k = k;",
        "        let mut ans = 64;",
        "        for i in 0..64 {",
        "            if x & (1 << i) > 0 {",
        "                k -= 1;",
        "            }",
        "            if k == 0 {",
        "                ans = i;",
        "                break;",
        "            }",
        "        }",
        "        ans",
        "    }",
        "    pub fn new(n: usize) -> FID {",
        "        let n_blocks = (n >> 6) + 1;",
        "        FID {",
        "            n: n,",
        "            n_blocks: (n >> 6) + 1,",
        "            blocks: vec![0; n_blocks],",
        "            block_rank1: vec![0; n_blocks],",
        "        }",
        "    }",
        "    pub fn set(&mut self, k: usize) {",
        "        self.blocks[k >> 6] |= 1 << (k & 0b111111);",
        "    }",
        "    pub fn build(&mut self) {",
        "        self.block_rank1[0] = 0;",
        "        for i in 1..self.n_blocks {",
        "            self.block_rank1[i] = self.block_rank1[i - 1] + Self::popcount(self.blocks[i - 1]);",
        "        }",
        "    }",
        "    pub fn access(&self, k: usize) -> bool {",
        "        let x = self.blocks[k >> 6] & 1 << (k & 0b111111);",
        "        if x > 0 {",
        "            true",
        "        } else {",
        "            false",
        "        }",
        "    }",
        "    ///count 1s in [0,k)",
        "    pub fn rank1(&self, k: usize) -> usize {",
        "        let mask = (1 << (k & 0b111111)) - 1;",
        "        let rest = self.blocks[k >> 6] & mask;",
        "        self.block_rank1[k >> 6] + Self::popcount(rest)",
        "    }",
        "    ///count 0s in [0,k). O(1)",
        "    pub fn rank0(&self, k: usize) -> usize {",
        "        k - self.rank1(k)",
        "    }",
        "    pub fn rank(&self, b: bool, k: usize) -> usize {",
        "        if b {",
        "            self.rank1(k)",
        "        } else {",
        "            self.rank0(k)",
        "        }",
        "    }",
        "    ///query the index of k-th 0 (0-indexed)",
        "    pub fn select0(&self, k: usize) -> usize {",
        "        let mut bs = BinarySearch {",
        "            l: 0,",
        "            r: self.n as i64,",
        "            f: |i: i64| {",
        "                let r = self.rank0(i as usize);",
        "                r >= k + 1",
        "            },",
        "        };",
        "        bs.lower_bound() as usize - 1",
        "    }",
        "    ///query the index of k-th 1 (0-indexed)",
        "    pub fn select1(&self, k: usize) -> usize {",
        "        let mut bs = BinarySearch {",
        "            l: 0,",
        "            r: self.n as i64,",
        "            f: |i: i64| {",
        "                let r = self.rank1(i as usize);",
        "                r >= k + 1",
        "            },",
        "        };",
        "        bs.lower_bound() as usize - 1",
        "    }",
        "    pub fn select(&self, b: bool, k: usize) -> usize {",
        "        if b {",
        "            self.select1(k)",
        "        } else {",
        "            self.select0(k)",
        "        }",
        "    }",
        "}",
        "struct WM {",
        "    mat: Vec<FID>,",
        "    nzeros: Vec<usize>,",
        "}",
        "impl WM {",
        "    pub fn new(xs: Vec<u64>) -> WM {",
        "        let n = xs.len();",
        "        let mut mat = vec![];",
        "        let mut nzeros = vec![];",
        "        let mut cur = xs;",
        "        for i in 0..64 {",
        "            let mid = 1 << (63 - i);",
        "            let mask = mid - 1;",
        "            let mut b = vec![];",
        "            let mut left = vec![];",
        "            let mut right = vec![];",
        "            for i in 0..n {",
        "                let x = cur[i];",
        "                if x >= mid {",
        "                    right.push(x & mask);",
        "                    b.push(true);",
        "                } else {",
        "                    left.push(x & mask);",
        "                    b.push(false);",
        "                }",
        "            }",
        "            nzeros.push(left.len());",
        "            left.append(&mut right);",
        "            cur = left;",
        "            let mut fid = FID::new(n);",
        "            for i in 0..n {",
        "                if b[i] {",
        "                    fid.set(i);",
        "                }",
        "            }",
        "            fid.build();",
        "            mat.push(fid);",
        "        }",
        "        WM {",
        "            mat: mat,",
        "            nzeros: nzeros,",
        "        }",
        "    }",
        "    ///counting x in v[0,i) O(1)",
        "    pub fn rank(&self, x: u64, i: usize) -> usize {",
        "        let mut s = 0;",
        "        let mut e = i;",
        "        for d in 0..64 {",
        "            let fid = &self.mat[d];",
        "            let b = x & (1 << (63 - d)) > 0;",
        "            s = fid.rank(b, s);",
        "            e = fid.rank(b, e);",
        "            if b {",
        "                s += self.nzeros[d];",
        "                e += self.nzeros[d];",
        "            }",
        "        }",
        "        e - s",
        "    }",
        "    ///the position of k-th x (0-indexed). O(logn)",
        "    pub fn select(&self, x: u64, k: usize) -> usize {",
        "        let mut bs = BinarySearch {",
        "            l: 0,",
        "            r: self.mat[0].n as i64,",
        "            f: |i: i64| {",
        "                let cnt = self.rank(x, i as usize);",
        "                cnt >= k + 1",
        "            },",
        "        };",
        "        bs.lower_bound() as usize - 1",
        "    }",
        "    ///k-th largest number in [l,r)",
        "    pub fn quantile(&self, l: usize, r: usize, k: usize) -> u64 {",
        "        let mut res = 0;",
        "        let mut k = k;",
        "        let mut s = l;",
        "        let mut e = r;",
        "        for d in 0..64 {",
        "            let msb = 1 << (63 - d);",
        "            let fid = &self.mat[d];",
        "            let ns = fid.rank1(s);",
        "            let ne = fid.rank1(e);",
        "            let n1 = ne - ns;",
        "            if n1 >= k {",
        "                res |= msb;",
        "                s = ns;",
        "                e = ne;",
        "                s += self.nzeros[d];",
        "                e += self.nzeros[d];",
        "            } else {",
        "                s = s - ns;",
        "                e = e - ne;",
        "                k -= n1;",
        "            }",
        "        }",
        "        res",
        "    }",
        "    fn rank_all(&self, l: usize, r: usize, x: u64) -> (usize, usize, usize) {",
        "        let mut cnt_lt = 0;",
        "        let mut cnt_gt = 0;",
        "        let mut s = l;",
        "        let mut e = r;",
        "        for d in 0..64 {",
        "            let b = x & (1 << (63 - d)) > 0;",
        "            let lcnt = self.mat[d].rank(b, s);",
        "            let rcnt = self.mat[d].rank(b, e);",
        "            let add = (e - s) - (rcnt - lcnt);",
        "            if b {",
        "                cnt_lt += add;",
        "            } else {",
        "                cnt_gt += add;",
        "            }",
        "            s = lcnt;",
        "            e = rcnt;",
        "            if b {",
        "                s += self.nzeros[d];",
        "                e += self.nzeros[d];",
        "            }",
        "        }",
        "        (cnt_lt, e - s, cnt_gt)",
        "    }",
        "    ///counting numbers in range [min,max) in v[l,r). O(1)",
        "    pub fn rangefreq(&self, l: usize, r: usize, min: u64, max: u64) -> usize {",
        "        let (cntlt_max, _, _) = self.rank_all(l, r, max);",
        "        let (cntlt_min, _, _) = self.rank_all(l, r, min);",
        "        cntlt_max - cntlt_min",
        "    }",
        "}",
        "struct WMi64 {",
        "    offset: i64,",
        "    wm: WM,",
        "}",
        "impl WMi64 {",
        "    pub fn new(xs: Vec<i64>) -> WMi64 {",
        "        let offset = 1 << 62;",
        "        let mut ys = vec![];",
        "        for x in xs {",
        "            ys.push((x + offset) as u64)",
        "        }",
        "        let wm = WM::new(ys);",
        "        WMi64 {",
        "            offset: offset,",
        "            wm: wm,",
        "        }",
        "    }",
        "    pub fn rangefreq(&self, l: usize, r: usize, min: i64, max: i64) -> usize {",
        "        self.wm",
        "            .rangefreq(l, r, (min + self.offset) as u64, (max + self.offset) as u64)",
        "    }",
        "    pub fn quantile(&self, l: usize, r: usize, k: usize) -> i64 {",
        "        self.wm.quantile(l, r, k) as i64 - self.offset",
        "    }",
        "    pub fn rank(&self, x: i64, i: usize) -> usize {",
        "        self.wm.rank((x + self.offset) as u64, i)",
        "    }",
        "    pub fn select(&self, x: i64, k: usize) -> usize {",
        "        self.wm.select((x + self.offset) as u64, k)",
        "    }",
        "}"
      ]
    },
    "WeighedUnionFind": {
      "prefix": "WeighedUnionFind",
      "body": [
        "struct WeightedUnionFind {",
        "    par: Vec<usize>,",
        "    rank: Vec<usize>,",
        "    diff_weight: Vec<i32>,",
        "}",
        "impl WeightedUnionFind {",
        "    fn new(n: usize) -> WeightedUnionFind {",
        "        WeightedUnionFind {",
        "            par: (0..n).collect::<Vec<usize>>(),",
        "            rank: vec![0; n],",
        "            diff_weight: vec![0; n],",
        "        }",
        "    }",
        "    fn root(&mut self, x: usize) -> usize {",
        "        if self.par[x] == x {",
        "            return x;",
        "        } else {",
        "            let y = self.par[x];",
        "            let z = self.root(y);",
        "            self.diff_weight[x] += self.diff_weight[y];",
        "            self.par[x] = z;",
        "            return z;",
        "        }",
        "    }",
        "    fn weight(&mut self, x: usize) -> i32 {",
        "        self.root(x);",
        "        self.diff_weight[x]",
        "    }",
        "    fn same(&mut self, x: usize, y: usize) -> bool {",
        "        self.root(x) == self.root(y)",
        "    }",
        "    fn merge(&mut self, x: usize, y: usize, w: i32) -> bool {",
        "        let mut w = w;",
        "        w += self.weight(x);",
        "        w -= self.weight(y);",
        "        let mut a = self.root(x);",
        "        let mut b = self.root(y);",
        "        if a == b {",
        "            return false;",
        "        }",
        "        if self.rank[a] < self.rank[b] {",
        "            std::mem::swap(&mut a, &mut b);",
        "            w = -w;",
        "        }",
        "        assert!(self.rank[a] >= self.rank[b]);",
        "        if self.rank[a] == self.rank[b] {",
        "            self.rank[a] += 1;",
        "        }",
        "        self.par[b] = a;",
        "        self.diff_weight[b] = w;",
        "        return true;",
        "    }",
        "}"
      ]
    },
    "XorShift": {
      "prefix": "XorShift",
      "body": [
        "#[derive(Debug, Clone)]",
        "#[allow(dead_code)]",
        "pub struct Xorshift {",
        "    seed: u64,",
        "}",
        "impl Xorshift {",
        "    #[allow(dead_code)]",
        "    pub fn new() -> Xorshift {",
        "        Xorshift {",
        "            seed: 0xf0fb588ca2196dac,",
        "        }",
        "    }",
        "    #[allow(dead_code)]",
        "    pub fn with_seed(seed: u64) -> Xorshift {",
        "        Xorshift { seed: seed }",
        "    }",
        "    #[inline(always)]",
        "    #[allow(dead_code)]",
        "    pub fn next(&mut self) -> u64 {",
        "        self.seed = self.seed ^ (self.seed << 13);",
        "        self.seed = self.seed ^ (self.seed >> 7);",
        "        self.seed = self.seed ^ (self.seed << 17);",
        "        self.seed",
        "    }",
        "    #[inline(always)]",
        "    #[allow(dead_code)]",
        "    pub fn rand(&mut self, m: u64) -> u64 {",
        "        self.next() % m",
        "    }",
        "    #[inline(always)]",
        "    #[allow(dead_code)]",
        "    pub fn randf(&mut self) -> f64 {",
        "        use std::mem;",
        "        const UPPER_MASK: u64 = 0x3FF0000000000000;",
        "        const LOWER_MASK: u64 = 0xFFFFFFFFFFFFF;",
        "        let tmp = UPPER_MASK | (self.next() & LOWER_MASK);",
        "        let result: f64 = unsafe { mem::transmute(tmp) };",
        "        result - 1.0",
        "    }",
        "}"
      ]
    },
    "ZenHo": {
      "prefix": "ZenHo",
      "body": [
        "trait ZenHoable: Foldable + Clone + Sized {",
        "    type NVal: Clone;",
        "    type EVal: Clone;",
        "    /// rerootingした時に新しいDP値を計算するために呼ばれる。",
        "    /// uの下にあったvを持ち上げてu->vの値を計算する場合、",
        "    /// nvalue: uの値",
        "    /// evalue: u->vの値",
        "    fn f(",
        "        &self,",
        "        nvalue: Self::NVal,",
        "        evalue: Self::EVal,",
        "        dp: &CumRL<Self>,",
        "        l: usize,",
        "        r: usize,",
        "    ) -> Self::T;",
        "}",
        "#[derive(Debug)]",
        "struct ZenHo<Z: ZenHoable> {",
        "    z: Z,",
        "    g: Vec<Vec<usize>>,",
        "    nvalues: Vec<Z::NVal>,",
        "    evalues: HashMap<(usize, usize), Z::EVal>,",
        "    dp: HashMap<(usize, usize), Z::T>,",
        "}",
        "impl<Z: ZenHoable> ZenHo<Z> {",
        "    pub fn new(z: Z, nvalues: Vec<Z::NVal>) -> ZenHo<Z> {",
        "        let n = nvalues.len();",
        "        ZenHo {",
        "            z: z,",
        "            g: vec![vec![]; n],",
        "            nvalues: nvalues,",
        "            evalues: HashMap::new(),",
        "            dp: HashMap::new(),",
        "        }",
        "    }",
        "    pub fn n(&self) -> usize {",
        "        self.g.len()",
        "    }",
        "    pub fn add_edge(&mut self, u: usize, v: usize, eval: Z::EVal) {",
        "        self.g[u].push(v);",
        "        self.evalues.insert((u, v), eval);",
        "    }",
        "    fn init_dfs(&mut self, par: Option<usize>, u: usize) {",
        "        for i in 0..self.g[u].len() {",
        "            let v = self.g[u][i];",
        "            if Some(v) == par {",
        "                continue;",
        "            }",
        "            self.init_dfs(Some(u), v);",
        "        }",
        "        if let Some(p) = par {",
        "            let mut dp = vec![];",
        "            for i in 0..self.g[u].len() {",
        "                let v = self.g[u][i];",
        "                if Some(v) == par {",
        "                    continue;",
        "                }",
        "                let dpval = self.dp.get(&(v, u)).cloned().unwrap();",
        "                dp.push(dpval);",
        "            }",
        "            let cumRL: CumRL<Z> = CumRL::new(dp);",
        "            let newv = self.z.f(",
        "                self.nvalues[u].clone(),",
        "                self.evalues.get(&(u, p)).cloned().unwrap(),",
        "                &cumRL,",
        "                cumRL.len(),",
        "                0,",
        "            );",
        "            self.dp.insert((u, p), newv);",
        "        }",
        "    }",
        "    fn reroot_bfs(&mut self, par: Option<usize>, u: usize) {",
        "        let mut dp = vec![];",
        "        for i in 0..self.g[u].len() {",
        "            let v = self.g[u][i];",
        "            let x = self.dp.get(&(v, u)).cloned().unwrap();",
        "            dp.push(x);",
        "        }",
        "        let cum: CumRL<Z> = CumRL::new(dp);",
        "        let n = cum.len();",
        "        for i in 0..self.g[u].len() {",
        "            let v = self.g[u][i];",
        "            let L = i;",
        "            let R = n - 1 - L;",
        "            let newv = self.z.f(",
        "                self.nvalues[u].clone(),",
        "                self.evalues.get(&(u, v)).cloned().unwrap(),",
        "                &cum,",
        "                L,",
        "                R,",
        "            );",
        "            self.dp.insert((u, v), newv);",
        "        }",
        "        for i in 0..self.g[u].len() {",
        "            let v = self.g[u][i];",
        "            if Some(v) == par {",
        "                continue;",
        "            }",
        "            self.reroot_bfs(Some(u), v);",
        "        }",
        "    }",
        "    ///O(n)",
        "    pub fn build(&mut self, root: usize) {",
        "        self.init_dfs(None, root);",
        "        self.reroot_bfs(None, root);",
        "    }",
        "    pub fn calc(&self, u: usize, v: usize) -> Z::T {",
        "        self.dp.get(&(u, v)).cloned().unwrap()",
        "    }",
        "}"
      ]
    },
    "bellman_ford": {
      "prefix": "bellman_ford",
      "body": [
        "/// ベルマンフォード法",
        "///",
        "/// 負辺を許す。",
        "/// ベルマンフォード法のアイデアは、",
        "/// 最悪ケースでも毎ターン1つは最短距離を確定していくということである。",
        "/// 毎回全辺をループして、各頂点の最短距離を更新していく。",
        "/// 全部でVターン繰り返せば収束するはず。",
        "/// 収束しないならば負ループが存在する。",
        "///",
        "/// 計算量 O(VE)",
        "pub mod bellman_ford {",
        "    #[derive(Clone, Copy, Debug)]",
        "    pub struct Edge {",
        "        pub from: usize,",
        "        pub to: usize,",
        "        pub cost: i64,",
        "    }",
        "    pub fn bellman_ford(n: usize, es: &[Edge], source: usize) -> Vec<i64> {",
        "        const INF: i64 = 1 << 60;",
        "        let mut d = vec![INF; n];",
        "        d[source] = 0;",
        "        loop {",
        "            let mut update = false;",
        "            for e in es {",
        "                if d[e.from] != INF && d[e.to] > d[e.from] + e.cost {",
        "                    d[e.to] = d[e.from] + e.cost;",
        "                    update = true;",
        "                }",
        "            }",
        "            if !update {",
        "                break;",
        "            }",
        "        }",
        "        d",
        "    }",
        "    pub fn find_negative_loop(n: usize, es: &[Edge]) -> bool {",
        "        let mut d = vec![0; n];",
        "        for i in 0..n {",
        "            for e in es {",
        "                if d[e.to] > d[e.from] + e.cost {",
        "                    d[e.to] = d[e.from] + e.cost;",
        "                    if i == n - 1 {",
        "                        return true;",
        "                    }",
        "                }",
        "            }",
        "        }",
        "        false",
        "    }",
        "}"
      ]
    },
    "bfs01": {
      "prefix": "bfs01",
      "body": [
        "/// 入力NxNの隣接行列",
        "/// 距離は1かinfのみ",
        "/// g[i][i] = infにする",
        "pub fn bfs01(g: &[Vec<i64>], s: usize, inf: i64) -> Vec<i64> {",
        "    use std::collections::VecDeque;",
        "    let n = g.len();",
        "    let mut dp = vec![inf; n];",
        "    let mut deque = VecDeque::new();",
        "    dp[s] = 0;",
        "    deque.push_back(s);",
        "    while !deque.is_empty() {",
        "        let i = deque.pop_front().unwrap();",
        "        let cur_min_cost = dp[i];",
        "        for j in 0..n {",
        "            if g[i][j] < inf {",
        "                if g[i][j] == 1 {",
        "                    let new_cost = cur_min_cost + 1;",
        "                    if new_cost < dp[j] {",
        "                        dp[j] = new_cost;",
        "                        deque.push_back(j);",
        "                    }",
        "                } else {",
        "                    let new_cost = cur_min_cost;",
        "                    if new_cost < dp[j] {",
        "                        dp[j] = new_cost;",
        "                        deque.push_front(j);",
        "                    }",
        "                }",
        "            }",
        "        }",
        "    }",
        "    dp",
        "}"
      ]
    },
    "bit_positions": {
      "prefix": "bit_positions",
      "body": [
        "/// bitが立っている箇所を計算する",
        "/// 計算量:",
        "/// 構築 O(log x)",
        "fn bit_positions(x: i64) -> Vec<usize> {",
        "    let mut p = vec![];",
        "    let mut cur = x;",
        "    for i in 0.. {",
        "        if x & (1 << i) > 0 {",
        "            p.push(i)",
        "        }",
        "        cur >>= 1;",
        "        if cur == 0 {",
        "            break;",
        "        }",
        "    }",
        "    p",
        "}"
      ]
    },
    "chu_liu_edmonds": {
      "prefix": "chu_liu_edmonds",
      "body": [
        "mod chu_liu_edmonds {",
        "    use crate::graph::scc::SCC;",
        "    #[derive(Debug, Clone, Copy)]",
        "    pub struct Edge(pub usize, pub u64);",
        "    fn min_edge(edges: &[Edge]) -> &Edge {",
        "        let mut r = &edges[0];",
        "        for e in edges {",
        "            if e.1 < r.1 {",
        "                r = e;",
        "            }",
        "        }",
        "        r",
        "    }",
        "    static NULL_EDGE: &'static Edge = &Edge(1 << 40, 0);",
        "    pub fn chu_liu_edmonds(in_g: &[Vec<Edge>], root: usize) -> u64 {",
        "        let n = in_g.len();",
        "        let mut min_in_g: Vec<&Edge> = vec![];",
        "        let mut min_out_g: Vec<Vec<usize>> = vec![vec![]; n];",
        "        for to in 0..n {",
        "            if to == root {",
        "                min_in_g.push(NULL_EDGE);",
        "                continue;",
        "            }",
        "            let e = min_edge(&in_g[to]);",
        "            min_in_g.push(e);",
        "            min_out_g[e.0].push(to);",
        "        }",
        "        let mut scc = SCC::new(n);",
        "        for u in 0..n {",
        "            for i in 0..min_out_g[u].len() {",
        "                let v = min_out_g[u][i];",
        "                scc.add_edge(u, v);",
        "            }",
        "        }",
        "        scc.build();",
        "        let mut max_cmp = 0;",
        "        for &cmp in &scc.order {",
        "            if cmp > max_cmp {",
        "                max_cmp = cmp;",
        "            }",
        "        }",
        "        let no_loop = max_cmp == scc.order.len() - 1;",
        "        if no_loop {",
        "            let mut res = 0;",
        "            for e in &min_in_g {",
        "                res += e.1;",
        "            }",
        "            return res;",
        "        }",
        "        let mut groups = vec![vec![]; max_cmp + 1];",
        "        for v in 0..scc.order.len() {",
        "            let cmp = scc.order[v];",
        "            groups[cmp].push(v);",
        "        }",
        "        let mut contracted_cost = 0;",
        "        let mut new_in_g = vec![vec![]; max_cmp + 1];",
        "        for group in groups {",
        "            if group.len() > 1 {",
        "                let cmp_to = scc.order[group[0]];",
        "                for &v in &group {",
        "                    let cur_e = min_in_g[v];",
        "                    contracted_cost += cur_e.1;",
        "                    for e in &in_g[v] {",
        "                        let in_group = group.contains(&e.0);",
        "                        if !in_group {",
        "                            let cmp_from = scc.order[e.0];",
        "                            let diff_cost = e.1 - cur_e.1;",
        "                            new_in_g[cmp_to].push(Edge(cmp_from, diff_cost));",
        "                        }",
        "                    }",
        "                }",
        "            } else {",
        "                assert!(group.len() == 1);",
        "                let v = group[0];",
        "                for e in &in_g[v] {",
        "                    let cmp_to = scc.order[v];",
        "                    let cmp_from = scc.order[e.0];",
        "                    new_in_g[cmp_to].push(Edge(cmp_from, e.1));",
        "                }",
        "            }",
        "        }",
        "        let new_root = scc.order[root];",
        "        contracted_cost + chu_liu_edmonds(&new_in_g, new_root)",
        "    }",
        "}"
      ]
    },
    "closest_pair": {
      "prefix": "closest_pair",
      "body": [
        "pub fn closest_pair(ps: &[(f64, f64)]) -> ((f64, f64), (f64, f64)) {",
        "    fn d(p1: (f64, f64), p2: (f64, f64)) -> f64 {",
        "        ((p1.0 - p2.0).powi(2) + (p1.1 - p2.1).powi(2)).sqrt()",
        "    }",
        "    fn rec(x_sort: &[(f64, f64)], y_sort: &[(f64, f64)]) -> ((f64, f64), (f64, f64)) {",
        "        if x_sort.len() <= 3 {",
        "            let mut min_d = std::f64::MAX;",
        "            let mut pair = ((0.0, 0.0), (0.0, 0.0));",
        "            for (i, &p1) in x_sort.iter().enumerate() {",
        "                for (j, &p2) in x_sort.iter().enumerate() {",
        "                    if i != j {",
        "                        let dist = d(p1, p2);",
        "                        if dist < min_d {",
        "                            min_d = dist;",
        "                            pair = (p1, p2);",
        "                        }",
        "                    }",
        "                }",
        "            }",
        "            return pair;",
        "        }",
        "        let mid = x_sort.len() / 2;",
        "        let pivot = x_sort[mid].0;",
        "        let q_x = &x_sort[..mid];",
        "        let r_x = &x_sort[mid..];",
        "        let mut q_y = Vec::with_capacity(mid);",
        "        let mut r_y = Vec::with_capacity(x_sort.len() - mid);",
        "        for &(x, y) in y_sort {",
        "            if x < pivot {",
        "                q_y.push((x, y));",
        "            } else {",
        "                r_y.push((x, y));",
        "            }",
        "        }",
        "        let pair1 = rec(q_x, &q_y);",
        "        let pair2 = rec(r_x, &r_y);",
        "        let w = d(pair1.0, pair1.1).min(d(pair2.0, pair2.1));",
        "        let s: Vec<(f64, f64)> = y_sort",
        "            .iter()",
        "            .filter(|&&(x, _)| (pivot - x).abs() <= w)",
        "            .cloned()",
        "            .collect();",
        "        let mut min_d = w;",
        "        let mut pair = if d(pair1.0, pair1.1) < d(pair2.0, pair2.1) {",
        "            pair1",
        "        } else {",
        "            pair2",
        "        };",
        "        for (i, &p1) in s.iter().enumerate() {",
        "            for &p2 in s[i + 1..].iter().take(15) {",
        "                let dist = d(p1, p2);",
        "                if dist < min_d {",
        "                    min_d = dist;",
        "                    pair = (p1, p2);",
        "                }",
        "            }",
        "        }",
        "        pair",
        "    }",
        "    let mut x_sort = ps.to_vec();",
        "    let mut y_sort = ps.to_vec();",
        "    x_sort.sort_by_key(|p| Total(p.0));",
        "    y_sort.sort_by_key(|p| Total(p.1));",
        "    rec(&x_sort, &y_sort)",
        "}"
      ]
    },
    "comb_table": {
      "prefix": "comb_table",
      "body": [
        "///Pascal's triangle. O(N^2)",
        "fn comb_table(n_max: usize) -> Vec<Vec<i64>> {",
        "    let mut dp = vec![vec![0; n_max + 1]; n_max + 1];",
        "    for i in 0..n_max {",
        "        for j in 0..i + 1 {",
        "            if j == 0 || j == i {",
        "                dp[i][j] = 1;",
        "            } else {",
        "                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];",
        "            }",
        "        }",
        "    }",
        "    dp",
        "}"
      ]
    },
    "compare_str": {
      "prefix": "compare_str",
      "body": [
        "///-1: s<t, 0: s=t, 1: s>t",
        "pub fn compare_str(s: &[char], t: &[char]) -> i8 {",
        "    let n = std::cmp::min(s.len(), t.len());",
        "    for i in 0..n {",
        "        if s[i] < t[i] {",
        "            return -1;",
        "        } else if s[i] > t[i] {",
        "            return 1;",
        "        } else {",
        "        }",
        "    }",
        "    if s.len() < t.len() {",
        "        return -1;",
        "    } else if s.len() > t.len() {",
        "        return 1;",
        "    } else {",
        "        return 0;",
        "    }",
        "}"
      ]
    },
    "complex": {
      "prefix": "complex",
      "body": [
        "mod complex {",
        "    #[derive(Clone, Copy, Debug)]",
        "    pub struct Complex {",
        "        pub x: f64,",
        "        pub y: f64,",
        "    }",
        "    impl Complex {",
        "        pub fn new(x: f64, y: f64) -> Self {",
        "            Complex { x: x, y: y }",
        "        }",
        "        pub fn polar(r: f64, theta: f64) -> Self {",
        "            Complex::new(r * theta.cos(), r * theta.sin())",
        "        }",
        "        pub fn conj(&self) -> Self {",
        "            Complex::new(self.x, -self.y)",
        "        }",
        "        pub fn abs(&self) -> f64 {",
        "            (self.x * self.x + self.y * self.y).sqrt()",
        "        }",
        "        pub fn arg(&self) -> f64 {",
        "            self.y.atan2(self.x)",
        "        }",
        "    }",
        "    use std::ops::*;",
        "    impl Add for Complex {",
        "        type Output = Self;",
        "        fn add(self, rhs: Self) -> Self {",
        "            Complex::new(self.x + rhs.x, self.y + rhs.y)",
        "        }",
        "    }",
        "    impl Sub for Complex {",
        "        type Output = Self;",
        "        fn sub(self, rhs: Self) -> Self {",
        "            Complex::new(self.x - rhs.x, self.y - rhs.y)",
        "        }",
        "    }",
        "    impl Mul for Complex {",
        "        type Output = Self;",
        "        fn mul(self, rhs: Self) -> Self {",
        "            Complex::new(",
        "                self.x * rhs.x - self.y * rhs.y,",
        "                self.x * rhs.y + self.y * rhs.x,",
        "            )",
        "        }",
        "    }",
        "    impl Div for Complex {",
        "        type Output = Self;",
        "        fn div(self, rhs: Self) -> Self {",
        "            let z = self * rhs.conj();",
        "            let a = rhs.x * rhs.x + rhs.y * rhs.y;",
        "            Complex::new(z.x / a, z.y / a)",
        "        }",
        "    }",
        "    impl AddAssign for Complex {",
        "        fn add_assign(&mut self, rhs: Self) {",
        "            *self = *self + rhs",
        "        }",
        "    }",
        "    impl SubAssign for Complex {",
        "        fn sub_assign(&mut self, rhs: Self) {",
        "            *self = *self - rhs",
        "        }",
        "    }",
        "    impl MulAssign for Complex {",
        "        fn mul_assign(&mut self, rhs: Self) {",
        "            *self = *self * rhs",
        "        }",
        "    }",
        "    impl DivAssign for Complex {",
        "        fn div_assign(&mut self, rhs: Self) {",
        "            *self = *self / rhs",
        "        }",
        "    }",
        "}",
        "pub type Complex = complex::Complex;"
      ]
    },
    "convex_hull": {
      "prefix": "convex_hull",
      "body": [
        "#[allow(dead_code)]",
        "fn convex_hull(vs: &[Vector2D]) -> Vec<usize> {",
        "    let mut idx: Vec<usize> = (0..vs.len()).collect();",
        "    idx.sort_by_key(|&i| Total((vs[i].0, vs[i].1)));",
        "    let mut res = Vec::new();",
        "    for &i in &idx {",
        "        while res.len() > 1",
        "            && Vector2D::det(",
        "                vs[res[res.len() - 1]] - vs[res[res.len() - 2]],",
        "                vs[i] - vs[res[res.len() - 1]],",
        "            ) <= 0.0",
        "        {",
        "            res.pop();",
        "        }",
        "        res.push(i);",
        "    }",
        "    let t = res.len();",
        "    for &i in idx.iter().rev().skip(1) {",
        "        while res.len() > t",
        "            && (vs[res[res.len() - 1]] - vs[res[res.len() - 2]]).det(vs[i] - vs[res[res.len() - 1]])",
        "                <= 0.0",
        "        {",
        "            res.pop();",
        "        }",
        "        res.push(i);",
        "    }",
        "    res.pop();",
        "    res",
        "}"
      ]
    },
    "ctoi": {
      "prefix": "ctoi",
      "body": [
        "fn ctoi(c: char) -> i64 {",
        "    if 'A' <= c && c <= 'Z' {",
        "        c as i64 - 'A' as i64",
        "    } else if 'a' <= c && c <= 'z' {",
        "        c as i64 - 'a' as i64 + 26",
        "    } else {",
        "        unreachable!(\"wrong character\");",
        "    }",
        "}"
      ]
    },
    "cumsum1": {
      "prefix": "cumsum1",
      "body": [
        "struct CumSum1 {",
        "    base: Vec<i64>,",
        "    dp: Vec<i64>,",
        "}",
        "impl CumSum1 {",
        "    pub fn new(n: usize) -> Self {",
        "        CumSum1 {",
        "            base: vec![0; n],",
        "            dp: vec![],",
        "        }",
        "    }",
        "    pub fn from_vec(a: Vec<i64>) -> Self {",
        "        let n = a.len();",
        "        let mut x = Self::new(n);",
        "        for i in 0..n {",
        "            x.set(i, a[i]);",
        "        }",
        "        x.build();",
        "        x",
        "    }",
        "    pub fn add(&mut self, i: usize, x: i64) {",
        "        self.base[i] += x;",
        "    }",
        "    pub fn set(&mut self, i: usize, x: i64) {",
        "        self.base[i] = x;",
        "    }",
        "    pub fn build(&mut self) {",
        "        let n = self.base.len();",
        "        let mut dp = vec![0; n + 1];",
        "        let mut acc = 0;",
        "        for i in 0..n {",
        "            acc += self.base[i];",
        "            dp[i + 1] = acc;",
        "        }",
        "        self.dp = dp;",
        "    }",
        "    ///[i,j)",
        "    pub fn query(&self, i: usize, j: usize) -> i64 {",
        "        self.dp[j] - self.dp[i]",
        "    }",
        "}"
      ]
    },
    "cumsum2": {
      "prefix": "cumsum2",
      "body": [
        "/// 二次元平面上の累積和",
        "/// dp[i][j]が[0,i)x[0,j)として計算出来ると、",
        "/// 任意の範囲の累積和が計算出来るようになる。",
        "///",
        "/// 計算量:",
        "/// 構築 O(N^2)",
        "/// クエリ O(1)",
        "pub struct CumSum2 {",
        "    base: Vec<Vec<i64>>,",
        "    dp: Vec<Vec<i64>>,",
        "}",
        "impl CumSum2 {",
        "    pub fn new(n: usize, m: usize) -> CumSum2 {",
        "        CumSum2 {",
        "            base: vec![vec![0; m]; n],",
        "            dp: vec![],",
        "        }",
        "    }",
        "    pub fn add(&mut self, i: usize, j: usize, x: i64) {",
        "        self.base[i][j] += x;",
        "    }",
        "    pub fn set(&mut self, i: usize, j: usize, x: i64) {",
        "        self.base[i][j] = x;",
        "    }",
        "    pub fn build(&mut self) {",
        "        let n = self.base.len();",
        "        let m = self.base[0].len();",
        "        let mut dp = vec![vec![0; m + 1]; n + 1];",
        "        for i in 0..n {",
        "            for j in 0..m {",
        "                dp[i + 1][j + 1] = self.base[i][j];",
        "            }",
        "        }",
        "        for i in 1..n + 1 {",
        "            for j in 1..m + 1 {",
        "                dp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];",
        "            }",
        "        }",
        "        self.dp = dp;",
        "    }",
        "    pub fn query(&self, i0: usize, i1: usize, j0: usize, j1: usize) -> i64 {",
        "        self.dp[i1][j1] - (self.dp[i0][j1] + self.dp[i1][j0] - self.dp[i0][j0])",
        "    }",
        "}"
      ]
    },
    "dijkstra": {
      "prefix": "dijkstra",
      "body": [
        "/// キューを使ったダイクストラ法",
        "///",
        "/// グラフをビー玉と柔らかい紐で表現し、始点をつまんでぶら下げる。",
        "/// この時、全ビー玉は垂直落下するが、早く止まったものから確定していく。",
        "/// これがキューから取り出すことに相当。",
        "/// 最後に、全ビー玉が全部停止した時、計算が終了する。",
        "/// という物理現象をシミュレートしている。",
        "///",
        "/// 計算量 O(E logV)",
        "pub mod djikstra_heap {",
        "    #[derive(Clone, Copy, Debug)]",
        "    pub struct Edge {",
        "        pub to: usize,",
        "        pub cost: i64,",
        "    }",
        "    pub fn dijkstra_heap(g: &[Vec<Edge>], s: usize, inf: i64) -> Vec<i64> {",
        "        let n = g.len();",
        "        let mut queue = std::collections::BinaryHeap::new();",
        "        let mut d = vec![inf; n];",
        "        d[s] = 0;",
        "        queue.push((0, s));",
        "        while let Some((cost, v)) = queue.pop() {",
        "            let cost = -cost;",
        "            if d[v] < cost {",
        "                continue;",
        "            }",
        "            for e in &g[v] {",
        "                let new_cost = cost + e.cost;",
        "                if d[e.to] > new_cost {",
        "                    d[e.to] = new_cost;",
        "                    queue.push((-new_cost, e.to));",
        "                }",
        "            }",
        "        }",
        "        d",
        "    }",
        "}"
      ]
    },
    "dinic": {
      "prefix": "dinic",
      "body": [
        "pub mod dinic {",
        "    #[derive(Clone, Copy, Debug)]",
        "    struct Edge {",
        "        to: usize,",
        "        cap: i64,",
        "        rev: usize,",
        "    }",
        "    pub struct Network {",
        "        g: Vec<Vec<Edge>>,",
        "        level: Vec<Option<usize>>,",
        "        iter: Vec<usize>,",
        "    }",
        "    ///direct flow graph. O(EV^2)",
        "    impl Network {",
        "        pub fn new(n: usize) -> Network {",
        "            Network {",
        "                g: vec![vec![]; n],",
        "                level: vec![None; n],",
        "                iter: vec![0; n],",
        "            }",
        "        }",
        "        pub fn add_edge(&mut self, from: usize, to: usize, cap: i64) {",
        "            assert!(cap >= 0);",
        "            let from_rev = self.g[to].len();",
        "            let to_rev = self.g[from].len();",
        "            self.g[from].push(Edge {",
        "                to: to,",
        "                cap: cap,",
        "                rev: from_rev,",
        "            });",
        "            self.g[to].push(Edge {",
        "                to: from,",
        "                cap: 0,",
        "                rev: to_rev,",
        "            });",
        "        }",
        "        fn n(&self) -> usize {",
        "            self.g.len()",
        "        }",
        "        fn bfs(&mut self, s: usize) {",
        "            self.level = vec![None; self.n()];",
        "            let mut q = std::collections::VecDeque::new();",
        "            q.push_back(s);",
        "            self.level[s] = Some(0);",
        "            while let Some(v) = q.pop_front() {",
        "                for e in &self.g[v] {",
        "                    if e.cap > 0 && self.level[e.to].is_none() {",
        "                        self.level[e.to] = self.level[v].map(|x| x + 1);",
        "                        q.push_back(e.to);",
        "                    }",
        "                }",
        "            }",
        "        }",
        "        fn dfs(&mut self, v: usize, t: usize, f: i64) -> i64 {",
        "            if v == t {",
        "                return f;",
        "            }",
        "            let iter_v_cur = self.iter[v];",
        "            for i in iter_v_cur..self.g[v].len() {",
        "                let e = self.g[v][i].clone();",
        "                if e.cap > 0 && self.level[v] < self.level[e.to] {",
        "                    let d = self.dfs(e.to, t, std::cmp::min(f, e.cap));",
        "                    if d > 0 {",
        "                        self.g[v][i].cap -= d;",
        "                        self.g[e.to][e.rev].cap += d;",
        "                        return d;",
        "                    }",
        "                }",
        "                self.iter[v] += 1;",
        "            }",
        "            return 0;",
        "        }",
        "        pub fn max_flow(&mut self, s: usize, t: usize) -> i64 {",
        "            let mut flow = 0;",
        "            loop {",
        "                self.bfs(s);",
        "                if self.level[t].is_none() {",
        "                    return flow;",
        "                }",
        "                let INF = 2_000_000_001;",
        "                self.iter = vec![0; self.n()];",
        "                let mut f = self.dfs(s, t, INF);",
        "                while f > 0 {",
        "                    flow += f;",
        "                    f = self.dfs(s, t, INF);",
        "                }",
        "            }",
        "        }",
        "    }",
        "}"
      ]
    },
    "divisors": {
      "prefix": "divisors",
      "body": [
        "///O(root N)",
        "fn divisors(n: i64) -> Vec<i64> {",
        "    let mut res = vec![];",
        "    let mut d = 1;",
        "    while d * d <= n {",
        "        if n % d == 0 {",
        "            res.push(d);",
        "            if d * d != n {",
        "                res.push(n / d);",
        "            }",
        "        }",
        "        d += 1;",
        "    }",
        "    res",
        "}"
      ]
    },
    "edit_distance": {
      "prefix": "edit_distance",
      "body": [
        "pub fn edit_distance<T: Eq>(s: Vec<T>, t: Vec<T>) -> Vec<Vec<usize>> {",
        "    let n = s.len();",
        "    let m = t.len();",
        "    let mut dp = vec![vec![1 << 30; m + 1]; n + 1];",
        "    for i in 0..=n {",
        "        dp[i][0] = i;",
        "    }",
        "    for j in 0..=m {",
        "        dp[0][j] = j;",
        "    }",
        "    for i in 0..n {",
        "        for j in 0..m {",
        "            let change = if s[i] == t[j] { dp[i][j] } else { dp[i][j] + 1 };",
        "            let delete = dp[i][j + 1] + 1;",
        "            let insert = dp[i + 1][j] + 1;",
        "            dp[i + 1][j + 1] = min(change, min(delete, insert));",
        "        }",
        "    }",
        "    dp",
        "}"
      ]
    },
    "eratosthenes": {
      "prefix": "eratosthenes",
      "body": [
        "///O(N log log N)",
        "fn eratosthenes(n_max: usize) -> Vec<usize> {",
        "    let mut res = vec![];",
        "    let mut v = vec![0; n_max + 1];",
        "    for i in 2..n_max + 1 {",
        "        if v[i] == 0 {",
        "            res.push(i);",
        "            let mut j = i;",
        "            while j <= n_max {",
        "                v[j] = i;",
        "                j += i;",
        "            }",
        "        }",
        "    }",
        "    res",
        "}"
      ]
    },
    "euler_phi_table": {
      "prefix": "euler_phi_table",
      "body": [
        "/// オイラーのφ関数",
        "/// n以下の数でnと素なもの（1を含む）の数を求める",
        "/// 構築: O(N log log N)",
        "pub fn euler_phi_table(max_n: usize) -> Vec<usize> {",
        "    let mut euler = vec![0; max_n + 1];",
        "    for i in 0..=max_n {",
        "        euler[i] = i;",
        "    }",
        "    for i in 2..max_n {",
        "        if euler[i] == i {",
        "            let mut j = i;",
        "            while j <= max_n {",
        "                euler[j] = euler[j] / i * (i - 1);",
        "                j += i;",
        "            }",
        "        }",
        "    }",
        "    euler",
        "}"
      ]
    },
    "extgcd": {
      "prefix": "extgcd",
      "body": [
        "///ax+by=gcd(a,b) returns (gcd, x, y)",
        "#[allow(dead_code)]",
        "pub fn extgcd(a: i64, b: i64) -> (i64, i64, i64) {",
        "    if b == 0 {",
        "        (a, 1, 0)",
        "    } else {",
        "        let (gcd, x, y) = extgcd(b, a % b);",
        "        (gcd, y, x - (a / b) * y)",
        "    }",
        "}"
      ]
    },
    "factor_table": {
      "prefix": "factor_table",
      "body": [
        "///compute the maximum factor for each number. O(N log log N)",
        "#[allow(dead_code)]",
        "pub fn factor_table(max_n: usize) -> Vec<usize> {",
        "    let mut res = vec![0; max_n + 1];",
        "    for i in 2..max_n + 1 {",
        "        if res[i] == 0 {",
        "            let mut j = i;",
        "            while j <= max_n {",
        "                res[j] = i;",
        "                j += i;",
        "            }",
        "        }",
        "    }",
        "    res",
        "}"
      ]
    },
    "factorial": {
      "prefix": "factorial",
      "body": [
        "fn factorial(a: i64, p: i64) -> i64 {",
        "    if a == 0 {",
        "        return 1;",
        "    }",
        "    let mut n = 1;",
        "    let mut a = a;",
        "    while a > 1 {",
        "        n *= a;",
        "        n %= p;",
        "        a -= 1;",
        "    }",
        "    n",
        "}"
      ]
    },
    "factorial_prime_count": {
      "prefix": "factorial_prime_count",
      "body": [
        "///O(n). how many prime p found in n!",
        "fn factorial_prime_count(n: i64, p: i64, mo: i64) -> i64 {",
        "    let mut acc = 0;",
        "    for k in 1.. {",
        "        let mut d = 1;",
        "        for _ in 0..k {",
        "            d *= p;",
        "        }",
        "        if d > n {",
        "            break;",
        "        }",
        "        acc += n / d;",
        "        acc %= mo;",
        "    }",
        "    acc",
        "}"
      ]
    },
    "fft": {
      "prefix": "fft",
      "body": [
        "pub fn multiply(a: &[i64], b: &[i64]) -> Vec<i64> {",
        "    let n = a.len();",
        "    let m = b.len();",
        "    let mut fa = vec![];",
        "    let mut fb = vec![];",
        "    for i in 0..n {",
        "        fa.push(a[i] as f64)",
        "    }",
        "    for i in 0..m {",
        "        fb.push(b[i] as f64)",
        "    }",
        "    let fc = convolve(fa, fb);",
        "    let mut c = vec![];",
        "    for x in fc {",
        "        let v = (x + 0.5) as i64;",
        "        c.push(v);",
        "    }",
        "    c",
        "}",
        "fn convolve(a: Vec<f64>, b: Vec<f64>) -> Vec<f64> {",
        "    let n = a.len() + b.len() - 1;",
        "    let mut m = 1;",
        "    while m < n {",
        "        m *= 2;",
        "    }",
        "    let mut x = vec![Complex::new(0., 0.); m];",
        "    for i in 0..a.len() {",
        "        x[i] = Complex::new(a[i], 0.);",
        "    }",
        "    let mut y = vec![Complex::new(0., 0.); m];",
        "    for i in 0..b.len() {",
        "        y[i] = Complex::new(b[i], 0.);",
        "    }",
        "    let X = fast_fourier_transform(x, false);",
        "    let Y = fast_fourier_transform(y, false);",
        "    let mut Z = vec![Complex::new(0., 0.); m];",
        "    for i in 0..m {",
        "        Z[i] = X[i] * Y[i];",
        "    }",
        "    let z = fast_fourier_transform(Z, true);",
        "    let mut ret = vec![0.; m];",
        "    for i in 0..m {",
        "        ret[i] = z[i].x;",
        "    }",
        "    ret",
        "}",
        "fn fast_fourier_transform(arr: Vec<Complex>, inv: bool) -> Vec<Complex> {",
        "    let n = arr.len();",
        "    assert!(n.count_ones() == 1, \"the length of array is not square\");",
        "    let mut a: Vec<_> = arr.to_vec();",
        "    let mut tmp: Vec<_> = (0..n).map(|_| Complex::new(0., 0.)).collect();",
        "    let mut ai: Vec<_> = (0..n).map(|i| i).collect();",
        "    let mut ti: Vec<_> = (0..n).map(|_| 0).collect();",
        "    let bit = n.trailing_zeros();",
        "    let f = if inv { -1.0 } else { 1.0 };",
        "    for si in (0..bit).rev() {",
        "        let s = 1 << si;",
        "        std::mem::swap(&mut a, &mut tmp);",
        "        std::mem::swap(&mut ai, &mut ti);",
        "        let zeta = Complex::polar(1.0, std::f64::consts::PI * 2.0 * f / (s << 1) as f64);",
        "        let mut z_i = Complex::new(1.0, 0.0);",
        "        let mut ev = 0;",
        "        let mut od = 1;",
        "        for i in 0..n {",
        "            if (i & s) != 0 {",
        "                a[i] = (tmp[i - s] - tmp[i]) * z_i;",
        "                ai[i] = ti[od];",
        "                od += 2;",
        "                z_i *= zeta;",
        "            } else {",
        "                a[i] = tmp[i] + tmp[i + s];",
        "                ai[i] = ti[ev];",
        "                ev += 2;",
        "                z_i = Complex::new(1.0, 0.0);",
        "            }",
        "        }",
        "    }",
        "    std::mem::swap(&mut a, &mut tmp);",
        "    let inv_n = if inv { n as f64 } else { 1.0 };",
        "    for i in 0..n {",
        "        a[ai[i]] = Complex::new(tmp[i].x / inv_n, tmp[i].y / inv_n);",
        "    }",
        "    a",
        "}"
      ]
    },
    "ford_fulkerson": {
      "prefix": "ford_fulkerson",
      "body": [
        "mod ford_fulkerson {",
        "    #[derive(Clone, Copy, Debug)]",
        "    struct Edge {",
        "        to: usize,",
        "        cap: i64,",
        "        rev: usize,",
        "    }",
        "    pub struct Network {",
        "        g: Vec<Vec<Edge>>,",
        "        used: Vec<bool>,",
        "    }",
        "    ///directed flow graph. O(FE)",
        "    impl Network {",
        "        pub fn new(n: usize) -> Network {",
        "            Network {",
        "                g: vec![vec![]; n],",
        "                used: vec![false; n],",
        "            }",
        "        }",
        "        fn n(&self) -> usize {",
        "            self.g.len()",
        "        }",
        "        pub fn add_edge(&mut self, from: usize, to: usize, cap: i64) {",
        "            assert!(cap >= 0);",
        "            let from_rev = self.g[to].len();",
        "            let to_rev = self.g[from].len();",
        "            self.g[from].push(Edge {",
        "                to: to,",
        "                cap: cap,",
        "                rev: from_rev,",
        "            });",
        "            self.g[to].push(Edge {",
        "                to: from,",
        "                cap: 0,",
        "                rev: to_rev,",
        "            });",
        "        }",
        "        fn dfs(&mut self, v: usize, t: usize, f: i64) -> i64 {",
        "            if v == t {",
        "                return f;",
        "            }",
        "            self.used[v] = true;",
        "            for i in 0..self.g[v].len() {",
        "                let e = self.g[v][i].clone();",
        "                if !self.used[e.to] && e.cap > 0 {",
        "                    let d = self.dfs(e.to, t, std::cmp::min(f, e.cap));",
        "                    if d > 0 {",
        "                        self.g[v][i].cap -= d;",
        "                        self.g[e.to][e.rev].cap += d;",
        "                        return d;",
        "                    }",
        "                }",
        "            }",
        "            return 0;",
        "        }",
        "        pub fn max_flow(&mut self, s: usize, t: usize) -> i64 {",
        "            let mut flow = 0;",
        "            loop {",
        "                self.used = vec![false; self.n()];",
        "                let f = self.dfs(s, t, 2_000_000_001);",
        "                if f == 0 {",
        "                    return flow;",
        "                }",
        "                flow += f;",
        "            }",
        "        }",
        "    }",
        "}"
      ]
    },
    "garner": {
      "prefix": "garner",
      "body": [
        "pub fn garner(rm: Vec<(i64, i64)>, mo: i64) -> i64 {",
        "    let mut rm = rm;",
        "    rm.push((0, mo));",
        "    let mut coef = vec![1; rm.len()];",
        "    let mut constants = vec![0; rm.len()];",
        "    for i in 0..rm.len() - 1 {",
        "        let v = (rm[i].0 + rm[i].1 - constants[i]) * modinv(coef[i], rm[i].1) % rm[i].1;",
        "        for j in i + 1..rm.len() {",
        "            constants[j] += coef[j] * v;",
        "            constants[j] %= rm[j].1;",
        "            coef[j] *= rm[i].1;",
        "            coef[j] %= rm[j].1;",
        "        }",
        "    }",
        "    constants[rm.len() - 1]",
        "}",
        "/// 入力の整形用関数。",
        "/// miを素にする。",
        "/// 不可能な場合はfalseを返す。",
        "pub fn pre_garner(rm: &mut Vec<(i64, i64)>) -> bool {",
        "    let n = rm.len();",
        "    for i in 0..n {",
        "        for j in 0..i {",
        "            let g = gcd(rm[i].1, rm[j].1);",
        "            if (rm[i].0 - rm[j].0) % g != 0 {",
        "                return false;",
        "            }",
        "            rm[i].1 /= g;",
        "            rm[j].1 /= g;",
        "            let mut gi = gcd(rm[i].1, g);",
        "            let mut gj = g / gi;",
        "            loop {",
        "                let g = gcd(gi, gj);",
        "                gi *= g;",
        "                gj /= g;",
        "                if g == 1 {",
        "                    break;",
        "                }",
        "            }",
        "            rm[i].1 *= gi;",
        "            rm[j].1 *= gj;",
        "            rm[i].0 %= rm[i].1;",
        "            rm[j].0 %= rm[j].1;",
        "        }",
        "    }",
        "    true",
        "}"
      ]
    },
    "gcd": {
      "prefix": "gcd",
      "body": [
        "#[allow(dead_code)]",
        "pub fn gcd(a: i64, b: i64) -> i64 {",
        "    if b == 0 {",
        "        a",
        "    } else {",
        "        gcd(b, a % b)",
        "    }",
        "}"
      ]
    },
    "group_by_relevance": {
      "prefix": "group_by_relevance",
      "body": [
        "pub fn group_by_relevance<T, F: Fn(&T, &T) -> bool>(xs: Vec<T>, f: F) -> Vec<Vec<T>> {",
        "    let mut res = vec![];",
        "    if xs.len() == 1 {",
        "        res.push(xs);",
        "        return res;",
        "    }",
        "    let mut xs = xs;",
        "    let n = xs.len();",
        "    let mut l = 0;",
        "    let mut sep = vec![];",
        "    for i in 0..n - 1 {",
        "        if !f(&xs[i], &xs[i + 1]) {",
        "            sep.push(i + 1 - l);",
        "            l = i + 1;",
        "        }",
        "    }",
        "    sep.push(n - l);",
        "    xs.reverse();",
        "    for len in sep {",
        "        let mut cur = vec![];",
        "        for _ in 0..len {",
        "            cur.push(xs.pop().unwrap());",
        "        }",
        "        res.push(cur);",
        "    }",
        "    res",
        "}"
      ]
    },
    "grundy_def": {
      "prefix": "grundy_def",
      "body": [
        "pub fn grundy_def(xs: Vec<i64>) -> i64 {",
        "    let mut xs = xs;",
        "    xs.sort();",
        "    let mut n = xs.len();",
        "    for i in 0..n {",
        "        if i as i64 != xs[i] {",
        "            return i as i64;",
        "        }",
        "    }",
        "    n as i64",
        "}"
      ]
    },
    "into_digits": {
      "prefix": "into_digits",
      "body": [
        "pub fn into_digits(b: i64, n: i64) -> Vec<i64> {",
        "    let mut r = vec![];",
        "    let mut n = n;",
        "    while n > 0 {",
        "        let v = n % b;",
        "        r.push(v);",
        "        n -= v;",
        "        n /= b;",
        "    }",
        "    r",
        "}"
      ]
    },
    "inversion": {
      "prefix": "inversion",
      "body": [
        "///O(NlogN)",
        "pub fn inversion(xs: &[usize]) -> Vec<usize> {",
        "    let mut max_v = 0;",
        "    for &x in xs {",
        "        max_v = max(max_v, x);",
        "    }",
        "    let mut res = vec![];",
        "    let mut bit = BIT::new(max_v + 1);",
        "    for i in 0..xs.len() {",
        "        let x = xs[i];",
        "        let cnt = bit.sum(x);",
        "        res.push(i - cnt);",
        "        bit.add(x, 1);",
        "    }",
        "    res",
        "}"
      ]
    },
    "is_prime": {
      "prefix": "is_prime",
      "body": [
        "///O(root N)",
        "fn is_prime(n: i64) -> bool {",
        "    let mut d = 1;",
        "    while d * d <= n {",
        "        d += 1;",
        "    }",
        "    let mut res = true;",
        "    for i in 2..d {",
        "        if n % i == 0 {",
        "            res = false;",
        "            break;",
        "        }",
        "    }",
        "    res",
        "}"
      ]
    },
    "is_subsequence": {
      "prefix": "is_subsequence",
      "body": [
        "///naive implementation. O(nm)",
        "pub fn is_subsequence(s: &[char], t: &[char]) -> bool {",
        "    let n = s.len();",
        "    let m = t.len();",
        "    let mut j = 0;",
        "    let mut ok = false;",
        "    for i in 0..n {",
        "        let c = s[i];",
        "        while j < m {",
        "            let found = t[j] == s[i];",
        "            j += 1;",
        "            if found {",
        "                if i == n - 1 {",
        "                    ok = true;",
        "                }",
        "                break;",
        "            }",
        "        }",
        "    }",
        "    ok",
        "}"
      ]
    },
    "itoc": {
      "prefix": "itoc",
      "body": [
        "fn itoc(c: i64) -> char {",
        "    if 0 <= c && c < 26 {",
        "        (c as u8 + 'A' as u8) as char",
        "    } else if c < 52 {",
        "        (c as u8 - 26 + 'a' as u8) as char",
        "    } else {",
        "        unreachable!(\"wrong character\");",
        "    }",
        "}"
      ]
    },
    "karatsuba": {
      "prefix": "karatsuba",
      "body": [
        "fn karatsuba<T>(a: &[T], b: &[T], c: &mut [T])",
        "where",
        "    T: std::marker::Copy",
        "        + std::ops::Add<Output = T>",
        "        + std::ops::Sub<Output = T>",
        "        + std::ops::Mul<Output = T>",
        "        + std::default::Default,",
        "{",
        "    let n = a.len();",
        "    if n <= 32 {",
        "        for (i, a) in a.iter().enumerate() {",
        "            for (c, b) in c[i..].iter_mut().zip(b.iter()) {",
        "                *c = *c + *a * *b;",
        "            }",
        "        }",
        "        return;",
        "    }",
        "    if n & 1 == 1 {",
        "        karatsuba(&a[1..], &b[1..], &mut c[2..]);",
        "        let x = a[0];",
        "        let y = b[0];",
        "        c[0] = c[0] + x * y;",
        "        for (c, (a, b)) in c[1..].iter_mut().zip(a[1..].iter().zip(b[1..].iter())) {",
        "            *c = *c + x * *b + *a * y;",
        "        }",
        "        return;",
        "    }",
        "    let m = n / 2;",
        "    karatsuba(&a[..m], &b[..m], &mut c[..n]);",
        "    karatsuba(&a[m..], &b[m..], &mut c[n..]);",
        "    let mut buf = vec![T::default(); 2 * n];",
        "    let (x, y) = buf.split_at_mut(m);",
        "    let (y, z) = y.split_at_mut(m);",
        "    for (x, (p, q)) in x.iter_mut().zip(a.iter().zip(a[m..].iter())) {",
        "        *x = *p + *q;",
        "    }",
        "    for (y, (p, q)) in y.iter_mut().zip(b.iter().zip(b[m..].iter())) {",
        "        *y = *p + *q;",
        "    }",
        "    karatsuba(x, y, z);",
        "    for (z, (p, q)) in z.iter_mut().zip(c[..n].iter().zip(c[n..].iter())) {",
        "        *z = *z - (*p + *q);",
        "    }",
        "    for (c, z) in c[m..].iter_mut().zip(z.iter()) {",
        "        *c = *c + *z;",
        "    }",
        "}",
        "pub fn multiply<T>(a: &[T], b: &[T]) -> Vec<T>",
        "where",
        "    T: std::marker::Copy",
        "        + std::ops::Add<Output = T>",
        "        + std::ops::Sub<Output = T>",
        "        + std::ops::Mul<Output = T>",
        "        + std::default::Default,",
        "{",
        "    let mut i = 0;",
        "    let mut j = 0;",
        "    let mut ans = vec![T::default(); a.len() + b.len()];",
        "    let mut c = Vec::with_capacity(a.len() + b.len());",
        "    while i < a.len() && j < b.len() {",
        "        let x = a.len() - i;",
        "        let y = b.len() - j;",
        "        let z = std::cmp::min(x, y);",
        "        c.clear();",
        "        c.resize(2 * z, T::default());",
        "        karatsuba(&a[i..(i + z)], &b[j..(j + z)], &mut c);",
        "        for (ans, c) in ans[(i + j)..].iter_mut().zip(c.iter()) {",
        "            *ans = *ans + *c;",
        "        }",
        "        if x <= y {",
        "            j += x;",
        "        } else {",
        "            i += y;",
        "        }",
        "    }",
        "    ans.truncate(a.len() + b.len() - 1);",
        "    ans",
        "}"
      ]
    },
    "kraskal": {
      "prefix": "kraskal",
      "body": [
        "/// クラスカル法",
        "///",
        "/// 辺をコスト昇順に並べ、前から辿っていく。",
        "/// 辺u-vについて、uとvがまだ連結でない場合に",
        "/// uとvを木に加えていく。",
        "/// こうしていくと、最小全域木が出来上がる。",
        "///",
        "/// 計算量:",
        "/// O(E logV)",
        "mod kraskal {",
        "    use crate::union_find::UnionFind;",
        "    #[derive(Clone, Copy, Debug)]",
        "    pub struct Edge {",
        "        pub u: usize,",
        "        pub v: usize,",
        "        pub cost: i64,",
        "    }",
        "    ///es: undirected edges. O(ElogV)",
        "    pub fn kraskal(n: usize, es: Vec<Edge>) -> (Vec<Edge>, Vec<Edge>) {",
        "        let mut used = vec![];",
        "        let mut unused = vec![];",
        "        let mut es = es;",
        "        es.sort_by_key(|x| x.cost);",
        "        let mut uf = UnionFind::new(n);",
        "        for e in es {",
        "            if !uf.same(e.u, e.v) {",
        "                uf.merge(e.u, e.v);",
        "                used.push(e);",
        "            } else {",
        "                unused.push(e);",
        "            }",
        "        }",
        "        (used, unused)",
        "    }",
        "}"
      ]
    },
    "lcm": {
      "prefix": "lcm",
      "body": [
        "#[allow(dead_code)]",
        "pub fn lcm(a: i64, b: i64) -> i64 {",
        "    a / gcd(a, b) * b",
        "}"
      ]
    },
    "lis": {
      "prefix": "lis",
      "body": [
        "///O(NlogN)",
        "pub fn lis<T: Ord + Clone>(xs: &[T], inf: T) -> Vec<T> {",
        "    let n = xs.len();",
        "    let mut dp = vec![inf.clone(); n];",
        "    for x in xs {",
        "        let i = dp.lower_bound(&x);",
        "        dp[i] = min(dp[i].clone(), x.clone());",
        "    }",
        "    let mut l = 0;",
        "    for i in 0..n {",
        "        if dp[i] < inf {",
        "            l += 1;",
        "        }",
        "    }",
        "    dp.truncate(l);",
        "    return dp;",
        "}"
      ]
    },
    "lower_bound": {
      "prefix": "lower_bound",
      "body": [
        "/// Equivalent to std::lowerbound and std::upperbound in c++",
        "pub trait LowerBound<T> {",
        "    fn lower_bound(&self, x: &T) -> usize;",
        "    fn upper_bound(&self, x: &T) -> usize;",
        "}",
        "impl<T: Ord> LowerBound<T> for [T] {",
        "    fn lower_bound(&self, x: &T) -> usize {",
        "        let mut low = 0;",
        "        let mut high = self.len();",
        "        while low != high {",
        "            let mid = (low + high) / 2;",
        "            match self[mid].cmp(x) {",
        "                Ordering::Less => {",
        "                    low = mid + 1;",
        "                }",
        "                Ordering::Equal | Ordering::Greater => {",
        "                    high = mid;",
        "                }",
        "            }",
        "        }",
        "        low",
        "    }",
        "    fn upper_bound(&self, x: &T) -> usize {",
        "        let mut low = 0;",
        "        let mut high = self.len();",
        "        while low != high {",
        "            let mid = (low + high) / 2;",
        "            match self[mid].cmp(x) {",
        "                Ordering::Less | Ordering::Equal => {",
        "                    low = mid + 1;",
        "                }",
        "                Ordering::Greater => {",
        "                    high = mid;",
        "                }",
        "            }",
        "        }",
        "        low",
        "    }",
        "}"
      ]
    },
    "modint": {
      "prefix": "modint",
      "body": [
        "/// モジュラ逆元",
        "///",
        "/// ax = 1",
        "/// を満たすxをaの逆元という。",
        "///",
        "/// aとpが素の場合、",
        "/// フェルマーの小定理より",
        "/// a^(p-1) = 1 (mod p)",
        "/// だから、",
        "/// a a^(p-2) = 1 (mod p)",
        "/// がいえる。",
        "/// これよりa^(p-2)はaの逆元であることがいえる。",
        "pub mod modular {",
        "    const M: i64 = 1_000_000_007;",
        "    #[derive(Debug, Clone, Copy, Default, PartialOrd, Ord, PartialEq, Eq)]",
        "    pub struct Mod(pub i64);",
        "    impl ::std::fmt::Display for Mod {",
        "        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {",
        "            write!(f, \"{}\", self.0)",
        "        }",
        "    }",
        "    impl Mod {",
        "        pub fn new(v: i64) -> Mod {",
        "            Mod((v + M) % M)",
        "        }",
        "        pub fn pow(self, mut r: i64) -> Mod {",
        "            let mut k = self;",
        "            let mut ret = 1.into();",
        "            while r > 0 {",
        "                if r % 2 != 0 {",
        "                    ret = ret * k;",
        "                }",
        "                r /= 2;",
        "                k = k * k;",
        "            }",
        "            ret",
        "        }",
        "        pub fn recip(self) -> Mod {",
        "            self.pow(M - 2)",
        "        }",
        "    }",
        "    use std::ops::*;",
        "    impl<T: Into<Mod>> Add<T> for Mod {",
        "        type Output = Mod;",
        "        fn add(self, rhs: T) -> Self::Output {",
        "            Mod::new(self.0 + rhs.into().0)",
        "        }",
        "    }",
        "    impl<T: Into<Mod>> AddAssign<T> for Mod {",
        "        fn add_assign(&mut self, rhs: T) {",
        "            *self = *self + rhs;",
        "        }",
        "    }",
        "    impl<T: Into<Mod>> Sub<T> for Mod {",
        "        type Output = Mod;",
        "        fn sub(self, rhs: T) -> Self::Output {",
        "            Mod::new(self.0 - rhs.into().0 + M)",
        "        }",
        "    }",
        "    impl<T: Into<Mod>> SubAssign<T> for Mod {",
        "        fn sub_assign(&mut self, rhs: T) {",
        "            *self = *self - rhs;",
        "        }",
        "    }",
        "    impl<T: Into<Mod>> Mul<T> for Mod {",
        "        type Output = Mod;",
        "        fn mul(self, rhs: T) -> Self::Output {",
        "            Mod::new(self.0 * rhs.into().0)",
        "        }",
        "    }",
        "    impl<T: Into<Mod>> MulAssign<T> for Mod {",
        "        fn mul_assign(&mut self, rhs: T) {",
        "            *self = *self * rhs;",
        "        }",
        "    }",
        "    impl<T: Into<Mod>> Div<T> for Mod {",
        "        type Output = Mod;",
        "        fn div(self, rhs: T) -> Self::Output {",
        "            self * rhs.into().recip()",
        "        }",
        "    }",
        "    impl<T: Into<Mod>> DivAssign<T> for Mod {",
        "        fn div_assign(&mut self, rhs: T) {",
        "            *self = *self / rhs;",
        "        }",
        "    }",
        "    impl Neg for Mod {",
        "        type Output = Mod;",
        "        fn neg(self) -> Self::Output {",
        "            Mod(0) - self",
        "        }",
        "    }",
        "    impl<T: ::std::convert::Into<i64>> ::std::convert::From<T> for Mod {",
        "        fn from(v: T) -> Self {",
        "            Mod::new(v.into())",
        "        }",
        "    }",
        "}",
        "pub type Mod = modular::Mod;"
      ]
    },
    "modinv": {
      "prefix": "modinv",
      "body": [
        "///ay=1 (mod m) -> y=a^{-1}",
        "pub fn modinv(a: i64, m: i64) -> i64 {",
        "    let (_, x, _) = extgcd(a, m);",
        "    (m + x % m) % m",
        "}"
      ]
    },
    "modpow": {
      "prefix": "modpow",
      "body": [
        "#[allow(dead_code)]",
        "/// x ^ n % m",
        "pub fn modpow(x: i64, n: i64, m: i64) -> i64 {",
        "    let mut res = 1;",
        "    let mut x = x % m;",
        "    let mut n = n;",
        "    while n > 0 {",
        "        if n & 1 == 1 {",
        "            res = (res * x) % m;",
        "        }",
        "        x = (x * x) % m;",
        "        n >>= 1;",
        "    }",
        "    res",
        "}"
      ]
    },
    "nCk": {
      "prefix": "nCk",
      "body": [
        "///O(b)",
        "fn nCk(a: i64, b: i64) -> Mod {",
        "    if a < b {",
        "        return 0.into();",
        "    }",
        "    let mut a: Mod = a.into();",
        "    let mut r: Mod = 1.into();",
        "    for d in 1..(b + 1) {",
        "        r *= a;",
        "        a -= 1;",
        "        r /= d;",
        "    }",
        "    r",
        "}"
      ]
    },
    "neighbour_table": {
      "prefix": "neighbour_table",
      "body": [
        "pub fn neighbour_table(xs: &[usize]) -> (Vec<Option<usize>>, Vec<Option<usize>>) {",
        "    let n = xs.len();",
        "    let mut m = 0;",
        "    for i in 0..n {",
        "        m = max(m, xs[i]);",
        "    }",
        "    m += 1;",
        "    let mut next = vec![None; m];",
        "    let mut cur = 0;",
        "    for i in 0..n {",
        "        let x = xs[i];",
        "        next[cur] = Some(x);",
        "        cur = x;",
        "    }",
        "    let mut prev = vec![None; m];",
        "    let mut cur = m - 1;",
        "    for i in (0..n).rev() {",
        "        let x = xs[i];",
        "        prev[cur] = Some(x);",
        "        cur = x;",
        "    }",
        "    (prev, next)",
        "}"
      ]
    },
    "partition_dp": {
      "prefix": "partition_dp",
      "body": [
        "///O(nm)",
        "#[allow(dead_code)]",
        "/// dp[i][j] = j th partition number of i",
        "pub fn partition_dp(n: usize, m: usize, p: i64) -> Vec<Vec<i64>> {",
        "    let mut dp = vec![vec![0; m + 1]; n + 1];",
        "    for i in 0..m + 1 {",
        "        dp[0][i] = 1;",
        "    }",
        "    for i in 1..n + 1 {",
        "        for j in 1..m + 1 {",
        "            if i >= j {",
        "                dp[i][j] = (dp[i - j][j] + dp[i][j - 1]) % p;",
        "            } else {",
        "                dp[i][j] = dp[i][j - 1];",
        "            }",
        "        }",
        "    }",
        "    dp",
        "}"
      ]
    },
    "prefix_decomposition": {
      "prefix": "prefix_decomposition",
      "body": [
        "pub fn prefix_decomposition(b: i64, n: i64) -> Vec<(Vec<i64>, Vec<i64>)> {",
        "    if n == 0 {",
        "        return vec![(vec![0], vec![0])];",
        "    }",
        "    let mut x = into_digits(b, n);",
        "    let m = x.len();",
        "    let mut p = vec![];",
        "    for i in 0..x.len() {",
        "        if x[i] > 0 {",
        "            p.push(i);",
        "        }",
        "    }",
        "    let pow = PowTable::new(b, x.len(), std::i64::MAX);",
        "    let from_digits = |x: &[i64]| {",
        "        let m = x.len();",
        "        let mut sum = 0;",
        "        for i in 0..m {",
        "            sum += pow.pow(i) * x[i];",
        "        }",
        "        sum",
        "    };",
        "    let mut r = into_digits(b, n);",
        "    let mut res = vec![(r.clone(), r.clone())];",
        "    for i in p {",
        "        x[i] = 0;",
        "        let numy = from_digits(&r) - 1;",
        "        let mut y = into_digits(b, numy);",
        "        for _ in y.len()..m {",
        "            y.push(0);",
        "        }",
        "        res.push((x.clone(), y));",
        "        r = x.clone();",
        "    }",
        "    res",
        "}"
      ]
    },
    "prim": {
      "prefix": "prim",
      "body": [
        "/// プリム法",
        "///",
        "/// 最小全域木に含まれる頂点集合Vとその他Wに分類し、",
        "/// 毎回、Vに含まれる頂点から、Wに繋がる辺のうちコスト最小のものを選んで、",
        "/// WからVに頂点を移動していく。",
        "///",
        "/// 計算量:",
        "/// O(V^2)",
        "pub mod prim {",
        "    pub fn prim(cost: &[Vec<u64>]) -> u64 {",
        "        let n = cost.len();",
        "        let inf = 1 << 60;",
        "        let mut mincost = vec![inf; n];",
        "        let mut used = vec![false; n];",
        "        mincost[0] = 0;",
        "        let mut total_cost = 0;",
        "        loop {",
        "            let mut v = None;",
        "            for u in 0..n {",
        "                if !used[u] && (v.is_none() || mincost[u] < mincost[v.unwrap()]) {",
        "                    v = Some(u)",
        "                }",
        "            }",
        "            if v.is_none() {",
        "                break;",
        "            }",
        "            let v = v.unwrap();",
        "            used[v] = true;",
        "            total_cost += mincost[v];",
        "            for u in 0..n {",
        "                mincost[u] = std::cmp::min(mincost[u], cost[v][u]);",
        "            }",
        "        }",
        "        total_cost",
        "    }",
        "}"
      ]
    },
    "prime_decomposition": {
      "prefix": "prime_decomposition",
      "body": [
        "///O(root(N))",
        "fn prime_decomposition(n: i64) -> std::collections::HashMap<i64, i64> {",
        "    fn root_int(n: i64) -> i64 {",
        "        let mut d = 1;",
        "        while d * d <= n {",
        "            d += 1;",
        "        }",
        "        d - 1",
        "    }",
        "    let mut n = n;",
        "    let mut m = std::collections::HashMap::new();",
        "    for i in 2..root_int(n) + 1 {",
        "        while n % i == 0 {",
        "            if !m.contains_key(&i) {",
        "                m.insert(i, 0);",
        "            }",
        "            *m.get_mut(&i).unwrap() += 1;",
        "            n /= i;",
        "        }",
        "    }",
        "    if n != 1 {",
        "        m.insert(n, 1);",
        "    }",
        "    m",
        "}"
      ]
    },
    "run_length_compression": {
      "prefix": "run_length_compression",
      "body": [
        "///O(N)",
        "fn run_length_compression<T: Eq + Clone>(xs: &[T]) -> Vec<(T, usize)> {",
        "    if xs.is_empty() {",
        "        return vec![];",
        "    }",
        "    let mut cur = &xs[0];",
        "    let mut rep = 1;",
        "    let mut res = vec![];",
        "    for i in 1..xs.len() {",
        "        if &xs[i] == cur {",
        "            rep += 1;",
        "        } else {",
        "            res.push((cur.clone(), rep));",
        "            cur = &xs[i];",
        "            rep = 1",
        "        }",
        "    }",
        "    res.push((cur.clone(), rep));",
        "    res",
        "}"
      ]
    },
    "skiplist": {
      "prefix": "skiplist",
      "body": [
        "mod skiplist {",
        "    use std;",
        "    use std::cell::{Cell, RefCell};",
        "    use std::collections::{BTreeMap, BTreeSet};",
        "    use std::fmt;",
        "    use std::rc::Rc;",
        "    struct RandGen {",
        "        x: u64,",
        "    }",
        "    impl RandGen {",
        "        fn new(seed: u64) -> RandGen {",
        "            RandGen { x: seed }",
        "        }",
        "        fn next(&mut self) -> u64 {",
        "            const a: u64 = 1103515245;",
        "            const b: u64 = 12345;",
        "            const m: u64 = 1 << 32;",
        "            self.x = (a * self.x + b) % m;",
        "            self.x",
        "        }",
        "    }",
        "    pub struct Skiplist<T> {",
        "        max_height: Option<usize>,",
        "        left_sentinel: Rc<RefCell<SkipNode<T>>>,",
        "        right_sentinel: Rc<RefCell<SkipNode<T>>>,",
        "        rand_gen: RandGen,",
        "        traverse_stat: Cell<usize>,",
        "        connect_stat: Cell<usize>,",
        "    }",
        "    impl Skiplist<usize> {",
        "        pub fn print_graph(&self) {",
        "            for level in (0..self.height()).rev() {",
        "                let mut line = vec![];",
        "                let mut cur = self.left_sentinel.clone();",
        "                loop {",
        "                    let next0 = cur.borrow().next[level].clone();",
        "                    let next = next0.unwrap().clone();",
        "                    if next.borrow().value.is_none() {",
        "                        break;",
        "                    } else {",
        "                        cur = next.clone();",
        "                        let v = cur.borrow().value.clone().unwrap();",
        "                        line.push(v);",
        "                    }",
        "                }",
        "                let mut ss = vec![];",
        "                for x in line {",
        "                    while ss.len() < x {",
        "                        ss.push(\"--\".to_string());",
        "                    }",
        "                    ss.push(format!(\"{:>02}\", x));",
        "                }",
        "                println!(\"{}\", ss.connect(\",\"));",
        "            }",
        "            println!(\"\");",
        "        }",
        "    }",
        "    impl<T> Skiplist<T>",
        "    where",
        "        T: std::cmp::Ord + fmt::Debug + Clone,",
        "    {",
        "        pub fn new() -> Skiplist<T> {",
        "            let left_sentinel = Rc::new(RefCell::new(SkipNode::sentinel()));",
        "            let right_sentinel = Rc::new(RefCell::new(SkipNode::sentinel()));",
        "            let sentinel_height = left_sentinel.borrow().height();",
        "            for level in 0..sentinel_height {",
        "                left_sentinel.borrow_mut().next[level] = Some(right_sentinel.clone());",
        "                right_sentinel.borrow_mut().prev[level] = Some(left_sentinel.clone());",
        "            }",
        "            Skiplist {",
        "                max_height: None,",
        "                left_sentinel: left_sentinel,",
        "                right_sentinel: right_sentinel,",
        "                rand_gen: RandGen::new(0),",
        "                traverse_stat: Cell::new(0),",
        "                connect_stat: Cell::new(0),",
        "            }",
        "        }",
        "        fn height(&self) -> usize {",
        "            self.max_height.unwrap_or(33)",
        "        }",
        "        fn pick_height(&mut self) -> usize {",
        "            let z = self.rand_gen.next();",
        "            let mut k = 0;",
        "            let mut m = 1;",
        "            while z & m != 0 {",
        "                k += 1;",
        "                m <<= 1;",
        "            }",
        "            k + 1",
        "        }",
        "        pub fn insert(&mut self, x: T) -> bool {",
        "            let mut paths = self.traverse(&x);",
        "            if !paths.is_empty() {",
        "                let next0 = paths[0].borrow().next[0].clone();",
        "                let next = next0.unwrap();",
        "                let found = next.borrow().value.as_ref() == Some(&x);",
        "                if found {",
        "                    return false;",
        "                }",
        "            }",
        "            let new_height = self.pick_height();",
        "            self.max_height = Some(std::cmp::max(self.max_height.unwrap_or(0), new_height));",
        "            while paths.len() < new_height {",
        "                paths.push(self.left_sentinel.clone());",
        "            }",
        "            let new_node = Rc::new(RefCell::new(SkipNode::new(x, new_height)));",
        "            for level in 0..new_height {",
        "                let prev = &paths[level];",
        "                self.connect_stat.set(self.connect_stat.get() + 1);",
        "                SkipNode::connect(prev, &new_node, level);",
        "            }",
        "            true",
        "        }",
        "        fn find_node(&self, x: &T) -> Option<Rc<RefCell<SkipNode<T>>>> {",
        "            let paths = self.traverse(x);",
        "            if paths.is_empty() {",
        "                return None;",
        "            }",
        "            let next0 = paths[0].borrow().next[0].clone();",
        "            let next = next0.unwrap();",
        "            if next.borrow().value.as_ref() == Some(x) {",
        "                Some(next)",
        "            } else {",
        "                None",
        "            }",
        "        }",
        "        pub fn find(&self, x: &T) -> bool {",
        "            self.find_node(x).is_some()",
        "        }",
        "        pub fn reset_stat(&self) {",
        "            self.traverse_stat.set(0);",
        "            self.connect_stat.set(0);",
        "        }",
        "        pub fn show_stat(&self) {",
        "            println!(\"traverse: {}\", self.traverse_stat.get());",
        "            println!(\"connect: {}\", self.connect_stat.get());",
        "        }",
        "        fn traverse(&self, x: &T) -> Vec<Rc<RefCell<SkipNode<T>>>> {",
        "            if self.height() == 0 {",
        "                return vec![];",
        "            }",
        "            let mut cur = self.left_sentinel.clone();",
        "            let mut acc = vec![self.left_sentinel.clone(); self.height()];",
        "            let mut level = self.height() - 1;",
        "            loop {",
        "                if level == 0 {",
        "                    loop {",
        "                        acc[level] = cur.clone();",
        "                        let next0 = cur.borrow().next[level].clone();",
        "                        let next = next0.unwrap();",
        "                        if next.borrow().value.is_none()",
        "                            || next.borrow().value.as_ref().unwrap() >= x",
        "                        {",
        "                            break;",
        "                        } else {",
        "                            cur = next.clone();",
        "                            self.traverse_stat.set(self.traverse_stat.get() + 1);",
        "                        }",
        "                    }",
        "                    break;",
        "                }",
        "                let next0 = cur.borrow().next[level].clone();",
        "                let next = next0.unwrap();",
        "                if next.borrow().value.is_none() || next.borrow().value.as_ref().unwrap() >= x {",
        "                    acc[level] = cur.clone();",
        "                    level -= 1;",
        "                    continue;",
        "                } else {",
        "                    cur = next;",
        "                    self.traverse_stat.set(self.traverse_stat.get() + 1);",
        "                }",
        "            }",
        "            acc",
        "        }",
        "        fn traverse_rev(&self, x: &T) -> Vec<Rc<RefCell<SkipNode<T>>>> {",
        "            if self.height() == 0 {",
        "                return vec![];",
        "            }",
        "            let mut cur = self.right_sentinel.clone();",
        "            let mut acc = vec![self.right_sentinel.clone(); self.height()];",
        "            let mut level = self.height() - 1;",
        "            loop {",
        "                if level == 0 {",
        "                    loop {",
        "                        acc[level] = cur.clone();",
        "                        let next = cur.borrow().prev[level].clone().unwrap();",
        "                        if next.borrow().value.is_none()",
        "                            || next.borrow().value.as_ref().unwrap() <= x",
        "                        {",
        "                            break;",
        "                        } else {",
        "                            cur = next.clone();",
        "                        }",
        "                    }",
        "                    break;",
        "                }",
        "                let next = cur.borrow().prev[level].clone().unwrap();",
        "                if next.borrow().value.is_none() || next.borrow().value.as_ref().unwrap() <= x {",
        "                    acc[level] = cur.clone();",
        "                    level -= 1;",
        "                    continue;",
        "                } else {",
        "                    cur = next;",
        "                }",
        "            }",
        "            acc",
        "        }",
        "        pub fn remove(&mut self, x: &T) -> bool {",
        "            let node = self.find_node(x);",
        "            if node.is_none() {",
        "                return false;",
        "            }",
        "            let node = node.unwrap();",
        "            node.borrow_mut().remove();",
        "            true",
        "        }",
        "        ///iterator in range [x,]",
        "        pub fn ge_iter(&self, x: &T) -> Range<T> {",
        "            let f = self.traverse(x)[0].clone();",
        "            Range {",
        "                forward: true,",
        "                f: f,",
        "                b: self.right_sentinel.clone(),",
        "            }",
        "        }",
        "        ///iterator in range [,x]",
        "        pub fn le_iter(&self, x: &T) -> Range<T> {",
        "            let b = self.traverse_rev(x)[0].clone();",
        "            Range {",
        "                forward: false,",
        "                f: self.left_sentinel.clone(),",
        "                b: b,",
        "            }",
        "        }",
        "        ///iterator in range [..]",
        "        pub fn iter(&self) -> Range<T> {",
        "            Range {",
        "                forward: true,",
        "                f: self.left_sentinel.clone(),",
        "                b: self.right_sentinel.clone(),",
        "            }",
        "        }",
        "        pub fn is_empty(&self) -> bool {",
        "            let mut it = self.iter();",
        "            let mut l = 0;",
        "            for _ in it {",
        "                l += 1;",
        "            }",
        "            l == 0",
        "        }",
        "        ///O(n)",
        "        pub fn pop(&mut self) -> Option<T> {",
        "            if self.is_empty() {",
        "                None",
        "            } else {",
        "                let mut it = self.iter();",
        "                let x = it.next().unwrap();",
        "                self.remove(&x);",
        "                Some(x)",
        "            }",
        "        }",
        "        ///O(n)",
        "        pub fn pop_back(&mut self) -> Option<T> {",
        "            if self.is_empty() {",
        "                None",
        "            } else {",
        "                let mut it = self.iter().rev();",
        "                let x = it.next().unwrap();",
        "                self.remove(&x);",
        "                Some(x)",
        "            }",
        "        }",
        "    }",
        "    pub struct Range<T> {",
        "        forward: bool,",
        "        f: Rc<RefCell<SkipNode<T>>>,",
        "        b: Rc<RefCell<SkipNode<T>>>,",
        "    }",
        "    impl<T: Clone> Iterator for Range<T> {",
        "        type Item = T;",
        "        fn next(&mut self) -> Option<Self::Item> {",
        "            let next0 = if self.forward {",
        "                self.f.borrow().next[0].clone()",
        "            } else {",
        "                self.b.borrow().prev[0].clone()",
        "            };",
        "            if next0.is_none() {",
        "                return None;",
        "            }",
        "            let next = next0.unwrap();",
        "            if self.forward {",
        "                self.f = next;",
        "                self.f.borrow().value.clone()",
        "            } else {",
        "                self.b = next;",
        "                self.b.borrow().value.clone()",
        "            }",
        "        }",
        "    }",
        "    impl<T: Clone> DoubleEndedIterator for Range<T> {",
        "        fn next_back(&mut self) -> Option<Self::Item> {",
        "            let next0 = if self.forward {",
        "                self.b.borrow().prev[0].clone()",
        "            } else {",
        "                self.f.borrow().next[0].clone()",
        "            };",
        "            if next0.is_none() {",
        "                return None;",
        "            }",
        "            let next = next0.unwrap();",
        "            if self.forward {",
        "                self.b = next;",
        "                self.b.borrow().value.clone()",
        "            } else {",
        "                self.f = next;",
        "                self.f.borrow().value.clone()",
        "            }",
        "        }",
        "    }",
        "    impl<T> fmt::Debug for Skiplist<T>",
        "    where",
        "        T: fmt::Debug + Clone + std::cmp::Ord,",
        "    {",
        "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
        "            let v: Vec<T> = self.iter().collect();",
        "            writeln!(f, \"{:?}\", v);",
        "            Ok(())",
        "        }",
        "    }",
        "    struct SkipNode<T> {",
        "        value: Option<T>,",
        "        prev: Vec<Option<Rc<RefCell<SkipNode<T>>>>>,",
        "        next: Vec<Option<Rc<RefCell<SkipNode<T>>>>>,",
        "    }",
        "    impl<T> fmt::Debug for SkipNode<T>",
        "    where",
        "        T: fmt::Debug + std::cmp::Ord,",
        "    {",
        "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
        "            writeln!(f, \"{:?}, {:?}\", self.value, self.height());",
        "            Ok(())",
        "        }",
        "    }",
        "    impl<T> SkipNode<T>",
        "    where",
        "        T: std::cmp::Ord + fmt::Debug,",
        "    {",
        "        fn sentinel() -> SkipNode<T> {",
        "            SkipNode {",
        "                value: None,",
        "                prev: vec![None; 33],",
        "                next: vec![None; 33],",
        "            }",
        "        }",
        "        fn new(value: T, height: usize) -> SkipNode<T> {",
        "            SkipNode {",
        "                value: Some(value),",
        "                prev: vec![None; height],",
        "                next: vec![None; height],",
        "            }",
        "        }",
        "        fn height(&self) -> usize {",
        "            self.next.len()",
        "        }",
        "        fn remove(&mut self) {",
        "            for level in 0..self.height() {",
        "                let prev_node = self.prev[level].clone().unwrap();",
        "                let next_node = self.next[level].clone().unwrap();",
        "                next_node.borrow_mut().prev[level] = Some(prev_node.clone());",
        "                prev_node.borrow_mut().next[level] = Some(next_node.clone());",
        "            }",
        "        }",
        "        fn connect(x: &Rc<RefCell<Self>>, y: &Rc<RefCell<Self>>, level: usize) {",
        "            let x_next = x.borrow().next[level].clone().unwrap();",
        "            x.borrow_mut().next[level] = Some(y.clone());",
        "            y.borrow_mut().prev[level] = Some(x.clone());",
        "            y.borrow_mut().next[level] = Some(x_next.clone());",
        "            x_next.borrow_mut().prev[level] = Some(y.clone());",
        "        }",
        "    }",
        "    use std::collections::HashMap;",
        "    pub struct Multiset<T> {",
        "        sl: Skiplist<T>,",
        "        counting: HashMap<T, usize>,",
        "    }",
        "    impl<T> Multiset<T>",
        "    where",
        "        T: Ord + fmt::Debug + Clone + std::hash::Hash,",
        "    {",
        "        pub fn new() -> Multiset<T> {",
        "            Multiset {",
        "                sl: Skiplist::new(),",
        "                counting: HashMap::new(),",
        "            }",
        "        }",
        "        pub fn insert(&mut self, x: T) {",
        "            self.sl.insert(x.clone());",
        "            *self.counting.entry(x).or_insert(0) += 1;",
        "        }",
        "        pub fn counting(&self, x: &T) -> usize {",
        "            self.counting.get(x).cloned().unwrap_or(0)",
        "        }",
        "        pub fn remove(&mut self, x: &T) -> bool {",
        "            let cnt = self.counting(x);",
        "            if cnt == 0 {",
        "                return false;",
        "            }",
        "            if cnt >= 2 {",
        "                *self.counting.get_mut(x).unwrap() -= 1;",
        "            } else if cnt == 1 {",
        "                self.counting.remove(x);",
        "                self.sl.remove(x);",
        "            }",
        "            return true;",
        "        }",
        "        pub fn unwrap(&self) -> &Skiplist<T> {",
        "            &self.sl",
        "        }",
        "    }",
        "}"
      ]
    },
    "sliding_window": {
      "prefix": "sliding_window",
      "body": [
        "pub fn sliding_window<T, F: Fn(&T) -> K, K: Ord>(a: Vec<T>, k: usize, f: F) -> Vec<usize> {",
        "    use std::collections::VecDeque;",
        "    let n = a.len();",
        "    let mut ans = vec![n; n];",
        "    let mut q = VecDeque::new();",
        "    for i in 0..n {",
        "        while !q.is_empty() && f(&a[*q.back().unwrap()]) > f(&a[i]) {",
        "            q.pop_back();",
        "        }",
        "        q.push_back(i);",
        "        while !q.is_empty() && *q.front().unwrap() + k <= i {",
        "            q.pop_front();",
        "        }",
        "        dbg!(&q);",
        "        ans[i] = *q.front().unwrap();",
        "    }",
        "    ans",
        "}"
      ]
    },
    "solve_bsgs": {
      "prefix": "solve_bsgs",
      "body": [
        "/// a^x = b (mod m)",
        "/// を解く。",
        "/// 計算量: O(root M)",
        "pub fn solve_bsgs<M: BSGSable>(a: M::T, b: M::T, mo: u64) -> Option<u64> {",
        "    let mut r = 1;",
        "    while r * r < mo {",
        "        r += 1;",
        "    }",
        "    let mut baby_step = vec![];",
        "    baby_step.push(M::unit());",
        "    for j in 1..r {",
        "        let prev = &baby_step[j as usize - 1];",
        "        let next = M::multiply(prev, &a, mo);",
        "        baby_step.push(next);",
        "    }",
        "    let mut baby_step_k2j = HashMap::new();",
        "    for j in 0..r {",
        "        let x = &baby_step[j as usize];",
        "        let k = M::unique_key_for(x);",
        "        baby_step_k2j.insert(k, j);",
        "    }",
        "    let mut giant_step = vec![];",
        "    let a_inv = M::inv(&a, mo);",
        "    let mut a_inv_pow_r = M::unit();",
        "    for _ in 0..r {",
        "        a_inv_pow_r = M::multiply(&a_inv_pow_r, &a_inv, mo);",
        "    }",
        "    giant_step.push(M::unit());",
        "    for i in 1..r {",
        "        let prev = &giant_step[i as usize - 1];",
        "        let next = M::multiply(&prev, &a_inv_pow_r, mo);",
        "        giant_step.push(next);",
        "    }",
        "    for i in 0..r {",
        "        let gs = &giant_step[i as usize];",
        "        let tgt = M::multiply(&b, &gs, mo);",
        "        let key = M::unique_key_for(&tgt);",
        "        if let Some(j) = baby_step_k2j.get(&key) {",
        "            return Some(i * r + j);",
        "        }",
        "    }",
        "    return None;",
        "}"
      ]
    },
    "split_by_condition": {
      "prefix": "split_by_condition",
      "body": [
        "pub fn split_by_condition<T, F: FnMut(&T) -> bool>(xs: Vec<T>, mut p: F) -> Vec<Vec<T>> {",
        "    let mut res = vec![];",
        "    let mut tmp = vec![];",
        "    for x in xs {",
        "        if !p(&x) {",
        "            res.push(tmp);",
        "            tmp = vec![x];",
        "        } else {",
        "            tmp.push(x);",
        "        }",
        "    }",
        "    if tmp.len() > 0 {",
        "        res.push(tmp);",
        "    }",
        "    res",
        "}"
      ]
    },
    "split_sequence": {
      "prefix": "split_sequence",
      "body": [
        "#[derive(Debug)]",
        "pub enum SplitComp<T> {",
        "    Seq(Vec<T>),",
        "    Splitter(T),",
        "}",
        "pub fn split_sequence<T, F: Fn(&T) -> bool>(xs: Vec<T>, splitter: F) -> Vec<SplitComp<T>> {",
        "    let mut res = vec![];",
        "    let mut xs = xs;",
        "    xs.reverse();",
        "    let mut cur = vec![];",
        "    while !xs.is_empty() {",
        "        let x = xs.pop().unwrap();",
        "        let b = splitter(&x);",
        "        if b {",
        "            if cur.len() > 0 {",
        "                res.push(SplitComp::Seq(cur));",
        "            }",
        "            res.push(SplitComp::Splitter(x));",
        "            cur = vec![];",
        "        } else {",
        "            cur.push(x);",
        "        }",
        "    }",
        "    if cur.len() > 0 {",
        "        res.push(SplitComp::Seq(cur));",
        "    }",
        "    res",
        "}"
      ]
    },
    "split_tree": {
      "prefix": "split_tree",
      "body": [
        "/// 木をある頂点を中心に分解する",
        "/// nodeidは、初期の木における頂点番号を保持していて、",
        "/// eは、nodeid配列内のindexを用いて無向辺を表現する。",
        "#[derive(Debug)]",
        "pub struct SubTree {",
        "    nodeid: Vec<usize>,",
        "    e: Vec<(usize, usize)>,",
        "}",
        "pub fn split_tree(tree: SubTree, root: usize) -> Vec<SubTree> {",
        "    struct Rec<'a> {",
        "        g: &'a Vec<Vec<usize>>,",
        "        vs: Vec<usize>,",
        "        es: Vec<(usize, usize)>,",
        "    }",
        "    impl<'a> Rec<'a> {",
        "        fn solve(&mut self, u: usize, par: usize) {",
        "            self.vs.push(u);",
        "            for i in 0..self.g[u].len() {",
        "                let v = self.g[u][i];",
        "                if v != par {",
        "                    self.es.push((u, v));",
        "                    self.solve(v, u);",
        "                }",
        "            }",
        "        }",
        "    }",
        "    let mut res = vec![];",
        "    let n = tree.nodeid.len();",
        "    let mut g = vec![vec![]; n];",
        "    for (u, v) in tree.e {",
        "        g[u].push(v);",
        "        g[v].push(u);",
        "    }",
        "    for i in 0..g[root].len() {",
        "        let u = g[root][i];",
        "        let mut rec = Rec {",
        "            g: &g,",
        "            vs: vec![],",
        "            es: vec![],",
        "        };",
        "        rec.solve(u, root);",
        "        let m = rec.vs.len();",
        "        let mut rev = HashMap::new();",
        "        for i in 0..m {",
        "            rev.insert(rec.vs[i], i);",
        "        }",
        "        let mut nodeid = vec![m; m];",
        "        for i in 0..m {",
        "            let u = rec.vs[i];",
        "            nodeid[i] = tree.nodeid[u];",
        "        }",
        "        let mut e = vec![];",
        "        for (u, v) in rec.es {",
        "            let uu = *rev.get(&u).unwrap();",
        "            let vv = *rev.get(&v).unwrap();",
        "            e.push((uu, vv));",
        "        }",
        "        res.push(SubTree {",
        "            nodeid: nodeid,",
        "            e: e,",
        "        });",
        "    }",
        "    res",
        "}"
      ]
    },
    "submasks": {
      "prefix": "submasks",
      "body": [
        "/// ある値に含まれるmビットを",
        "/// 反転させた値2^m通りを計算する。",
        "/// 計算量: O(m)",
        "fn submasks(mask: i64) -> Vec<i64> {",
        "    let mut res = vec![];",
        "    let mut smask = mask;",
        "    while smask > 0 {",
        "        res.push(smask);",
        "        smask = (smask - 1) & mask;",
        "    }",
        "    res.push(0);",
        "    res.reverse();",
        "    return res;",
        "}"
      ]
    },
    "template": {
      "prefix": "template",
      "body": [
        "/// https://github.com/akiradeveloper/rust-comp-snippets",
        "#[allow(unused_imports)]",
        "use std::cmp::{max, min, Ordering};",
        "#[allow(unused_imports)]",
        "use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};",
        "#[allow(unused_imports)]",
        "use std::iter::FromIterator;",
        "#[macro_export]",
        "macro_rules ! chmax {(\\$ x : expr , \\$ (\\$ v : expr ) ,+ ) => {\\$ (\\$ x = std :: cmp :: max (\\$ x ,\\$ v ) ; ) + } ; }",
        "#[macro_export]",
        "macro_rules ! chmin {(\\$ x : expr , \\$ (\\$ v : expr ) ,+ ) => {\\$ (\\$ x = std :: cmp :: min (\\$ x ,\\$ v ) ; ) + } ; }",
        "#[macro_export]",
        "macro_rules ! max {(\\$ x : expr ) => (\\$ x ) ; (\\$ x : expr , \\$ (\\$ xs : expr ) ,+ ) => {std :: cmp :: max (\\$ x , max ! (\\$ (\\$ xs ) ,+ ) ) } ; }",
        "#[macro_export]",
        "macro_rules ! min {(\\$ x : expr ) => (\\$ x ) ; (\\$ x : expr , \\$ (\\$ xs : expr ) ,+ ) => {std :: cmp :: min (\\$ x , min ! (\\$ (\\$ xs ) ,+ ) ) } ; }",
        "#[macro_export]",
        "macro_rules ! dvec {(\\$ t : expr ; \\$ len : expr ) => {vec ! [\\$ t ; \\$ len ] } ; (\\$ t : expr ; \\$ len : expr , \\$ (\\$ rest : expr ) ,* ) => {vec ! [dvec ! (\\$ t ; \\$ (\\$ rest ) ,* ) ; \\$ len ] } ; }",
        "#[macro_export]",
        "macro_rules ! cfor {(; \\$ (\\$ rest : tt ) * ) => {cfor ! (() ; \\$ (\\$ rest ) * ) } ; (\\$ (\\$ init : stmt ) ,+; ; \\$ (\\$ rest : tt ) * ) => {cfor ! (\\$ (\\$ init ) ,+; ! false ; \\$ (\\$ rest ) * ) } ; (\\$ (\\$ init : stmt ) ,+; \\$ cond : expr ; ; \\$ body : block ) => {cfor ! {\\$ (\\$ init ) ,+; \\$ cond ; () ; \\$ body } } ; (\\$ (\\$ init : stmt ) ,+; \\$ cond : expr ; \\$ (\\$ step : expr ) ,+; \\$ body : block ) => {{\\$ (\\$ init ; ) + while \\$ cond {let mut _first = true ; let mut _continue = false ; loop {if ! _first {_continue = true ; break } _first = false ; \\$ body } if ! _continue {break } \\$ (\\$ step ; ) + } } } ; }",
        "/// main",
        "#[allow(unused_imports)]",
        "use std::io::{stdin, stdout, BufWriter, Write};",
        "#[macro_export]",
        "macro_rules ! input {(source = \\$ s : expr , \\$ (\\$ r : tt ) * ) => {let mut parser = Parser :: from_str (\\$ s ) ; input_inner ! {parser , \\$ (\\$ r ) * } } ; (parser = \\$ parser : ident , \\$ (\\$ r : tt ) * ) => {input_inner ! {\\$ parser , \\$ (\\$ r ) * } } ; (new_stdin_parser = \\$ parser : ident , \\$ (\\$ r : tt ) * ) => {let stdin = std :: io :: stdin () ; let reader = std :: io :: BufReader :: new (stdin . lock () ) ; let mut \\$ parser = Parser :: new (reader ) ; input_inner ! {\\$ parser , \\$ (\\$ r ) * } } ; (\\$ (\\$ r : tt ) * ) => {input ! {new_stdin_parser = parser , \\$ (\\$ r ) * } } ; }",
        "#[macro_export]",
        "macro_rules ! input_inner {(\\$ parser : ident ) => {} ; (\\$ parser : ident , ) => {} ; (\\$ parser : ident , \\$ var : ident : \\$ t : tt \\$ (\\$ r : tt ) * ) => {let \\$ var = read_value ! (\\$ parser , \\$ t ) ; input_inner ! {\\$ parser \\$ (\\$ r ) * } } ; }",
        "#[macro_export]",
        "macro_rules ! read_value {(\\$ parser : ident , (\\$ (\\$ t : tt ) ,* ) ) => {(\\$ (read_value ! (\\$ parser , \\$ t ) ) ,* ) } ; (\\$ parser : ident , [\\$ t : tt ; \\$ len : expr ] ) => {(0 ..\\$ len ) . map (| _ | read_value ! (\\$ parser , \\$ t ) ) . collect ::< Vec < _ >> () } ; (\\$ parser : ident , chars ) => {read_value ! (\\$ parser , String ) . chars () . collect ::< Vec < char >> () } ; (\\$ parser : ident , usize1 ) => {read_value ! (\\$ parser , usize ) - 1 } ; (\\$ parser : ident , \\$ t : ty ) => {\\$ parser . next ::<\\$ t > () . expect (\"Parse error\" ) } ; }",
        "use std::io;",
        "use std::io::BufRead;",
        "use std::str;",
        "pub struct Parser<R> {",
        "    reader: R,",
        "    buf: Vec<u8>,",
        "    pos: usize,",
        "}",
        "impl Parser<io::Empty> {",
        "    pub fn from_str(s: &str) -> Parser<io::Empty> {",
        "        Parser {",
        "            reader: io::empty(),",
        "            buf: s.as_bytes().to_vec(),",
        "            pos: 0,",
        "        }",
        "    }",
        "}",
        "impl<R: BufRead> Parser<R> {",
        "    pub fn new(reader: R) -> Parser<R> {",
        "        Parser {",
        "            reader: reader,",
        "            buf: vec![],",
        "            pos: 0,",
        "        }",
        "    }",
        "    pub fn update_buf(&mut self) {",
        "        self.buf.clear();",
        "        self.pos = 0;",
        "        loop {",
        "            let (len, complete) = {",
        "                let buf2 = self.reader.fill_buf().unwrap();",
        "                self.buf.extend_from_slice(buf2);",
        "                let len = buf2.len();",
        "                if len == 0 {",
        "                    break;",
        "                }",
        "                (len, buf2[len - 1] <= 0x20)",
        "            };",
        "            self.reader.consume(len);",
        "            if complete {",
        "                break;",
        "            }",
        "        }",
        "    }",
        "    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {",
        "        loop {",
        "            let mut begin = self.pos;",
        "            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {",
        "                begin += 1;",
        "            }",
        "            let mut end = begin;",
        "            while end < self.buf.len() && (self.buf[end] > 0x20) {",
        "                end += 1;",
        "            }",
        "            if begin != self.buf.len() {",
        "                self.pos = end;",
        "                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();",
        "            } else {",
        "                self.update_buf();",
        "            }",
        "        }",
        "    }",
        "}",
        "#[allow(unused_macros)]",
        "macro_rules ! debug {(\\$ (\\$ a : expr ) ,* ) => {eprintln ! (concat ! (\\$ (stringify ! (\\$ a ) , \" = {:?}, \" ) ,* ) , \\$ (\\$ a ) ,* ) ; } }",
        "/// https://github.com/hatoo/competitive-rust-snippets",
        "const BIG_STACK_SIZE: bool = true;",
        "#[allow(dead_code)]",
        "fn main() {",
        "    use std::thread;",
        "    if BIG_STACK_SIZE {",
        "        thread::Builder::new()",
        "            .stack_size(32 * 1024 * 1024)",
        "            .name(\"solve\".into())",
        "            .spawn(solve)",
        "            .unwrap()",
        "            .join()",
        "            .unwrap();",
        "    } else {",
        "        solve();",
        "    }",
        "}",
        "fn solve() {",
        "    let out = stdout();",
        "    let mut out = BufWriter::new(out.lock());",
        "}"
      ]
    },
    "ternary_search": {
      "prefix": "ternary_search",
      "body": [
        "///f(x) should be upper convex function in [l,r]. find x where f(x) is the max in the range.",
        "fn ternary_search<F: Fn(f64) -> f64>(f: F, l: f64, r: f64) -> f64 {",
        "    let mut l = l;",
        "    let mut r = r;",
        "    let eps = 1e-9;",
        "    while r - l > eps {",
        "        let m1 = (2.0 * l + r) / 3.0;",
        "        let m2 = (l + 2.0 * r) / 3.0;",
        "        let f1 = f(m1);",
        "        let f2 = f(m2);",
        "        if f1 < f2 {",
        "            l = m1;",
        "        } else {",
        "            r = m2;",
        "        }",
        "    }",
        "    l",
        "}"
      ]
    },
    "tree_diameter": {
      "prefix": "tree_diameter",
      "body": [
        "/// 木の直径",
        "///",
        "/// 重み付き木（無向）において、直径を求める。",
        "/// アルゴリズムにはdouble-sweepという名前があるらしい。",
        "pub mod tree_diameter {",
        "    #[derive(Clone, Copy)]",
        "    struct Edge {",
        "        dst: usize,",
        "        weight: i64,",
        "    }",
        "    pub struct FindFurthestPair {",
        "        g: Vec<Vec<Edge>>,",
        "    }",
        "    impl FindFurthestPair {",
        "        pub fn find(&self, v: usize) -> (usize, i64) {",
        "            self.find_rec(None, v)",
        "        }",
        "        fn find_rec(&self, par: Option<usize>, v: usize) -> (usize, i64) {",
        "            let mut r = (v, 0);",
        "            for &e in &self.g[v] {",
        "                if Some(e.dst) != par {",
        "                    let mut t = self.find_rec(Some(v), e.dst);",
        "                    t.1 += e.weight;",
        "                    if r.1 < t.1 {",
        "                        r = t;",
        "                    }",
        "                }",
        "            }",
        "            r",
        "        }",
        "    }",
        "    pub struct TreeDiameter {",
        "        g: Vec<Vec<Edge>>,",
        "    }",
        "    impl TreeDiameter {",
        "        pub fn new(n: usize) -> TreeDiameter {",
        "            TreeDiameter { g: vec![vec![]; n] }",
        "        }",
        "        pub fn connect(&mut self, u: usize, v: usize, dist: i64) {",
        "            self.g[u].push(Edge {",
        "                dst: v,",
        "                weight: dist,",
        "            });",
        "            self.g[v].push(Edge {",
        "                dst: u,",
        "                weight: dist,",
        "            });",
        "        }",
        "        pub fn solve(&self) -> (usize, usize, i64) {",
        "            let ffp = FindFurthestPair { g: self.g.clone() };",
        "            let (v, _) = ffp.find(0);",
        "            let (w, d) = ffp.find(v);",
        "            (v, w, d)",
        "        }",
        "    }",
        "}"
      ]
    },
    "vec_to_string": {
      "prefix": "vec_to_string",
      "body": [
        "pub fn vec_to_string<T: ToString>(xs: &[T]) -> Vec<String> {",
        "    let mut res = vec![];",
        "    for x in xs {",
        "        res.push(x.to_string());",
        "    }",
        "    res",
        "}"
      ]
    },
    "warshal_floyd": {
      "prefix": "warshal_floyd",
      "body": [
        "/// ワーシャルフロイド法",
        "///",
        "/// 帰納法による証明:",
        "/// あるi,jの最短距離について考える。",
        "/// Gの部分集合をGとして、G_kを{0,...,k}とする。",
        "/// この時、G_k U {i,j}の中でmind_k(i,j)が求まったとすると、",
        "/// G_k+1 U {i,j}のmind_k+1(i,j)は、",
        "/// mind_k(i,j) or i->k+1->j のどちらかとなる。",
        "///",
        "/// 従って、初期値は",
        "/// d[i][i] = 0",
        "/// else = inf",
        "///",
        "/// 計算量 O(V^3)",
        "fn warshal_floyd(d: &mut [Vec<i64>]) {",
        "    let n = d.len();",
        "    for k in 0..n {",
        "        for i in 0..n {",
        "            for j in 0..n {",
        "                d[i][j] = std::cmp::min(d[i][j], d[i][k] + d[k][j]);",
        "            }",
        "        }",
        "    }",
        "}"
      ]
    },
    "z_algorithm": {
      "prefix": "z_algorithm",
      "body": [
        "/// S[i,]がS[0]とprefixが何文字一致するかを示す配列Z[i]を返す。",
        "///",
        "/// 計算量 O(N)",
        "/// 空間量 O(N)",
        "pub fn z_algorithm(s: &[u64]) -> Vec<usize> {",
        "    let mut z = vec![0; s.len()];",
        "    z[0] = s.len();",
        "    let mut i = 1;",
        "    let mut j = 0;",
        "    while i < s.len() {",
        "        while i + j < s.len() && s[j] == s[i + j] {",
        "            j += 1;",
        "        }",
        "        z[i] = j;",
        "        if j == 0 {",
        "            i += 1;",
        "            continue;",
        "        }",
        "        let mut k = 1;",
        "        while i + k < s.len() && k + z[k] < j {",
        "            z[i + k] = z[k];",
        "            k += 1;",
        "        }",
        "        i += k;",
        "        j -= k;",
        "    }",
        "    z",
        "}"
      ]
    },
    "r3yohei_01bfs": {
      "prefix": "r3yohei_01bfs",
      "body": [
        "/// 隣接リスト表現に対する01BFS",
        "/// 辺のコストが0or1のグラフに使用する",
        "fn zero_one_bfs(edges: &Vec<Vec<(usize, i64)>>, s: usize) -> Vec<i64> {",
        "    //! 辺のコストが1ならdequeの右端，0なら左端を繰り返す",
        "    //! dequeの中身の頂点の暫定最短距離が常に(1,1,2,3,4,4,..)",
        "    //! のように，左と同じかそれ+1であるように並ぶ",
        "    //! 暫定距離が短いものからpop_frontしたいのでこうなる",
        "    //! ダイクストラでheapqを使うのと同じ気持ちだが，dequeなので計算量がO(V+ElogV)からO(V+E)に落ちる",
        "    let n = edges.len();",
        "    const INF: i64 = 1_000_000_000;",
        "    let mut dist = vec![INF; n];",
        "    dist[s] = 0;",
        "    let mut deque = VecDeque::new();",
        "    deque.push_back(s);",
        "    while let Some(frm) = deque.pop_front() {",
        "        for &(to, cost) in &edges[frm] {",
        "            let d = dist[frm] + cost;",
        "            if d < dist[to] {",
        "                dist[to] = d;",
        "                if cost == 1 {",
        "                    deque.push_back(to);",
        "                } else {",
        "                    deque.push_front(to);",
        "                }",
        "            }",
        "        }",
        "    }",
        "    dist",
        "}"
      ]
    },
    "r3yohei_01bfs_grid": {
      "prefix": "r3yohei_01bfs_grid",
      "body": [
        "/// 二次元グリッド上での，01BFS",
        "/// 例えば方向を状態に持てば壁にぶつかるまでの間好きなだけ方向転換できる",
        "fn zero_one_bfs(c: &Vec<Vec<char>>, s_x: usize, s_y: usize) -> Vec<Vec<i64>> {",
        "    let h = c.len();",
        "    let w = c[0].len();",
        "    const DIJ: [(usize, usize); 4] = [(!0, !0), (!0, 1), (1, !0), (1, 1)];",
        "    let mut deque = VecDeque::new();",
        "    deque.push_back((s_x, s_y));",
        "    const INF: i64 = 1_000_000_000;",
        "    let mut dist = vec![vec![INF; w]; h];",
        "    dist[s_x][s_y] = 0;",
        "    while let Some((frm_x, frm_y)) = deque.pop_front() {",
        "        let to_cost = dist[frm_x][frm_y] + 1;",
        "        for &(dx, dy) in &DIJ {",
        "            let mut to_x = frm_x.wrapping_add(dx);",
        "            let mut to_y = frm_y.wrapping_add(dy);",
        "            while to_x < h && to_y < w && c[to_x][to_y] == '.' {",
        "                if to_cost < dist[to_x][to_y] {",
        "                    deque.push_back((to_x, to_y));",
        "                    dist[to_x][to_y] = to_cost;",
        "                } else if to_cost > dist[to_x][to_y] {",
        "                    break;",
        "                }",
        "                to_x = to_x.wrapping_add(dx);",
        "                to_y = to_y.wrapping_add(dy);",
        "            }",
        "        }",
        "    }",
        "    dist",
        "}"
      ]
    },
    "r3yohei_ChangeMinMax": {
      "prefix": "r3yohei_ChangeMinMax",
      "body": [
        "/// 最小･最大の交換",
        "/// A.chmax(B)のようにすることで，もしA<BならA=Bとしてtrueを返し，そうでなければAのまま保持してfalseを返す",
        "pub trait ChangeMinMax {",
        "    fn chmin(&mut self, x: Self) -> bool;",
        "    fn chmax(&mut self, x: Self) -> bool;",
        "}",
        "impl<T: PartialOrd> ChangeMinMax for T {",
        "    fn chmin(&mut self, x: Self) -> bool {",
        "        *self > x && {",
        "            *self = x;",
        "            true",
        "        }",
        "    }",
        "    fn chmax(&mut self, x: Self) -> bool {",
        "        *self < x && {",
        "            *self = x;",
        "            true",
        "        }",
        "    }",
        "}"
      ]
    },
    "r3yohei_ModInt": {
      "prefix": "r3yohei_ModInt",
      "body": [
        "#[derive(Debug, Clone, Copy, Default)]",
        "struct ModInt {",
        "    value: usize,",
        "}",
        "impl ModInt {",
        "    const MOD: usize = 998244353;",
        "    fn new(n: usize) -> Self {",
        "        ModInt {",
        "            value: n % Self::MOD,",
        "        }",
        "    }",
        "    fn zero() -> Self {",
        "        ModInt { value: 0 }",
        "    }",
        "    fn one() -> Self {",
        "        ModInt { value: 1 }",
        "    }",
        "    fn value(&self) -> usize {",
        "        self.value",
        "    }",
        "    fn pow(&self, n: usize) -> Self {",
        "        let mut p = *self;",
        "        let mut ret = ModInt::one();",
        "        let mut nn = n;",
        "        while nn > 0 {",
        "            if nn & 1 == 1 {",
        "                ret *= p;",
        "            }",
        "            p *= p;",
        "            nn >>= 1;",
        "        }",
        "        ret",
        "    }",
        "    fn inv(&self) -> Self {",
        "        fn ext_gcd(a: usize, b: usize) -> (isize, isize, usize) {",
        "            if a == 0 {",
        "                return (0, 1, b);",
        "            }",
        "            let (x, y, g) = ext_gcd(b % a, a);",
        "            (y - b as isize / a as isize * x, x, g)",
        "        }",
        "        ModInt::new((ext_gcd(self.value, Self::MOD).0 + Self::MOD as isize) as usize)",
        "    }",
        "}",
        "impl std::ops::Add for ModInt {",
        "    type Output = ModInt;",
        "    fn add(self, other: Self) -> Self {",
        "        ModInt::new(self.value + other.value)",
        "    }",
        "}",
        "impl std::ops::Sub for ModInt {",
        "    type Output = ModInt;",
        "    fn sub(self, other: Self) -> Self {",
        "        ModInt::new(Self::MOD + self.value - other.value)",
        "    }",
        "}",
        "impl std::ops::Mul for ModInt {",
        "    type Output = ModInt;",
        "    fn mul(self, other: Self) -> Self {",
        "        ModInt::new(self.value * other.value)",
        "    }",
        "}",
        "impl std::ops::Div for ModInt {",
        "    type Output = ModInt;",
        "    fn div(self, other: Self) -> Self {",
        "        self * other.inv()",
        "    }",
        "}",
        "impl std::ops::AddAssign for ModInt {",
        "    fn add_assign(&mut self, other: Self) {",
        "        *self = *self + other;",
        "    }",
        "}",
        "impl std::ops::SubAssign for ModInt {",
        "    fn sub_assign(&mut self, other: Self) {",
        "        *self = *self - other;",
        "    }",
        "}",
        "impl std::ops::MulAssign for ModInt {",
        "    fn mul_assign(&mut self, other: Self) {",
        "        *self = *self * other;",
        "    }",
        "}",
        "impl std::ops::DivAssign for ModInt {",
        "    fn div_assign(&mut self, other: Self) {",
        "        *self = *self / other;",
        "    }",
        "}"
      ]
    },
    "r3yohei_TwoPointer": {
      "prefix": "r3yohei_TwoPointer",
      "body": [
        "/// while1重尺取法",
        "/// https://zenn.dev/luke256/articles/0d60a95fd86ffa",
        "struct TwoPointer {",
        "    n: usize,",
        "    t: Vec<i64>,",
        "}",
        "impl TwoPointer {",
        "    fn new(n: usize, t: Vec<i64>) -> Self {",
        "        Self { n, t }",
        "    }",
        "    fn run(&mut self) {",
        "        let mut l = 0;",
        "        let mut r = 0;",
        "        while l < self.n {",
        "            if r == self.n || todo!(\"条件を満たさない場合を記載\") {",
        "                l += 1;",
        "            } else {",
        "                r += 1;",
        "            }",
        "        }",
        "    }",
        "}"
      ]
    },
    "r3yohei_Xoshiro256": {
      "prefix": "r3yohei_Xoshiro256",
      "body": [
        "/// seed値を4つの初期状態値に分割するためのsplit mix 64",
        "struct SplitMix64 {",
        "    s: u64,",
        "}",
        "impl SplitMix64 {",
        "    fn new(seed: u64) -> Self {",
        "        Self { s: seed }",
        "    }",
        "    fn next_u64(&mut self) -> u64 {",
        "        self.s = self.s.wrapping_add(0x9e3779b97f4a7c15);",
        "        let mut z = self.s;",
        "        z = (z ^ z >> 30).wrapping_mul(0xbf58476d1ce4e5b9);",
        "        z = (z ^ z >> 27).wrapping_mul(0x94d049bb133111eb);",
        "        z ^ z >> 31",
        "    }",
        "}",
        "/// Xoshiro256による乱数生成器",
        "struct Xoshiro256 {",
        "    s: [u64; 4],",
        "}",
        "impl Xoshiro256 {",
        "    fn new(seed: u64) -> Self {",
        "        let mut split_mix_64 = SplitMix64::new(seed);",
        "        let mut s = [0; 4];",
        "        for si in &mut s {",
        "            *si = split_mix_64.next_u64();",
        "        }",
        "        Self { s }",
        "    }",
        "    fn next_u64(&mut self) -> u64 {",
        "        let result = (self.s[1].wrapping_mul(5)).rotate_left(7).wrapping_mul(9);",
        "        let t = self.s[1] << 17;",
        "        self.s[2] ^= self.s[0];",
        "        self.s[3] ^= self.s[1];",
        "        self.s[1] ^= self.s[2];",
        "        self.s[0] ^= self.s[3];",
        "        self.s[2] ^= t;",
        "        self.s[3] = self.s[3].rotate_left(45);",
        "        result",
        "    }",
        "    fn gen_usize(&mut self, lower: usize, upper: usize) -> usize {",
        "        assert!(lower < upper);",
        "        let count = upper - lower;",
        "        (self.next_u64() % count as u64) as usize + lower",
        "    }",
        "    fn gen_i64(&mut self, lower: i64, upper: i64) -> i64 {",
        "        assert!(lower < upper);",
        "        let count = upper - lower;",
        "        (self.next_u64() % count as u64) as i64 + lower",
        "    }",
        "    fn gen_f64(&mut self) -> f64 {",
        "        const UPPER_MASK: u64 = 0x3ff0000000000000;",
        "        const LOWER_MASK: u64 = 0xfffffffffffff;",
        "        let result = UPPER_MASK | (self.next_u64() & LOWER_MASK);",
        "        let result: f64 = unsafe { std::mem::transmute(result) };",
        "        result - 1.0",
        "    }",
        "    fn gen_bool(&mut self, prob: f64) -> bool {",
        "        self.gen_f64() < prob",
        "    }",
        "    fn fisher_yates_shuffle<T>(&mut self, items: &mut [T]) {",
        "        for i in (1..items.len()).rev() {",
        "            let j = (self.next_u64() as usize) % (i + 1);",
        "            items.swap(j, i);",
        "        }",
        "    }",
        "}"
      ]
    },
    "r3yohei_argsort": {
      "prefix": "r3yohei_argsort",
      "body": [
        "/// ベクタのargsort",
        "fn argsort<T: Ord>(v: &[T]) -> Vec<usize> {",
        "    let mut idx = (0..v.len()).collect::<Vec<_>>();",
        "    idx.sort_by(|&i, &j| v[i].cmp(&v[j]));",
        "    idx",
        "}"
      ]
    },
    "r3yohei_bfs": {
      "prefix": "r3yohei_bfs",
      "body": [
        "/// 隣接リスト表現に対するBFS",
        "fn bfs(edges: &Vec<Vec<usize>>, s: usize) -> (Vec<i64>, Vec<usize>) {",
        "    let mut deque = VecDeque::new();",
        "    deque.push_back(s);",
        "    let mut dist = vec![-1; edges.len()];",
        "    dist[s] = 0;",
        "    let mut prev = vec![!0; edges.len()];",
        "    while let Some(crt) = deque.pop_front() {",
        "        for &to in &edges[crt] {",
        "            if dist[to] == -1 {",
        "                dist[to] = dist[crt] + 1;",
        "                prev[to] = crt;",
        "                deque.push_back(to);",
        "            }",
        "        }",
        "    }",
        "    (dist, prev)",
        "}",
        "/// BFS経路復元",
        "fn restore_bfs(prev: &Vec<usize>, t: usize) -> Vec<usize> {",
        "    let mut path = vec![];",
        "    let mut tt = t;",
        "    while tt != !0 {",
        "        path.push(tt);",
        "        tt = prev[tt];",
        "    }",
        "    path.reverse();",
        "    path",
        "}"
      ]
    },
    "r3yohei_bfs_grid": {
      "prefix": "r3yohei_bfs_grid",
      "body": [
        "/// 二次元グリッド上のBFS",
        "fn bfs(c: &Vec<Vec<char>>, s_x: usize, s_y: usize) -> (Vec<Vec<i64>>, Vec<Vec<(usize, usize)>>) {",
        "    let h = c.len();",
        "    let w = c[0].len();",
        "    const DIJ: [(usize, usize); 4] = [(1, 0), (0, 1), (!0, 0), (0, !0)];",
        "    let mut deque = VecDeque::new();",
        "    deque.push_back((s_x, s_y));",
        "    let mut dist = vec![vec![-1; w]; h];",
        "    dist[s_x][s_y] = 0;",
        "    let mut prev = vec![vec![(!0, !0); w]; h];",
        "    while let Some((crt_x, crt_y)) = deque.pop_front() {",
        "        for i in 0..4 {",
        "            let to_x = crt_x.wrapping_add(DIJ[i].0);",
        "            let to_y = crt_y.wrapping_add(DIJ[i].1);",
        "            if to_x < h && to_y < w && c[to_x][to_y] == '.' && dist[to_x][to_y] == -1 {",
        "                dist[to_x][to_y] = dist[crt_x][crt_y] + 1;",
        "                prev[to_x][to_y] = (crt_x, crt_y);",
        "                deque.push_back((to_x, to_y));",
        "            }",
        "        }",
        "    }",
        "    (dist, prev)",
        "}",
        "/// BFS経路復元",
        "fn restore_bfs(prev: &Vec<Vec<(usize, usize)>>, t_x: usize, t_y: usize) -> Vec<(usize, usize)> {",
        "    let mut path = vec![];",
        "    let mut tt = (t_x, t_y);",
        "    while tt != (!0, !0) {",
        "        path.push(tt);",
        "        tt = prev[tt.0][tt.1];",
        "    }",
        "    path.reverse();",
        "    path",
        "}"
      ]
    },
    "r3yohei_bfs_grid_until_wall": {
      "prefix": "r3yohei_bfs_grid_until_wall",
      "body": [
        "/// 二次元グリッド上で，壁にぶつかるまで動くBFS",
        "fn bfs_until_wall(c: &Vec<Vec<char>>, s_x: usize, s_y: usize) -> Vec<Vec<bool>> {",
        "    let h = c.len();",
        "    let w = c[0].len();",
        "    const DIJ: [(usize, usize); 4] = [(1, 0), (0, 1), (!0, 0), (0, !0)];",
        "    let mut deque = VecDeque::new();",
        "    let mut visited = vec![vec![false; w]; h];",
        "    deque.push_back((s_x, s_y));",
        "    visited[s_x][s_y] = true;",
        "    let mut stopped = vec![vec![false; w]; h];",
        "    while let Some((frm_x, frm_y)) = deque.pop_front() {",
        "        for &(dx, dy) in &DIJ {",
        "            let mut to_x = frm_x;",
        "            let mut to_y = frm_y;",
        "            while c[to_x.wrapping_add(dx)][to_y.wrapping_add(dy)] == '.' {",
        "                to_x = to_x.wrapping_add(dx);",
        "                to_y = to_y.wrapping_add(dy);",
        "                visited[to_x][to_y] = true;",
        "            }",
        "            if !stopped[to_x][to_y] {",
        "                stopped[to_x][to_y] = true;",
        "                deque.push_back((to_x, to_y));",
        "            }",
        "        }",
        "    }",
        "    visited",
        "}"
      ]
    },
    "r3yohei_change_radix": {
      "prefix": "r3yohei_change_radix",
      "body": [
        "/// 文字列の数字sをa進数からb進数の文字列に変換する",
        "/// 大きな桁の数字を扱うために文字列としている",
        "pub fn change_radix(s: &str, a: i64, b: i64) -> String {",
        "    let mut base10: i64 = 0;",
        "    for (i, c) in s.chars().rev().enumerate() {",
        "        base10 += c.to_digit(10).unwrap() as i64 * a.pow(i as u32);",
        "    }",
        "    if base10 == 0 {",
        "        return \"0\".to_string();",
        "    }",
        "    let mut result = String::new();",
        "    while base10 != 0 {",
        "        result.push(std::char::from_digit((base10 % b) as u32, 10).unwrap());",
        "        base10 /= b;",
        "    }",
        "    return result.chars().rev().collect::<String>();",
        "}"
      ]
    },
    "r3yohei_ddlist": {
      "prefix": "r3yohei_ddlist",
      "body": [
        "use std::cell::RefCell;",
        "use std::rc::{Rc, Weak};",
        "type Link<T> = Option<Rc<RefCell<Node<T>>>>;",
        "type Wink<T> = Option<Weak<RefCell<Node<T>>>>;",
        "pub trait List<T: Clone> {",
        "    fn size(&self) -> usize;",
        "    fn get(&self, i: usize) -> Option<T>;",
        "    fn set(&mut self, i: usize, x: T) -> Option<T>;",
        "    fn add(&mut self, i: usize, x: T);",
        "    fn remove(&mut self, i: usize) -> Option<T>;",
        "}",
        "#[derive(Clone, Debug, Default)]",
        "pub struct DLList<T: Clone + Default> {",
        "    head: Link<T>,",
        "    tail: Wink<T>,",
        "    n: usize,",
        "}",
        "impl<T> Drop for DLList<T>",
        "where",
        "    T: Clone + Default,",
        "{",
        "    fn drop(&mut self) {",
        "        while self.remove(0).is_some() {}",
        "    }",
        "}",
        "#[derive(Clone, Debug, Default)]",
        "pub struct Node<T> {",
        "    x: T,",
        "    next: Link<T>,",
        "    prev: Wink<T>,",
        "}",
        "impl<T> Node<T> {",
        "    fn new(x: T) -> Rc<RefCell<Self>> {",
        "        Rc::new(RefCell::new(Self {",
        "            x,",
        "            next: None,",
        "            prev: None,",
        "        }))",
        "    }",
        "}",
        "impl<T: Default + Clone> DLList<T> {",
        "    pub fn new() -> Self {",
        "        let dummy1: Rc<RefCell<Node<T>>> = Default::default();",
        "        let dummy2: Rc<RefCell<Node<T>>> = Default::default();",
        "        dummy1.borrow_mut().next = Some(dummy2.clone());",
        "        dummy2.borrow_mut().prev = Some(Rc::downgrade(&dummy1));",
        "        Self {",
        "            head: Some(dummy1),",
        "            tail: Some(Rc::downgrade(&dummy2)),",
        "            n: 0,",
        "        }",
        "    }",
        "    fn get_link(&self, i: usize) -> Link<T> {",
        "        let mut p: Link<T>;",
        "        if i < self.n / 2 {",
        "            p = self.head.as_ref().and_then(|d| d.borrow().next.clone());",
        "            for _j in 0..i {",
        "                p = p.and_then(|p| p.borrow().next.clone());",
        "            }",
        "        } else {",
        "            p = self.tail.as_ref().and_then(|p| p.upgrade());",
        "            for _j in (i + 1..=self.n).rev() {",
        "                p = p.and_then(|p| p.borrow().prev.as_ref().and_then(|p| p.upgrade()));",
        "            }",
        "        }",
        "        p",
        "    }",
        "    fn add_before(&mut self, w: Link<T>, x: T) {",
        "        let u = Node::new(x);",
        "        u.borrow_mut().prev = w.as_ref().and_then(|p| p.borrow().prev.clone());",
        "        if let Some(p) = w.as_ref() {",
        "            p.borrow_mut().prev = Some(Rc::downgrade(&u))",
        "        }",
        "        u.borrow_mut().next = w;",
        "        u.borrow()",
        "            .prev",
        "            .as_ref()",
        "            .and_then(|p| p.upgrade().map(|p| p.borrow_mut().next = Some(u.clone())));",
        "        self.n += 1;",
        "    }",
        "    fn remove_link(&mut self, w: Link<T>) {",
        "        let prev = w.as_ref().and_then(|p| p.borrow_mut().prev.take());",
        "        let next = w.and_then(|p| p.borrow_mut().next.take());",
        "        prev.as_ref()",
        "            .and_then(|p| p.upgrade().map(|p| p.borrow_mut().next = next.clone()));",
        "        if let Some(p) = next {",
        "            p.borrow_mut().prev = prev",
        "        }",
        "        self.n -= 1;",
        "    }",
        "}",
        "impl<T: Clone + Default> List<T> for DLList<T> {",
        "    fn size(&self) -> usize {",
        "        self.n",
        "    }",
        "    fn get(&self, i: usize) -> Option<T> {",
        "        if self.n == 0 {",
        "            None",
        "        } else {",
        "            self.get_link(i).map(|p| p.borrow().x.clone())",
        "        }",
        "    }",
        "    fn set(&mut self, i: usize, x: T) -> Option<T> {",
        "        if self.n > 0 {",
        "            self.get_link(i).map(|p| {",
        "                let ret = p.borrow().x.clone();",
        "                p.borrow_mut().x = x;",
        "                ret",
        "            })",
        "        } else {",
        "            None",
        "        }",
        "    }",
        "    fn add(&mut self, i: usize, x: T) {",
        "        self.add_before(self.get_link(i), x);",
        "    }",
        "    fn remove(&mut self, i: usize) -> Option<T> {",
        "        if self.n == 0 {",
        "            return None;",
        "        }",
        "        let w = self.get_link(i);",
        "        self.remove_link(w.clone());",
        "        match w {",
        "            Some(w) => Some(Rc::try_unwrap(w).ok().unwrap().into_inner().x),",
        "            None => None,",
        "        }",
        "    }",
        "}"
      ]
    },
    "r3yohei_dfs": {
      "prefix": "r3yohei_dfs",
      "body": [
        "/// 隣接リスト表現に対するDFS",
        "fn dfs(crt: usize, pre: usize, edges: &Vec<Vec<usize>>, mut visited: &mut Vec<bool>) {",
        "    visited[crt] = true;",
        "    todo!(\"行きがけの処理\");",
        "    for &to in &edges[crt] {",
        "        if visited[to] {",
        "            continue;",
        "        }",
        "        dfs(to, crt, edges, visited);",
        "    }",
        "    todo!(\"帰りがけの処理\");",
        "}"
      ]
    },
    "r3yohei_dfs_grid": {
      "prefix": "r3yohei_dfs_grid",
      "body": [
        "/// 二次元グリッド上のDFS",
        "fn dfs(",
        "    c: &Vec<Vec<char>>,",
        "    crt_x: usize,",
        "    crt_y: usize,",
        "    prev_x: usize,",
        "    prev_y: usize,",
        "    mut visited: &mut Vec<Vec<bool>>,",
        ") {",
        "    const DIJ: [(usize, usize); 4] = [(1, 0), (0, 1), (!0, 0), (0, !0)];",
        "    visited[crt_x][crt_y] = true;",
        "    todo!(\"行きがけの処理\");",
        "    for i in 0..4 {",
        "        let to_x = crt_x.wrapping_add(DIJ[i].0);",
        "        let to_y = crt_y.wrapping_add(DIJ[i].1);",
        "        if to_x < c.len() && to_y < c[0].len() {",
        "            if (to_x == prev_x && to_y == prev_y) || c[to_x][to_y] == '#' || visited[to_x][to_y] {",
        "                continue;",
        "            }",
        "            dfs(c, to_x, to_y, crt_x, crt_y, &mut visited);",
        "        }",
        "    }",
        "    todo!(\"帰りがけの処理\");",
        "}"
      ]
    },
    "r3yohei_dijkstra": {
      "prefix": "r3yohei_dijkstra",
      "body": [
        "/// 隣接リスト表現に対するダイクストラ法",
        "fn dijkstra(edges: &Vec<Vec<(usize, i64)>>, s: usize) -> (Vec<i64>, Vec<usize>) {",
        "    let inf = 1 << 60;",
        "    let mut bh = BinaryHeap::new();",
        "    bh.push((Reverse(0), s));",
        "    let mut dist = vec![inf; edges.len()];",
        "    dist[s] = 0;",
        "    let mut prev = vec![!0; edges.len()];",
        "    while let Some((Reverse(d), crt)) = bh.pop() {",
        "        if dist[crt] < d {",
        "            continue;",
        "        }",
        "        for &(to, w) in &edges[crt] {",
        "            if d + w < dist[to] {",
        "                dist[to] = d + w;",
        "                prev[to] = crt;",
        "                bh.push((Reverse(dist[to]), to));",
        "            }",
        "        }",
        "    }",
        "    (dist, prev)",
        "}",
        "/// ダイクストラ法経路復元",
        "fn restore_dijkstra(prev: &Vec<usize>, t: usize) -> Vec<usize> {",
        "    let mut path = vec![];",
        "    let mut tt = t;",
        "    while tt != !0 {",
        "        path.push(tt);",
        "        tt = prev[tt];",
        "    }",
        "    path.reverse();",
        "    path",
        "}"
      ]
    },
    "r3yohei_gaussian_process_regression": {
      "prefix": "r3yohei_gaussian_process_regression",
      "body": [
        "/// ガウス過程回帰のカーネルのハイパーパラメータ",
        "#[derive(Debug, Clone, Copy)]",
        "struct GaussianProcessRegressionParameter {",
        "    theta1: f64,",
        "    theta2: f64,",
        "    theta3: f64,",
        "}",
        "impl GaussianProcessRegressionParameter {",
        "    fn new(theta1: f64, theta2: f64, theta3: f64) -> Self {",
        "        Self {",
        "            theta1,",
        "            theta2,",
        "            theta3,",
        "        }",
        "    }",
        "}",
        "/// 1次元ガウス過程回帰モデル",
        "#[derive(Debug, Clone)]",
        "struct GaussianProcessRegression {",
        "    x: Vec<DVector<f64>>,",
        "    y: Vec<f64>,",
        "    param: GaussianProcessRegressionParameter,",
        "}",
        "impl GaussianProcessRegression {",
        "    pub fn new() -> Self {",
        "        Self {",
        "            x: vec![],",
        "            y: vec![],",
        "            param: GaussianProcessRegressionParameter::new(1.0, 1.0, 0.1),",
        "        }",
        "    }",
        "    pub fn collect_data(&mut self, xi: DVector<f64>, yi: f64) {",
        "        self.x.push(xi);",
        "        self.y.push(yi);",
        "    }",
        "    pub fn predict(&self, x_test: &DMatrix<f64>) -> (Vec<f64>, Vec<f64>) {",
        "        let mut x_train = DMatrix::from_row_slice(",
        "            self.x.len(),",
        "            self.x[0].len(),",
        "            &self.x.iter().flatten().copied().collect_vec(),",
        "        );",
        "        let mut y_train = DVector::from_vec(self.y.clone());",
        "        let y_average = y_train.mean();",
        "        y_train.add_scalar_mut(-y_average);",
        "        let train_len = self.x.len();",
        "        let test_len = x_test.shape().0;",
        "        let kernel_mat = self.compute_kernel_matrix(&x_train);",
        "        let kernel_lu = kernel_mat.lu();",
        "        let yy = kernel_lu.solve(&y_train).unwrap();",
        "        let mut mean = vec![];",
        "        let mut covariance = vec![];",
        "        for j in 0..test_len {",
        "            let mut k = vec![];",
        "            for i in 0..train_len {",
        "                let xi = x_train.row(i).transpose();",
        "                let xj = x_test.row(j).transpose();",
        "                let kernel = self.kernel(&xi, &xj, i, j);",
        "                k.push(kernel);",
        "            }",
        "            let k = DVector::from_vec(k);",
        "            let xj = x_test.row(j).transpose();",
        "            let s = self.kernel(&xj, &xj, j + train_len, j + train_len);",
        "            mean.push(k.dot(&yy) + y_average);",
        "            covariance.push(s - (k.transpose() * kernel_lu.solve(&k).unwrap())[(0, 0)]);",
        "        }",
        "        (mean, covariance)",
        "    }",
        "    fn kernel(&self, xi: &DVector<f64>, xj: &DVector<f64>, i: usize, j: usize) -> f64 {",
        "        let diff = xi - xj;",
        "        let norm = diff.component_mul(&diff).sum();",
        "        let mut kernel = self.param.theta1 * (-norm / self.param.theta2.powf(2.0)).exp();",
        "        if i == j {",
        "            kernel += self.param.theta3;",
        "        }",
        "        kernel",
        "    }",
        "    fn compute_kernel_matrix(&self, x_train: &DMatrix<f64>) -> DMatrix<f64> {",
        "        let train_len = x_train.shape().0;",
        "        let mut kernel_mat = DMatrix::zeros(train_len, train_len);",
        "        for i in 0..train_len {",
        "            for j in 0..train_len {",
        "                let xi = x_train.row(i).transpose();",
        "                let xj = x_train.row(j).transpose();",
        "                kernel_mat[(i, j)] = self.kernel(&xi, &xj, i, j);",
        "            }",
        "        }",
        "        kernel_mat",
        "    }",
        "    fn log_likelihood(&self, y_train: &DVector<f64>, kernel_mat: DMatrix<f64>) -> f64 {",
        "        let det = kernel_mat.determinant().max(1e-100);",
        "        -det.ln() - (y_train.transpose() * kernel_mat.lu().solve(y_train).unwrap())[(0, 0)]",
        "    }",
        "    fn search_ranges(&self) -> (Vec<f64>, Vec<f64>, Vec<f64>) {",
        "        let theta1_range = (3..10).map(|v| 2.0_f64.powi(v)).collect_vec();",
        "        let theta2_range = (2..12).map(|v| 5.0 * v as f64).collect_vec();",
        "        let theta3_range = (0..6).map(|v| 2.0_f64.powi(v)).collect_vec();",
        "        (theta1_range, theta2_range, theta3_range)",
        "    }",
        "    pub fn grid_search(&mut self) {",
        "        let x_train = DMatrix::from_row_slice(",
        "            self.x.len(),",
        "            self.x[0].len(),",
        "            &self.x.iter().flatten().copied().collect_vec(),",
        "        );",
        "        let mut y_train = DVector::from_vec(self.y.clone());",
        "        let y_average = y_train.mean();",
        "        y_train.add_scalar_mut(-y_average);",
        "        let mut best_param = self.param;",
        "        let kernel_mat = self.compute_kernel_matrix(&x_train);",
        "        let mut best_likelihood = self.log_likelihood(&y_train, kernel_mat);",
        "        let (theta1_range, theta2_range, theta3_range) = self.search_ranges();",
        "        for &theta1 in &theta1_range {",
        "            for &theta2 in &theta2_range {",
        "                for &theta3 in &theta3_range {",
        "                    self.param = GaussianProcessRegressionParameter::new(theta1, theta2, theta3);",
        "                    let kernel_mat = self.compute_kernel_matrix(&x_train);",
        "                    let likelihood = self.log_likelihood(&y_train, kernel_mat);",
        "                    if best_likelihood < likelihood {",
        "                        best_likelihood = likelihood;",
        "                        best_param =",
        "                            GaussianProcessRegressionParameter::new(theta1, theta2, theta3);",
        "                    }",
        "                }",
        "            }",
        "        }",
        "        self.param = best_param;",
        "    }",
        "}"
      ]
    },
    "r3yohei_get_time": {
      "prefix": "r3yohei_get_time",
      "body": [
        "/// 現在時刻を返す",
        "pub fn get_time() -> f64 {",
        "    static mut STIME: f64 = -1.0;",
        "    let t = std::time::SystemTime::now()",
        "        .duration_since(std::time::UNIX_EPOCH)",
        "        .unwrap();",
        "    let ms = t.as_secs() as f64 + t.subsec_nanos() as f64 * 1e-9;",
        "    unsafe {",
        "        if STIME < 0.0 {",
        "            STIME = ms;",
        "        }",
        "        #[cfg(feature = \"local\")]",
        "        {",
        "            (ms - STIME) * 1.5",
        "        }",
        "        #[cfg(not(feature = \"local\"))]",
        "        {",
        "            ms - STIME",
        "        }",
        "    }",
        "}"
      ]
    },
    "r3yohei_is_ok": {
      "prefix": "r3yohei_is_ok",
      "body": [
        "fn is_ok(mid: isize) -> bool {",
        "    todo!()",
        "}"
      ]
    },
    "r3yohei_is_prime": {
      "prefix": "r3yohei_is_prime",
      "body": [
        "/// 素数判定",
        "/// O(√n)",
        "/// 1~√nまででnを割り切るものがあれば素数でない",
        "fn is_prime(n: usize) -> bool {",
        "    if n <= 1 {",
        "        return false;",
        "    }",
        "    let rootn = (n as f64).sqrt().floor() as usize;",
        "    for i in 2..=rootn {",
        "        if n % i == 0 {",
        "            return false;",
        "        }",
        "    }",
        "    true",
        "}"
      ]
    },
    "r3yohei_largest_square_in_grid": {
      "prefix": "r3yohei_largest_square_in_grid",
      "body": [
        "/// グリッド内の最大正方形の面積を求める O(HW)",
        "/// https://qiita.com/H20/items/884551b4965739176afc",
        "fn largest_square_in_grid(grid: &Vec<Vec<bool>>) -> Vec<Vec<i64>> {",
        "    let H = grid.len();",
        "    let W = grid[0].len();",
        "    let mut dp = vec![vec![-1; W]; H];",
        "    for i in 0..H {",
        "        for j in 0..W {",
        "            if grid[i][j] {",
        "                if i == 0 || j == 0 {",
        "                    dp[i][j] = 1;",
        "                } else {",
        "                    dp[i][j] = dp[i - 1][j].min(dp[i][j - 1]).min(dp[i - 1][j - 1]) + 1;",
        "                }",
        "            } else {",
        "                dp[i][j] = 0;",
        "            }",
        "        }",
        "    }",
        "    dp",
        "}"
      ]
    },
    "r3yohei_lis": {
      "prefix": "r3yohei_lis",
      "body": [
        "/// 最長部分増加列(LIS)を求める O(NlogN)",
        "/// https://qiita.com/python_walker/items/d1e2be789f6e7a0851e5",
        "fn lis(a: &[i64]) -> usize {",
        "    let inf: i64 = 1_000_000_000;",
        "    let mut dp = vec![inf; a.len()];",
        "    let mut p = vec![0; a.len()];",
        "    for (i, &ai) in a.iter().enumerate() {",
        "        let j = dp.lower_bound(&ai);",
        "        dp[j] = ai;",
        "        p[i] = j + 1;",
        "    }",
        "    let mut ans = 0;",
        "    for i in 0..a.len() {",
        "        if dp[i] != inf {",
        "            ans += 1;",
        "        }",
        "    }",
        "    ans",
        "}"
      ]
    },
    "r3yohei_lucas_theorem": {
      "prefix": "r3yohei_lucas_theorem",
      "body": [
        "/// p-1C0 ~ p-1Cp-1 をDPで求める",
        "/// comb[i][j] := iCj mod p (i >= j)",
        "/// iCj = i-1Cj-1 + i-1Cjであることを利用",
        "fn ncr_mod(p: usize) -> Vec<Vec<usize>> {",
        "    let mut comb = vec![vec![0; p]; p];",
        "    comb[0][0] = 1;",
        "    for i in 1..p {",
        "        comb[i][0] = 1;",
        "        for j in (1..=i).rev() {",
        "            comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % p;",
        "        }",
        "    }",
        "    comb",
        "}",
        "/// リュカの定理によりnCr mod pを求める",
        "/// O(p^2 + log_p(n))",
        "fn ncr_lucas(mut n: usize, mut r: usize, p: usize) -> usize {",
        "    let mut ret = 1;",
        "    let comb = ncr_mod(p);",
        "    while n > 0 {",
        "        let n_next = n % p;",
        "        let r_next = r % p;",
        "        ret *= comb[n_next][r_next];",
        "        ret %= p;",
        "        n /= p;",
        "        r /= p;",
        "    }",
        "    ret",
        "}"
      ]
    },
    "r3yohei_meguru_bisect": {
      "prefix": "r3yohei_meguru_bisect",
      "body": [
        "fn is_ok(mid: isize) -> bool {",
        "    todo!()",
        "}",
        "/// めぐる式二分探索(https://aotamasaki.hatenablog.com/entry/meguru_bisect)",
        "/// ng: '取り得る最小の値' - 1",
        "/// ok: '取り得る最大の値' + 1",
        "fn meguru_bisect(mut ng: isize, mut ok: isize) -> usize {",
        "    while ok.abs_diff(ng) > 1 {",
        "        let mid = (ok + ng) / 2;",
        "        if is_ok(mid) {",
        "            ok = mid;",
        "        } else {",
        "            ng = mid;",
        "        }",
        "    }",
        "    ok as usize",
        "}"
      ]
    },
    "r3yohei_memorization_recursion": {
      "prefix": "r3yohei_memorization_recursion",
      "body": [
        "/// メモ化再帰関数",
        "/// 例: 区間DP",
        "pub fn memo_rec(l: usize, r: usize, a: &[i64], mut dp: &mut [Vec<Option<i64>>]) -> i64 {",
        "    if l == r {",
        "        return 0;",
        "    }",
        "    return match dp[l][r] {",
        "        Some(val) => val,",
        "        None => {",
        "            let val = memo_rec(l + 1, r, &a, &mut dp).max(memo_rec(l, r - 1, &a, &mut dp));",
        "            dp[l][r] = Some(val);",
        "            val",
        "        }",
        "    };",
        "}"
      ]
    },
    "r3yohei_min_cost_flow": {
      "prefix": "r3yohei_min_cost_flow",
      "body": [
        "#[derive(Debug, Clone, Copy)]",
        "struct Edge {",
        "    to: usize,",
        "    cap: isize,",
        "    cost: i64,",
        "    rev: usize,",
        "}",
        "#[derive(Debug, Clone)]",
        "struct MinCostFlow {",
        "    n: usize,",
        "    graph: Vec<Vec<Edge>>,",
        "    h: Vec<i64>,",
        "    dist: Vec<i64>,",
        "    prev: Vec<(usize, usize)>,",
        "}",
        "impl MinCostFlow {",
        "    fn new(n: usize) -> Self {",
        "        MinCostFlow {",
        "            n: n,",
        "            graph: vec![vec![]; n],",
        "            h: vec![0; n],",
        "            dist: vec![0; n],",
        "            prev: vec![(0, 0); n],",
        "        }",
        "    }",
        "    fn add_edge(&mut self, from: usize, to: usize, cap: isize, cost: i64) {",
        "        let fst = Edge {",
        "            to: to,",
        "            cap: cap,",
        "            cost: cost,",
        "            rev: self.graph[to].len(),",
        "        };",
        "        self.graph[from].push(fst);",
        "        let snd = Edge {",
        "            to: from,",
        "            cap: 0,",
        "            cost: -cost,",
        "            rev: self.graph[from].len() - 1,",
        "        };",
        "        self.graph[to].push(snd);",
        "    }",
        "    fn min_cost_flow(&mut self, s: usize, t: usize, mut f: isize) -> i64 {",
        "        let n = self.n;",
        "        let inf: i64 = std::i64::MAX / 10;",
        "        let mut res = 0;",
        "        let h = &mut self.h;",
        "        let dist = &mut self.dist;",
        "        while f > 0 {",
        "            let mut que = std::collections::BinaryHeap::<(i64, usize)>::new();",
        "            for i in 0..n {",
        "                dist[i] = inf;",
        "            }",
        "            dist[s] = 0;",
        "            que.push((0, s));",
        "            while let Some((d, v)) = que.pop() {",
        "                let d = -d;",
        "                if dist[v] < d {",
        "                    continue;",
        "                }",
        "                for (i, &e) in self.graph[v].iter().enumerate() {",
        "                    if e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to] {",
        "                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];",
        "                        self.prev[e.to] = (v, i);",
        "                        que.push((-dist[e.to], e.to));",
        "                    }",
        "                }",
        "            }",
        "            if dist[t] == inf {",
        "                return -1;",
        "            }",
        "            for i in 0..n {",
        "                h[i] += dist[i];",
        "            }",
        "            let mut d = f;",
        "            let mut i = t;",
        "            while i != s {",
        "                let (pv, pe) = self.prev[i];",
        "                d = std::cmp::min(d, self.graph[pv][pe].cap);",
        "                i = pv;",
        "            }",
        "            f -= d;",
        "            res += d as i64 * h[t];",
        "            i = t;",
        "            while i != s {",
        "                let (pv, pe) = self.prev[i];",
        "                self.graph[pv][pe].cap -= d;",
        "                let erev = self.graph[pv][pe].rev;",
        "                self.graph[i][erev].cap += d;",
        "                i = pv;",
        "            }",
        "        }",
        "        return res;",
        "    }",
        "}"
      ]
    },
    "r3yohei_modinv": {
      "prefix": "r3yohei_modinv",
      "body": [
        "/// x^p mod MODを繰り返し二乗法により求める",
        "/// O(log(p))",
        "fn modpow(mut x: i64, mut p: i64, mod_num: i64) -> i64 {",
        "    let mut ret = 1;",
        "    while p > 0 {",
        "        if p & 1 == 1 {",
        "            ret *= x;",
        "            ret %= mod_num;",
        "        }",
        "        x *= x;",
        "        x %= mod_num;",
        "        p >>= 1;",
        "    }",
        "    ret",
        "}",
        "/// MODを法とするxの逆元を見つける",
        "fn modinv(x: i64, mod_num: i64) -> i64 {",
        "    modpow(x, mod_num - 2, mod_num)",
        "}"
      ]
    },
    "r3yohei_modpow": {
      "prefix": "r3yohei_modpow",
      "body": [
        "/// x^p mod MODを繰り返し二乗法により求める",
        "/// O(log(p))",
        "fn modpow(mut x: i64, mut p: i64, mod_num: i64) -> i64 {",
        "    let mut ret = 1;",
        "    while p > 0 {",
        "        if p & 1 == 1 {",
        "            ret *= x;",
        "            ret %= mod_num;",
        "        }",
        "        x *= x;",
        "        x %= mod_num;",
        "        p >>= 1;",
        "    }",
        "    ret",
        "}"
      ]
    },
    "r3yohei_ncr_mod": {
      "prefix": "r3yohei_ncr_mod",
      "body": [
        "/// p-1C0 ~ p-1Cp-1 をDPで求める",
        "/// comb[i][j] := iCj mod p (i >= j)",
        "/// iCj = i-1Cj-1 + i-1Cjであることを利用",
        "fn ncr_mod(p: usize) -> Vec<Vec<usize>> {",
        "    let mut comb = vec![vec![0; p]; p];",
        "    comb[0][0] = 1;",
        "    for i in 1..p {",
        "        comb[i][0] = 1;",
        "        for j in (1..=i).rev() {",
        "            comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % p;",
        "        }",
        "    }",
        "    comb",
        "}"
      ]
    },
    "r3yohei_ncr_small": {
      "prefix": "r3yohei_ncr_small",
      "body": [
        "/// n <= 200くらいまでの組合せ",
        "fn nCr_small(n: u128, r: u128) -> u128 {",
        "    //! オーバーフローしないように，以下の工夫をする",
        "    //! nCr = n*(n-1)*...*(n-r+1) / 1*2*...*r より，",
        "    //! n/1 * (n-1)/2 *...* (n-r+1) / r",
        "    let mut ncr = 1;",
        "    for i in 1..=r {",
        "        ncr *= n - i + 1;",
        "        ncr /= i;",
        "    }",
        "    ncr",
        "}"
      ]
    },
    "r3yohei_next_permutation": {
      "prefix": "r3yohei_next_permutation",
      "body": [
        "/// イテレータの並びのうち，辞書順で次の並びのものがあるかどうかを判定する",
        "/// あれば，イテレータも並び替えられる",
        "pub fn next_permutation<T>(a: &mut [T]) -> bool",
        "where",
        "    T: PartialOrd,",
        "{",
        "    let n = a.len();",
        "    for i in (1..n).rev() {",
        "        if a[i - 1] < a[i] {",
        "            let mut j = n - 1;",
        "            while a[i - 1] >= a[j] {",
        "                j -= 1;",
        "            }",
        "            a.swap(i - 1, j);",
        "            a[i..n].reverse();",
        "            return true;",
        "        }",
        "    }",
        "    a.reverse();",
        "    false",
        "}"
      ]
    },
    "r3yohei_prim": {
      "prefix": "r3yohei_prim",
      "body": [
        "/// プリム法により最小全域木のコストを返す",
        "/// O(N + MlogN)",
        "pub fn prim(edges: &Vec<Vec<(usize, i64)>>) -> i64 {",
        "    let mut cost = 0;",
        "    let mut visited = vec![false; edges.len()];",
        "    let mut bh = BinaryHeap::new();",
        "    bh.push((Reverse(0), 0, !0));",
        "    while let Some((Reverse(w1), crt, frm)) = bh.pop() {",
        "        if visited[crt] {",
        "            continue;",
        "        }",
        "        visited[crt] = true;",
        "        if frm != !0 {",
        "            cost += w1;",
        "        }",
        "        for &(to, w2) in &edges[crt] {",
        "            if visited[to] {",
        "                continue;",
        "            }",
        "            bh.push((Reverse(w2), to, crt));",
        "        }",
        "    }",
        "    cost",
        "}"
      ]
    },
    "r3yohei_prime_factorization": {
      "prefix": "r3yohei_prime_factorization",
      "body": [
        "/// 素数判定",
        "/// O(√n)",
        "/// 1~√nまででnを割り切るものがあれば素数でない",
        "fn is_prime(n: usize) -> bool {",
        "    if n <= 1 {",
        "        return false;",
        "    }",
        "    let rootn = (n as f64).sqrt().floor() as usize;",
        "    for i in 2..=rootn {",
        "        if n % i == 0 {",
        "            return false;",
        "        }",
        "    }",
        "    true",
        "}",
        "/// 素因数分解",
        "/// is_prime()に依存",
        "fn prime_factorization(mut n: usize) -> Vec<usize> {",
        "    let mut factor = vec![];",
        "    if is_prime(n) {",
        "        factor.push(n);",
        "        factor",
        "    } else {",
        "        let rootn = (n as f64).sqrt().floor() as usize;",
        "        for i in 2..=rootn {",
        "            while n % i == 0 {",
        "                n /= i;",
        "                factor.push(i);",
        "            }",
        "        }",
        "        if n != 1 {",
        "            factor.push(n);",
        "        }",
        "        factor",
        "    }",
        "}"
      ]
    },
    "r3yohei_removability_checker": {
      "prefix": "r3yohei_removability_checker",
      "body": [
        "struct RemovabilityChecker {",
        "    window: usize,",
        "    removability: Vec<bool>,",
        "}",
        "impl RemovabilityChecker {",
        "    fn new(window: usize) -> Self {",
        "        let mut removability = vec![false; 1 << (window * window)];",
        "        for pattern in 0..(1 << (window * window)) {",
        "            let drop_center = pattern & !(1 << ((window * window) / 2));",
        "            removability[pattern] = Self::bfs(window, drop_center as u32);",
        "        }",
        "        Self {",
        "            window,",
        "            removability,",
        "        }",
        "    }",
        "    fn bfs(window: usize, pattern: u32) -> bool {",
        "        let s = pattern.trailing_zeros() as usize;",
        "        let mut deque = VecDeque::new();",
        "        let mut visited = 0;",
        "        deque.push_back(s);",
        "        visited |= 1 << s;",
        "        while let Some(crt) = deque.pop_front() {",
        "            if crt % window < window - 1 {",
        "                let next = crt + 1;",
        "                if (visited & (1 << next)) == 0 && 0 < (pattern & (1 << next)) {",
        "                    visited |= 1 << next;",
        "                    deque.push_back(next);",
        "                }",
        "            }",
        "            if 0 < crt % window {",
        "                let next = crt - 1;",
        "                if (visited & (1 << next)) == 0 && 0 < (pattern & (1 << next)) {",
        "                    visited |= 1 << next;",
        "                    deque.push_back(next);",
        "                }",
        "            }",
        "            if crt + window < window * window {",
        "                let next = crt + window;",
        "                if (visited & (1 << next)) == 0 && 0 < (pattern & (1 << next)) {",
        "                    visited |= 1 << next;",
        "                    deque.push_back(next);",
        "                }",
        "            }",
        "            if window <= crt {",
        "                let next = crt - window;",
        "                if (visited & (1 << next)) == 0 && 0 < (pattern & (1 << next)) {",
        "                    visited |= 1 << next;",
        "                    deque.push_back(next);",
        "                }",
        "            }",
        "        }",
        "        pattern == visited",
        "    }",
        "}"
      ]
    },
    "r3yohei_run_length_encoding": {
      "prefix": "r3yohei_run_length_encoding",
      "body": [
        "/// ランレングス符号化",
        "/// s = \"RRRLLRLRRLLLLRLRR\"などを",
        "/// [(R, 3), (L, 2), (R, 1), (L, 1), (R, 2), (L, 4), (R, 1), (L, 1), (R, 2)]",
        "/// のように変換する",
        "/// O(n)",
        "fn run_length_encoding(s: Vec<i64>) -> Vec<(i64, usize)> {",
        "    let mut tmp = s[0];",
        "    let mut cnt = 0;",
        "    let mut encode = vec![];",
        "    for &si in &s {",
        "        if tmp == si {",
        "            cnt += 1;",
        "        } else {",
        "            encode.push((tmp, cnt));",
        "            tmp = si;",
        "            cnt = 1;",
        "        }",
        "    }",
        "    encode.push((tmp, cnt));",
        "    encode",
        "}"
      ]
    },
    "r3yohei_sieve_of_eratosthenes": {
      "prefix": "r3yohei_sieve_of_eratosthenes",
      "body": [
        "/// エラトステネスの篩",
        "/// n以下の素数を列挙する",
        "/// O(nloglogn)",
        "fn sieve_of_eratosthenes(n: usize) -> Vec<usize> {",
        "    if n <= 1 {",
        "        return vec![];",
        "    }",
        "    let mut sieve = vec![true; n + 1];",
        "    sieve[0] = false;",
        "    sieve[1] = false;",
        "    let mut prime = vec![];",
        "    for i in 2..(n + 1) {",
        "        if sieve[i] {",
        "            prime.push(i);",
        "            for j in (i * 2..n + 1).step_by(i) {",
        "                sieve[j] = false;",
        "            }",
        "        }",
        "    }",
        "    prime",
        "}"
      ]
    },
    "r3yohei_sieve_of_eratosthenes_from_l_to_r": {
      "prefix": "r3yohei_sieve_of_eratosthenes_from_l_to_r",
      "body": [
        "/// L以上R以下の素数のエラトステネスの篩による列挙",
        "/// is_prime[x]: x+Lが素数かどうか",
        "fn sieve_of_eratosthenes_from_l_to_r(n: usize, l: usize, r: usize) -> Vec<usize> {",
        "    if n <= 1 {",
        "        return vec![];",
        "    }",
        "    let mut is_prime = vec![true; r - l + 1];",
        "    if l == 1 {",
        "        is_prime[0] = false;",
        "    }",
        "    let rootn = (n as f64).sqrt().floor() as usize;",
        "    for i in 2..=rootn {",
        "        let min_value = ((l + i - 1) / i) * i;",
        "        for j in (min_value..=r).step_by(i) {",
        "            if j == i {",
        "                continue;",
        "            }",
        "            is_prime[j - l] = false;",
        "        }",
        "    }",
        "    let mut prime = vec![];",
        "    for i in 0..r - l + 1 {",
        "        if is_prime[i] {",
        "            prime.push(i + l);",
        "        }",
        "    }",
        "    prime",
        "}"
      ]
    },
    "r3yohei_sinkhorn_knopp": {
      "prefix": "r3yohei_sinkhorn_knopp",
      "body": [
        "/// Sinkhorn-Knoppアルゴリズム",
        "/// [つるさんのブログ](https://theory-and-me.hatenablog.com/entry/2021/05/09/181435)",
        "fn sinkhorn_knopp(",
        "    a: Vec<f64>,",
        "    b: Vec<f64>,",
        "    C: Vec<Vec<f64>>,",
        "    lambda: f64,",
        "    tolerance: f64,",
        ") -> Vec<Vec<f64>> {",
        "    //! N件のソースからM件のターゲットにいくらかモノを運ぶ",
        "    //! 各ソースsiにはai個の供給があり，各ターゲットtiにはbi個の需要がある",
        "    //! Σ(1~n)ai = Σ(1~M)biとする",
        "    //! si->tj にモノを運ぶのに，cijの輸送コストがかかる",
        "    //! si->tjへの輸送量xijを適切に決めて，各ターゲットの要求を満たしつつ輸送コストの和を最小化する",
        "    //! Args:",
        "    //!     a: ソースの供給量ベクタ",
        "    //!     b: ターゲットの需要量ベクタ",
        "    //!     C: ソースiからターゲットjへの輸送コストcijの行列",
        "    //!     lambda: Sinkhorn-Knoppアルゴリズムの性能をコントロールするハイパーパラメータ (>0)",
        "    //!             大きいほど真の値に近づくが，収束が遅くなる",
        "    //!             ただし，あまりに大きい値にするとexp(-λ*cij)が破綻する",
        "    //!     tolerance: ベクタu, vのノルムがこれより変化しなくなったら収束したとみなす",
        "    //! Returns:",
        "    //!     R: ソースiからターゲットjへの輸送量rijの行列",
        "    let K = DMatrix::from_row_slice(",
        "        C.len(),",
        "        C[0].len(),",
        "        &C.iter()",
        "            .flatten()",
        "            .map(|&cij| f64::exp(-lambda * cij))",
        "            .collect_vec(),",
        "    );",
        "    let K_t = K.transpose();",
        "    let a = DVector::from_vec(a);",
        "    let b = DVector::from_vec(b);",
        "    let mut u = DVector::from_element(C.len(), 1.0);",
        "    let mut v = b.component_div(&(&K_t * &u));",
        "    let mut iter = 0;",
        "    loop {",
        "        iter += 1;",
        "        let next_u = a.component_div(&(&K * &v));",
        "        let next_v = b.component_div(&(&K_t * &u));",
        "        let error = (&next_u - &u).norm() + (&next_v - &v).norm();",
        "        if error < tolerance {",
        "            eprintln!(\"sinkhorn-knopp is converged after {} iterations\", iter);",
        "            break;",
        "        }",
        "        u = next_u;",
        "        v = next_v;",
        "    }",
        "    let U = DMatrix::from_diagonal(&u);",
        "    let V = DMatrix::from_diagonal(&v);",
        "    let R = U * K * V;",
        "    let R: Vec<Vec<f64>> = R.row_iter().map(|r| r.iter().copied().collect()).collect();",
        "    R",
        "}"
      ]
    },
    "r3yohei_split_mix_64": {
      "prefix": "r3yohei_split_mix_64",
      "body": [
        "/// seed値を4つの初期状態値に分割するためのsplit mix 64",
        "struct SplitMix64 {",
        "    s: u64,",
        "}",
        "impl SplitMix64 {",
        "    fn new(seed: u64) -> Self {",
        "        Self { s: seed }",
        "    }",
        "    fn next_u64(&mut self) -> u64 {",
        "        self.s = self.s.wrapping_add(0x9e3779b97f4a7c15);",
        "        let mut z = self.s;",
        "        z = (z ^ z >> 30).wrapping_mul(0xbf58476d1ce4e5b9);",
        "        z = (z ^ z >> 27).wrapping_mul(0x94d049bb133111eb);",
        "        z ^ z >> 31",
        "    }",
        "}"
      ]
    },
    "r3yohei_transpose": {
      "prefix": "r3yohei_transpose",
      "body": [
        "/// 二次元配列の転置を求める",
        "fn transpose(a: &Vec<Vec<i64>>) -> Vec<Vec<i64>> {",
        "    let h = a.len();",
        "    let w = a[0].len();",
        "    let mut a_t = vec![vec![0; h]; w];",
        "    for hi in 0..h {",
        "        for wi in 0..w {",
        "            a_t[wi][hi] = a[hi][wi];",
        "        }",
        "    }",
        "    a_t",
        "}"
      ]
    },
    "r3yohei_warshall_floyd": {
      "prefix": "r3yohei_warshall_floyd",
      "body": [
        "/// ワーシャルフロイド法",
        "/// 全点対最短経路問題を解くアルゴリズム",
        "/// O(V^3)",
        "/// 制約がN<=10^2くらいのときにエスパー可能",
        "fn warshall_floyd(dist: &mut Vec<Vec<i64>>) {",
        "    let n = dist.len();",
        "    for k in 0..n {",
        "        for i in 0..n {",
        "            for j in 0..n {",
        "                if dist[i][j] > dist[i][k] + dist[k][j] {",
        "                    dist[i][j] = dist[i][k] + dist[k][j];",
        "                }",
        "            }",
        "        }",
        "    }",
        "}"
      ]
    }
  }